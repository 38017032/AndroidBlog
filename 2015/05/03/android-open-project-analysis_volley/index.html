
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android 开源项目源码解析之Volley 源码解析 | Android博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 功能介绍1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 开源项目源码解析之Volley 源码解析">
<meta property="og:url" content="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/index.html">
<meta property="og:site_name" content="Android博客">
<meta property="og:description" content="1. 功能介绍1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/design.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/Volley-run-flow-chart.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley-class.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/RequestQueue-add-flow-chart.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/CacheDispatcher-run-flow-chart.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/NetworkDispatcher-run-flow-chart.png">
<meta property="og:image" content="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/response-process-flow-chart.png">
<meta property="og:updated_time" content="2015-07-11T08:20:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 开源项目源码解析之Volley 源码解析">
<meta name="twitter:description" content="1. 功能介绍1.1. VolleyVolley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。">
  
    <link rel="alternative" href="/AndroidBlog/atom.xml" title="Android博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="http://likebamboo.com/AndroidBlog/css/style.css" type="text/css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="http://likebamboo.com/AndroidBlog/" id="logo">Android博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="http://likebamboo.com/AndroidBlog/" id="subtitle">读万卷书</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="http://likebamboo.com/AndroidBlog/index.html">首页</a>
        
          <a class="main-nav-link" href="http://likebamboo.com/AndroidBlog/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/AndroidBlog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="likebamboo.com/AndroidBlog">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-android-open-project-analysis_volley" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/" class="article-date">
  <time datetime="2015-05-02T16:00:00.000Z" itemprop="datePublished">2015-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="http://likebamboo.com/AndroidBlog/categories/连载/">连载</a>►<a class="article-category-link" href="http://likebamboo.com/AndroidBlog/categories/连载/开源项目解析/">开源项目解析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android 开源项目源码解析之Volley 源码解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1-_Volley">1.1. Volley</h4><p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。<br><a id="more"></a></p>
<blockquote>
<p>名字由来：a burst or emission of many things or a large amount at once<br>发布演讲时候的配图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley.png" alt="Volley"></p>
</blockquote>
<p>从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合<strong>数据量小，通信频繁</strong>的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。</p>
<h4 id="1-2_Volley_的主要特点">1.2 Volley 的主要特点</h4><p>(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。<br>(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在<code>4.2.1 Volley</code>中具体介绍。<br>(4). 提供简便的图片加载工具。  </p>
<h3 id="2-_总体设计">2. 总体设计</h3><h4 id="2-1-_总体设计图">2.1. 总体设计图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/design.png" alt="总体设计图"><br>上面是 Volley 的总体设计图，主要是通过两种<code>Diapatch Thread</code>不断从<code>RequestQueue</code>中取出请求，根据是否已缓存调用<code>Cache</code>或<code>Network</code>这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由<code>ResponseDelivery</code>去做结果分发及回调处理。  </p>
<h4 id="2-2-_Volley_中的概念">2.2. Volley 中的概念</h4><p>简单介绍一些概念，在<code>详细设计</code>中会仔细介绍。<br>Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>后，只需要往这个<code>RequestQueue</code>不断 add Request 即可。  </p>
<p><strong>Volley：</strong>Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>。  </p>
<p><strong>Request：</strong>表示一个请求的抽象类。<code>StringRequest</code>、<code>JsonRequest</code>、<code>ImageRequest</code> 都是它的子类，表示某种类型的请求。  </p>
<p><strong>RequestQueue：</strong>表示请求队列，里面包含一个<code>CacheDispatcher</code>(用于处理走缓存请求的调度线程)、<code>NetworkDispatcher</code>数组(用于处理走网络请求的调度线程)，一个<code>ResponseDelivery</code>(返回结果分发接口)，通过 start() 函数启动时会启动<code>CacheDispatcher</code>和<code>NetworkDispatchers</code>。  </p>
<p><strong>CacheDispatcher：</strong>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p>
<p><strong>NetworkDispatcher：</strong>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理，并判断结果是否要进行缓存。  </p>
<p><strong>ResponseDelivery：</strong>返回结果分发接口，目前只有基于<code>ExecutorDelivery</code>的在入参 handler 对应线程内进行分发。  </p>
<p><strong>HttpStack：</strong>处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的<code>HurlStack</code>和 基于 Apache HttpClient 的<code>HttpClientStack</code>。  </p>
<p><strong>Network：</strong>调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。  </p>
<p><strong>Cache：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的<code>DiskBasedCache</code>。<code>NetworkDispatcher</code>得到请求结果后判断是否需要存储在 Cache，<code>CacheDispatcher</code>会从 Cache 中取缓存结果。  </p>
<h3 id="3-_流程图">3. 流程图</h3><p>Volley 请求流程图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/Volley-run-flow-chart.png" alt="Volley请求流程图">  </p>
<blockquote>
<p><strong>上图是 Volley 请求时的流程图，在  Volley 的发布演讲中给出，我在这里将其用中文重新画出。</strong>   </p>
</blockquote>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley-class.png" alt="类关系图"><br>这是 Volley 框架的主要类关系图    </p>
<blockquote>
<p>图中<strong>红色圈内</strong>的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以<strong>组合</strong>的方式结合在了一起。各个功能点也都是以<strong>接口</strong>或者<strong>抽象类</strong>的形式提供。<br>红色圈外面的部分，在 Volley 源码中放在了toolbox包中，作为 Volley 为各个功能点提供的默认的具体实现。<br>通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。</p>
<p><strong>多用组合，少用继承；针对接口编程，不针对具体实现编程。</strong>  </p>
<p><strong>优秀框架的设计，令人叫绝，受益良多。</strong>  </p>
</blockquote>
<h3 id="4-2_核心类功能介绍">4.2 核心类功能介绍</h3><h4 id="4-2-1_Volley-java">4.2.1 Volley.java</h4><p>这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的<code>RequestQueue</code>对象。<br><strong>(1). 主要函数</strong><br>Volley.java 有两个重载的静态方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。<br>第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现<code>BasicNetwork</code>。<br>接着构造一个代表缓存（Cache）的基于 Disk 的具体实现<code>DiskBasedCache</code>。<br>最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">queue.start();</span><br><span class="line"><span class="keyword">return</span> queue;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们平时大多采用<code>Volly.newRequestQueue(context)</code>的默认实现，构建RequestQueue。<br>通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的RequestQueue，采用自定义的<code>HttpStatck</code>，采用自定义的<code>Network</code>实现，采用自定义的Cache实现等来构建<code>RequestQueue</code>。<br><strong>优秀框架的高可拓展性的魅力来源于此啊</strong></p>
</blockquote>
<p><strong>(2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：</strong><br>在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。<br>另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。<br>再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。  </p>
<p><strong>(3). 关于 User Agent</strong><br>通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？<br>如果用 <a href="http://www.trinea.cn/android/android-network-sniffer/" target="_blank" rel="external">Fiddler 或 Charles</a> 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S)</span><br></pre></td></tr></table></figure></p>
<p>经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userAgent = System.getProperty(<span class="string">"http.agent"</span>);</span><br></pre></td></tr></table></figure></p>
<p>得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; getHeaders() <span class="keyword">throws</span> AuthFailureError &#123;</span><br><span class="line">    <span class="comment">// self-defined user agent</span></span><br><span class="line">    Map&lt;String, String&gt; headerMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    headerMap.put(<span class="string">"User-Agent"</span>, <span class="string">"android-open-project-analysis/1.0"</span>);</span><br><span class="line">    <span class="keyword">return</span> headerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-2_Request-java">4.2.2 Request.java</h4><p>代表一个网络请求的抽象类。我们通过构建一个<code>Request</code>类的非抽象子类(StringRequest、JsonRequest、ImageRequest或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。<br>Volley 支持 8 种 Http 请求方式 <strong>GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH</strong><br>Request 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。  </p>
<p><strong>因为是抽象类，子类必须重写的两个方法。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br></pre></td></tr></table></figure>
<p>子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。</p>
<p><strong>以下两个方法也经常会被重写</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBody()</span><br></pre></td></tr></table></figure></p>
<p>重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; getParams()</span><br></pre></td></tr></table></figure></p>
<p>在上面<code>getBody</code>函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。  </p>
<h4 id="4-2-3_RequestQueue-java">4.2.3 RequestQueue.java</h4><p>Volley 框架的核心类，将请求Request加入到一个运行的<code>RequestQueue</code>中，来完成请求操作。</p>
<h4 id="(1)-_主要成员变量">(1). 主要成员变量</h4><p>RequestQueue 中维护了两个<strong>基于优先级</strong>的 Request 队列，缓存请求队列和网络请求队列。<br>放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>维护了一个正在进行中，尚未完成的请求集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="(2)-_启动队列">(2). 启动队列</h4><p>创建出 RequestQueue 以后，调用 start 方法，启动队列。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Starts the dispatchers in this queue.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start 方法中，开启一个<strong>缓存调度线程<code>CacheDispatcher</code></strong>和 n 个<strong>网络调度线程<code>NetworkDispatcher</code></strong>，这里 n 默认为4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。<br>缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。  </p>
<h4 id="(3)-_加入请求">(3). 加入请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span></span>;</span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/RequestQueue-add-flow-chart.png" alt="加入请求流程图">  </p>
<h4 id="(4)-_请求完成">(4). 请求完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span></span></span><br></pre></td></tr></table></figure>
<p>Request 请求结束  </p>
<blockquote>
<p>(1). 首先从正在进行中请求集合<code>mCurrentRequests</code>中移除该请求。<br>(2). 然后查找请求等待集合<code>mWaitingRequests</code>中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程<code>CacheDispatcher</code>自动处理。  </p>
</blockquote>
<h4 id="(5)-_请求取消">(5). 请求取消</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(RequestFilter filter)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(<span class="keyword">final</span> Object tag)</span></span></span><br></pre></td></tr></table></figure>
<p>取消当前请求集合中所有符合条件的请求。<br>filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。<br>tag 表示按照<code>Request.setTag</code>设置好的 tag 取消请求，比如同属于某个 Activity 的。  </p>
<h4 id="4-2-4_CacheDispatcher-java">4.2.4 CacheDispatcher.java</h4><p>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p>
<h4 id="(1)-_成员变量">(1). 成员变量</h4><p><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> 缓存请求队列<br><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> 网络请求队列<br><code>Cache mCache</code> 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类  </p>
<h4 id="(2)-_处理流程图">(2). 处理流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/CacheDispatcher-run-flow-chart.png" alt="缓存调度线程处理流程图">  </p>
<h4 id="4-2-5_NetworkDispatcher-java">4.2.5 NetworkDispatcher.java</h4><p>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<h4 id="(1)-_成员变量-1">(1). 成员变量</h4><p><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue</code> 网络请求队列<br><code>Network mNetwork</code> 网络类，代表了一个可以执行请求的网络<br><code>Cache mCache</code>  缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类，可以传递请求的结果或者错误到调用者  </p>
<h4 id="(2)-_处理流程图-1">(2). 处理流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/NetworkDispatcher-run-flow-chart.png" alt="网络调度线程处理流程图">  </p>
<h4 id="4-2-6_Cache-java">4.2.6 Cache.java</h4><p>缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。</p>
<h4 id="(1)-_主要方法：">(1). 主要方法：</h4><p><code>public Entry get(String key);</code> 通过 key 获取请求的缓存实体<br><code>public void put(String key, Entry entry);</code> 存入一个请求的缓存实体<br><code>public void remove(String key);</code> 移除指定的缓存实体<br><code>public void clear();</code> 清空缓存  </p>
<h4 id="(2)-_代表缓存实体的内部类_Entry">(2). 代表缓存实体的内部类 Entry</h4><p>成员变量和方法<br><code>byte[] data</code> 请求返回的数据（Body 实体）<br><code>String etag</code> Http 响应首部中用于缓存新鲜度验证的 ETag<br><code>long serverDate</code> Http 响应首部中的响应产生时间<br><code>long ttl</code> 缓存的过期时间<br><code>long softTtl</code> 缓存的新鲜时间<br><code>Map&lt;String, String&gt; responseHeaders</code> 响应的 Headers<br><code>boolean isExpired()</code> 判断缓存是否过期，过期缓存不能继续使用<br><code>boolean refreshNeeded()</code> 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测  </p>
<h4 id="4-2-7_DiskBasedCache-java">4.2.7 DiskBasedCache.java</h4><p>继承 Cache 类，基于 Disk 的缓存实现类。</p>
<h4 id="(1)-_主要方法：-1">(1). 主要方法：</h4><p><code>public synchronized void initialize()</code> 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。<br><code>public synchronized Entry get(String key)</code> 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。<br><code>public synchronized void put(String key, Entry entry)</code> 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。<br><code>private void pruneIfNeeded(int neededSpace)</code> 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。<br><code>public synchronized void clear()</code> 清空缓存。<br><code>public synchronized void remove(String key)</code> 删除缓存中某个元素。  </p>
<h4 id="(2)-_CacheHeader_类">(2). CacheHeader 类</h4><p>CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的<code>Cache.Entry</code>相似。  </p>
<h4 id="4-2-8_NoCache-java">4.2.8 NoCache.java</h4><p>继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建<code>RequestQueue</code>的参数以实现一个不带缓存的请求队列。  </p>
<h4 id="4-2-9_Network-java">4.2.9 Network.java</h4><p>代表网络的接口，处理网络请求。<br>唯一的方法，用于执行特定请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-10_NetworkResponse-java">4.2.10 NetworkResponse.java</h4><p><code>Network</code>中方法 performRequest 的返回值，<code>Request</code>的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。<br>封装了网络请求响应的 StatusCode，Headers 和 Body 等。  </p>
<h4 id="(1)-_成员变量-2">(1). 成员变量</h4><p><code>int statusCode</code> Http 响应状态码<br><code>byte[] data</code> Body 数据<br><code>Map&lt;String, String&gt; headers</code> 响应 Headers<br><code>boolean notModified</code> 表示是否为 304 响应<br><code>long networkTimeMs</code> 请求耗时  </p>
<h4 id="(2)-_Volley_的内部_Response_转换流程图">(2). Volley 的内部 Response 转换流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/response-process-flow-chart.png" alt="Volley"><br>从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。  </p>
<h4 id="4-2-11_BasicNetwork-java">4.2.11 BasicNetwork.java</h4><p>实现 Network，Volley 中默认的网络接口实现类。调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。<br>主要实现了以下功能：<br>(1). 利用 HttpStack 执行网络请求。<br>(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。<br>(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。  </p>
<h4 id="4-2-12_HttpStack-java">4.2.12 HttpStack.java</h4><p>用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。<br>唯一方法，执行请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br></pre></td></tr></table></figure></p>
<p>执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。  </p>
<h4 id="4-2-13_HttpClientStack-java">4.2.13 HttpClientStack.java</h4><p>实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。<br>基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。  </p>
<h4 id="4-2-14_HurlStack-java">4.2.14 HurlStack.java</h4><p>实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。  </p>
<h4 id="4-2-15_Response-java">4.2.15 Response.java</h4><p>封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。<br>Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。  </p>
<h4 id="4-2-16_ByteArrayPool-java">4.2.16 ByteArrayPool.java</h4><p>byte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。<br>主要通过一个元素长度从小到大排序的<code>ArrayList</code>作为 byte[] 的缓存，另有一个按使用时间先后排序的<code>ArrayList</code>属性用于缓存满时清理元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span></span></span><br></pre></td></tr></table></figure></p>
<p>将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure></p>
<p>获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数<code>len</code>的 byte[]，并返回；如果最终没有合适的byte[]，new 一个返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。  </p>
<h4 id="4-2-17_PoolingByteArrayOutputStream-java">4.2.17 PoolingByteArrayOutputStream.java</h4><p>继承ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。  </p>
<h4 id="4-2-18_HttpHeaderParser-java">4.2.18 HttpHeaderParser.java</h4><p>Http header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。<br>有三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parseDateAsEpoch</span><span class="params">(String dateStr)</span></span></span><br></pre></td></tr></table></figure></p>
<p>解析时间，将 RFC1123 的时间格式，解析成 epoch 时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers)</span></span></span><br></pre></td></tr></table></figure>
<p>解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>比较重要的方法</strong>，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有<code>no-cache</code>或<code>no-store</code>表示不缓存，返回 null。<br>(1). 根据 Date 首部，获取响应生成时间<br>(2). 根据 ETag 首部，获取响应实体标签<br>(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间</p>
<blockquote>
<p>两点需要说明下：<br>1.没有处理<code>Last-Modify</code>首部，而是处理存储了<code>Date</code>首部，并在后续的新鲜度验证时，使用<code>Date</code>来构建<code>If-Modified-Since</code>。<br>这与 Http 1.1 的语义有些违背。<br>2.计算过期时间，Cache－Control 首部优先于 Expires 首部。  </p>
</blockquote>
<h4 id="4-2-19_RetryPolicy-java">4.2.19 RetryPolicy.java</h4><p>重试策略接口<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>获取当前请求用时（用于Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>获取已经重试的次数（用于Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p>
<p>确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。  </p>
<h4 id="4-2-20_DefaultRetryPolicy-java">4.2.20 DefaultRetryPolicy.java</h4><p>实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。<br>其中<code>mCurrentTimeoutMs</code>变量表示已经重试次数。<br><code>mBackoffMultiplier</code>表示每次重试之前的 timeout 该乘以的因子。<br><code>mCurrentTimeoutMs</code>变量表示当前重试的 timeout 时间，会以<code>mBackoffMultiplier</code>作为因子累计前几次重试的 timeout。  </p>
<h4 id="4-2-21_ResponseDelivery-java">4.2.21 ResponseDelivery.java</h4><p>请求结果的传输接口，用于传递请求结果或者请求错误。<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传递请求结果，<code>request</code> 和 <code>response</code> 参数分别表示请求信息和返回结果信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传递请求结果，并在完成传递后执行 Runnable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传输请求错误。  </p>
<h4 id="4-2-22_ExecutorDelivery-java">4.2.22 ExecutorDelivery.java</h4><p>请求结果传输接口具体实现类。<br>在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。  </p>
<h4 id="4-2-23_StringRequest-java">4.2.23 StringRequest.java</h4><p>继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。  </p>
<h4 id="4-2-24_JsonRequest-java">4.2.24 JsonRequest.java</h4><p>抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。  </p>
<h4 id="4-2-25_JsonObjectRequest-java">4.2.25 JsonObjectRequest.java</h4><p>继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。  </p>
<h4 id="4-2-26_JsonArrayRequest-java">4.2.26 JsonArrayRequest.java</h4><p>继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。  </p>
<h4 id="4-2-27_ImageRequest-java">4.2.27 ImageRequest.java</h4><p>继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。<br>可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。  </p>
<h4 id="4-2-28_ImageLoader-java">4.2.28 ImageLoader.java</h4><p>封装了 ImageRequst 的方便使用的图片加载工具类。 </p>
<blockquote>
<p>1.可以设置自定义的<code>ImageCache</code>，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。<br>2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。<br>3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。<br>// TODO  </p>
</blockquote>
<h4 id="4-2-29_NetworkImageView-java">4.2.29 NetworkImageView.java</h4><p>利用 ImageLoader，可以加载网络图片的 ImageView<br>有三个公开的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultImageResId</span><span class="params">(<span class="keyword">int</span> defaultImage)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置默认图片，加载图片过程中显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorImageResId</span><span class="params">(<span class="keyword">int</span> errorImage)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置错误图片，加载图片失败后显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(String url, ImageLoader imageLoader)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。  </p>
<blockquote>
<p>如果有新的图片加载请求，会把这个ImageView上旧的加载请求取消。  </p>
</blockquote>
<h4 id="4-2-30_ClearCacheRequest-java">4.2.30 ClearCacheRequest.java</h4><p>用于人为清空 Http 缓存的请求。<br>添加到 RequestQueue 后能很快执行，因为优先级很高，为<code>Priority.IMMEDIATE</code>。并且清空缓存的方法<code>mCache.clear()</code>写在了<code>isCanceled()</code>方法体中，能最早的得到执行。  </p>
<p>ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在<code>isCanceled()</code>中做清空操作本身就造成了歧义，不看源码没人知道在<code>NetworkDispatcher</code> run 方法循环的过程中，<code>isCanceled()</code>这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。  </p>
<h4 id="4-2-31_Authenticator-java">4.2.31 Authenticator.java</h4><p>身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。  </p>
<h4 id="4-2-32_AndroidAuthenticator-java">4.2.32 AndroidAuthenticator.java</h4><p>继承 Authenticator，基于 Android AccountManager 的认证交互实现类。  </p>
<h4 id="4-2-33_VolleyLog-java">4.2.33 VolleyLog.java</h4><p>Volley 的 Log 工具类。  </p>
<h4 id="4-2-34_VolleyError-java">4.2.34 VolleyError.java</h4><p>Volley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。  </p>
<h4 id="4-2-35_AuthFailureError-java">4.2.35 AuthFailureError.java</h4><p>继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。  </p>
<h4 id="4-2-36_NetworkError-java">4.2.36 NetworkError.java</h4><p>继承自 VolleyError，代表网络错误。  </p>
<h4 id="4-2-37_ParseError-java">4.2.37 ParseError.java</h4><p>继承自 VolleyError，代表内容解析错误。  </p>
<h4 id="4-2-38_ServerError-java">4.2.38 ServerError.java</h4><p>继承自 VolleyError，代表服务端错误。  </p>
<h4 id="4-2-39_TimeoutError-java">4.2.39 TimeoutError.java</h4><p>继承自 VolleyError，代表请求超时错误。  </p>
<h4 id="4-2-40_NoConnectionError-java">4.2.40 NoConnectionError.java</h4><p>继承自NetworkError，代表无法建立连接错误。  </p>
<h3 id="5-_杂谈">5. 杂谈</h3><h4 id="5-1_关于_Http_缓存">5.1 关于 Http 缓存</h4><p>Volley 构建了一套相对完整的符合 Http 语义的缓存机制。<br><strong>优点和特点</strong><br>(1). 根据<code>Cache-Control</code>和<code>Expires</code>首部来计算缓存的过期时间。如果两个首部都存在情况下，以<code>Cache-Control</code>为准。<br>(2). 利用<code>If-None-Match</code>和<code>If-Modified-Since</code>对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。<br>(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。</p>
<p><strong>我个人认为的不足之处</strong><br>缓存的再验证方面，在构建<code>If-Modified-Since</code>请求首部时，Volley 使用了服务端响应的<code>Date</code>首部，没有使用<code>Last-Modified</code>首部。整个框架没有使用<code>Last-Modified</code>首部。这与 Http 语义不符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">        headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端根据请求时通过<code>If-Modified-Since</code>首部传过来的时间，判断资源文件是否在<code>If-Modified-Since</code>时间 <strong>以后</strong> 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。<br><code>Last-Modified</code>代表了资源文件的最后修改时间。通常使用这个首部构建<code>If-Modified-Since</code>的时间。<br><code>Date</code>代表了响应产生的时间，正常情况下<code>Date</code>时间在<code>Last-Modified</code>时间之后。也就是<code>Date</code>&gt;=<code>Last-Modified</code>。<br>通过以上原理，既然<code>Date</code>&gt;=<code>Last-Modified</code>。那么我利用<code>Date</code>构建，也是完全正确的。  </p>
<p><strong>可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证<code>If-Modified-Since</code>，判断服务器资源文件修改时间是不是在<code>If-Modified-Since</code>之后。那么使用<code>Date</code>完全正确。</strong><br><strong>可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和<code>If-Modified-Since</code>所传时间相等。这样使用<code>Date</code>就不能实现正确的再验证，因为<code>Date</code>的时间总不会和服务器资源文件修改时间相等。</strong>  </p>
<p>尽管使用<code>Date</code>可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。<br><strong>但我还是希望Volley也能完全正确的实现Http语义，至少同时处理<code>Last-Modified</code>和<code>Date</code>,并且优先使用<code>Last-Modified</code>。</strong>  </p>
<h4 id="5-2_Bug">5.2 Bug</h4><h5 id="(1)-_BasicNetwork-performRequest(…)">(1). BasicNetwork.performRequest(…)</h5><p>如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">            NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ……</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BasicNetwork.performRequest(…) 最后的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br></pre></td></tr></table></figure></p>
<p>应该是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(e);</span><br></pre></td></tr></table></figure></p>
<p>更合理。  </p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 Volley 部分<br>项目地址：<a href="https://android.googlesource.com/platform/frameworks/volley/" target="_blank" rel="external">Volley</a>，分析的版本：<a href="https://android.googlesource.com/platform/frameworks/volley/+/35ce77836d8e1e951b8e4b2ec43e07fb7336dab6" target="_blank" rel="external">35ce778</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/volley-demo" target="_blank" rel="external">Volley Demo</a><br>分析者：<a href="https://github.com/grumoon" target="_blank" rel="external">grumoon</a>，校对者：<a href="https://github.com/huxian99" target="_blank" rel="external">huxian99</a>、<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对状态：完成   </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/" data-id="cibyut6j1007g181ib3xzk03e" class="article-share-link" data-share="baidu">分享到</a>
      

      
        <a href="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/开源项目解析/">开源项目解析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_universal-image-loader/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          Android 开源项目源码解析之Universal Image Loader 源码分析
        
      </div>
    </a>
  
  
    <a href="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_xUtils/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Android 开源项目源码解析之xUtils 源码解析</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2015/05/03/android-open-project-analysis_volley/" data-title="Android 开源项目源码解析之Volley 源码解析" data-url="http://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/AndroidIDE/">AndroidIDE</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/Android架构/">Android架构</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/Reactive-Extension-RX/">Reactive Extension(RX)</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/单元测试/">单元测试</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/翻译/">翻译</a><span class="category-list-count">47</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/翻译/单元测试/">单元测试</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/翻译/自动化测试/">自动化测试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/翻译/连载/">连载</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/自动化测试/">自动化测试</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/设计模式/">设计模式</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/连载/">连载</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="http://likebamboo.com/AndroidBlog/categories/连载/开源项目解析/">开源项目解析</a><span class="category-list-count">15</span></li></ul></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Android-Studio/">Android Studio</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Android架构/">Android架构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/AppCompat/">AppCompat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/AsyncTask/">AsyncTask</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Builder模式/">Builder模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/CodeReview/">CodeReview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Drawables/">Drawables</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/MVP/">MVP</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/MVVM/">MVVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Proxy模式/">Proxy模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/">RxJava/RxAndroid</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/Support-Library/">Support Library</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/SupportLibrary/">SupportLibrary</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/主题/">主题</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/任务调度/">任务调度</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/依赖注入/">依赖注入</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/内存泄露/">内存泄露</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/动画/">动画</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/单例模式/">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/原型模式/">原型模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/图形管道/">图形管道</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/图片缓存/">图片缓存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/基础/">基础</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/外观模式/">外观模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/多进程/">多进程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/字体/">字体</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/小技巧/">小技巧</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/工具/">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/开源库介绍/">开源库介绍</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/开源项目解析/">开源项目解析</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/性能优化/">性能优化</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/拍照/">拍照</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/材料设计/">材料设计</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/桥接模式/">桥接模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/模板方法模式/">模板方法模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/测试/">测试</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/特效/">特效</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/策略模式/">策略模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/网络请求/">网络请求</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/翻译/">翻译</a><span class="tag-list-count">23</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/自动化/">自动化</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/视频/">视频</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/责任链模式/">责任链模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/连载/">连载</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="http://likebamboo.com/AndroidBlog/tags/迭代器模式/">迭代器模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="http://likebamboo.com/AndroidBlog/archives/2015/05/">五月 2015</a><span class="archive-list-count">63</span></li><li class="archive-list-item"><a class="archive-list-link" href="http://likebamboo.com/AndroidBlog/archives/2015/04/">四月 2015</a><span class="archive-list-count">28</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://likebamboo.com/AndroidBlog/2015/05/29/introduction-to-model-view-presenter-on-android/">MVP在Android平台上的应用</a>
          </li>
        
          <li>
            <a href="http://likebamboo.com/AndroidBlog/2015/05/29/how-to-make-our-android-apps-unit-testable-pt-2/">Android 进行单元测试难在哪-part4</a>
          </li>
        
          <li>
            <a href="http://likebamboo.com/AndroidBlog/2015/05/29/ted_mosby/">Ted Mosby - 软件架构</a>
          </li>
        
          <li>
            <a href="http://likebamboo.com/AndroidBlog/2015/05/29/when-Thor-and-Hulk-meet-dagger2-rxjava-1/">当复仇者联盟遇上Dragger2、RxJava和Retrofit的巧妙结合</a>
          </li>
        
          <li>
            <a href="http://likebamboo.com/AndroidBlog/2015/05/29/automating-android-development/">自动化 Android 开发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 likebamboo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="http://likebamboo.com/AndroidBlog/index.html" class="mobile-nav-link">首页</a>
  
    <a href="http://likebamboo.com/AndroidBlog/archives" class="mobile-nav-link">归档</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="http://likebamboo.com/AndroidBlog/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"likebamboo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>window._bd_share_config={"common":{},"share":{"bdCustomStyle":"http://likebamboo.com/AndroidBlog/css/bdshare.css"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="http://likebamboo.com/AndroidBlog/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
