<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Android博客]]></title>
  <subtitle><![CDATA[读万卷书]]></subtitle>
  <link href="http://likebamboo.com/AndroidBlog/atom.xml" rel="self"/>
  <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//"/>
  <updated>2015-06-29T14:12:22.000Z</updated>
  <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//</id>
  
  <author>
    <name><![CDATA[likebamboo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[开始学习Material Design]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-getting-started-with-material-design/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-getting-started-with-material-design/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:12:22.000Z</updated>
    <content type="html"><![CDATA[<p>你可能已经听说过Android Lollipop中引入的Material Design.Material Design引入了很多新的东西，如Material 主题, 新的控件, 自定义阴影, 矢量绘制 and 自定义动画.如果你还没用过Material Design，那么本文很适合你。<br><a id="more"></a><br>我们将在本文中学习Material Design开发的基本步骤:编写自定义主题和用RecyclerView实现navigation drawer.</p>
<p>在下面的链接中，你能够学到更多有关Material Design的知识  </p>
<p><a href="http://www.google.com/design/spec/material-design/introduction.html#" target="_blank" rel="external">Material Design Specifications</a>  </p>
<p><a href="http://developer.android.com/training/material/index.html" target="_blank" rel="external">Creating Apps with Material Design</a>  </p>
<p><a href="http://download.androidhive.info/download?code=WPSkdrdZprHT0KLCZS3ClafgXBikGqM4r7FnNYdsdUTmlAkK6%2F2mkT0heOlNOq4U82rzqbod%2F14yU2uk5TWY4Zp%2FAYx6oiD7SKI%2FEgtUapzQUqkqcWEXX1bmw%3D%3DvqARiMEKqkqsXGbVf3vVUoffTqQcD2qfqZo" target="_blank" rel="external">Code</a></p>
<p><a href="http://www.youtube.com/embed/jDXX_wDvarM" target="_blank" rel="external">Video</a></p>
<h3 id="1-下载AndroidStudio">1.下载AndroidStudio</h3><p>再往下走之前，先下载Android Studio，并配置好本文之前提到的东西，如果你是首次使用Android Studio，先去看看文档.</p>
<h3 id="2-Material_Design_颜色自定义">2.Material Design 颜色自定义</h3><p>Material Deisgin提供以下系列自定义Material Deisign 颜色主题的属性，但本文只使用5种基本属性来自定义整体的主题</p>
<p>colorPrimaryDark - 这是app中最黑的基本色，主要用来做notification bar的背景.</p>
<p>colorPrimary - 这是app的基本颜色,将用作toolbar的背景色</p>
<p>textColorPrimary - 文本颜色,用于toolbar的标题</p>
<p>windowBackground - app默认的背景颜色</p>
<p>navigationBarColor - 这个颜色定义了navigation bar页脚的背景色.  </p>
<p><img src="http://cdn2.androidhive.info/wp-content/uploads/2015/04/android-material-design-color-schema.png" alt=""></p>
<p>你能选择适合你APP风格的颜色</p>
<h3 id="3-创建Material_Design_主题">3.创建Material Design 主题</h3><p>1.在as中，创建新项目,选择BlankActivity.</p>
<p>2.打开res-&gt;values-&gt;strings.xml 添加以下字符值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">strings.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"app_name"</span>&gt;</span>Material Design<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"action_settings"</span>&gt;</span>Settings<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"action_search"</span>&gt;</span>Search<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"drawer_open"</span>&gt;</span>Open<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"drawer_close"</span>&gt;</span>Close<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"nav_item_home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"nav_item_friends"</span>&gt;</span>Friends<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"nav_item_notifications"</span>&gt;</span>Messages<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- navigation drawer item labels  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string-array</span> <span class="attribute">name</span>=<span class="value">"nav_drawer_labels"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span>&gt;</span>@string/nav_item_home<span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span>&gt;</span>@string/nav_item_friends<span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span>&gt;</span>@string/nav_item_notifications<span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">string-array</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"title_messages"</span>&gt;</span>Messages<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"title_friends"</span>&gt;</span>Friends<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"title_home"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span>  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">3.打开res-&gt;values-&gt;colors 添加以下颜色,如果你没有找到colors.xml文件，那么新建一个.</span><br><span class="line">   </span><br><span class="line">```xml </span><br><span class="line">colors.xml  </span><br><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#F50057<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#C51162<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColorPrimary"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"windowBackground"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"navigationBarColor"</span>&gt;</span>#000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF80AB<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span>  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">4. 打开 dimens.xml文件，加入以下代码</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">```xml  </span><br><span class="line">dimens.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Default screen margins, per the Android Design guidelines. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dimen</span> <span class="attribute">name</span>=<span class="value">"activity_horizontal_margin"</span>&gt;</span>16dp<span class="tag">&lt;/<span class="title">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dimen</span> <span class="attribute">name</span>=<span class="value">"activity_vertical_margin"</span>&gt;</span>16dp<span class="tag">&lt;/<span class="title">dimen</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dimen</span> <span class="attribute">name</span>=<span class="value">"nav_drawer_width"</span>&gt;</span>260dp<span class="tag">&lt;/<span class="title">dimen</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5.打开styles.xml文件加入以下代码，在这里定义的style对于所有的androidbanben都是通用的。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">styles.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"MyMaterialTheme"</span> <span class="attribute">parent</span>=<span class="value">"MyMaterialTheme.Base"</span>&gt;</span><span class="css"></span><br><span class="line"> </span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"MyMaterialTheme.Base"</span> 				<span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="rule"><span class="attribute">android</span>:<span class="value">windowNoTitle<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>windowActionBar<span class="string">"&gt;false&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>colorPrimary<span class="string">"&gt;@color/colorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>colorPrimaryDark<span class="string">"&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>colorAccent<span class="string">"&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">    </span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>6.在res目录下，创建一个values-v21目录,并styles.xml<br>文件夹,这些style仅仅用于Android Lollipop</p>
<p>styles.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"MyMaterialTheme"</span> <span class="attribute">parent</span>=<span class="value">"MyMaterialTheme.Base"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="rule"><span class="attribute">android</span>:<span class="value">windowContentTransitions<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>android:windowAllowEnterTransitionOverlap<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item   name="</span>android:windowAllowReturnTransitionOverlap<span class="string">"&gt;true&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>android:windowSharedElementEnterTransition<span class="string">"&gt;@android:transition/move&lt;/item&gt;</span><br><span class="line">        &lt;item name="</span>android:windowSharedElementExitTransition<span class="string">"&gt;@android:transition/move&lt;/item&gt;</span><br><span class="line">    </span></span></span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>7.现在我们已经准备好Material Design style了， 为了使用这主题, 在AndroidManifest.xml文件中修改application theme属性如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AndroidManifest.xml</span><br><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">package</span>=<span class="value">"androidhive.info.materialdesign"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">        <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:icon</span>=<span class="value">"@mipmap/ic_launcher"</span></span><br><span class="line">        <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">        <span class="attribute">android:theme</span>=<span class="value">"@style/MyMaterialTheme"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">".activity.MainActivity"</span></span><br><span class="line">            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在如果你运行app，你能看到notification的颜色已经变成我们在style中设置的颜色.</p>
<p><img src="http://cdn4.androidhive.info/wp-content/uploads/2015/04/android-material-design-notification-bar.png" alt=""></p>
<h3 id="3-1_添加工具栏_(Action_Bar)">3.1 添加工具栏 (Action Bar)</h3><p>添加toolbar很简单,你要做的只是为toolbar另外创建一个layout,然后你想在哪里显示它，就在那个页面布局中include它</p>
<p>8.在layout目录下创建toolbar.xml, 在里面添加android.support.v7.widget.Toolbar，并设置宽高.代码如下：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toolbar.xml</span><br><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">android.support.v7.widget.Toolbar</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:local</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/toolbar"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:minHeight</span>=<span class="value">"?attr/actionBarSize"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"?attr/colorPrimary"</span></span><br><span class="line">    <span class="attribute">local:theme</span>=<span class="value">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span></span><br><span class="line">    <span class="attribute">local:popupTheme</span>=<span class="value">"@style/ThemeOverlay.AppCompat.Light"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>9.打开你的main activiy的布局,添加如下代码: </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">activity_main.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentTop</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">include</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/toolbar"</span></span><br><span class="line">            <span class="attribute">layout</span>=<span class="value">"@layout/toolbar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://cdn4.androidhive.info/wp-content/uploads/2015/04/android-material-design-toolbar1.png" alt=""> </p>
<p>现在让我尝试添加toolbard额标题，并启用它的行为。  </p>
<p>10.下载相关图片资源，然后导入到AS当中作为Image Asset.</p>
<p>11.导入Image asset步骤,右键res目录-&gt;new-&gt;Image Asset 之后显示弹窗，然后找到你已经下载好的图片,选择Action Bar 和 Tab Icons， 给资源命名为ic_search_action. 如下图 </p>
<p><img src="http://cdn3.androidhive.info/wp-content/uploads/2015/04/android-studio-importing-image-asset.png" alt=""> </p>
<p>12.一旦图片导入了，打开menu_main.xml 添加seach menu item,代码如下：   </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">menu_main.xml  </span><br><span class="line"><span class="tag">&lt;<span class="title">menu</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/action_search"</span></span><br><span class="line">        <span class="attribute">android:title</span>=<span class="value">"@string/action_search"</span></span><br><span class="line">        <span class="attribute">android:orderInCategory</span>=<span class="value">"100"</span></span><br><span class="line">        <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_action_search"</span></span><br><span class="line">        <span class="attribute">app:showAsAction</span>=<span class="value">"ifRoom"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/action_settings"</span></span><br><span class="line">        <span class="attribute">android:title</span>=<span class="value">"@string/action_settings"</span></span><br><span class="line">        <span class="attribute">android:orderInCategory</span>=<span class="value">"100"</span></span><br><span class="line">        <span class="attribute">app:showAsAction</span>=<span class="value">"never"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>13.打开MainActivity.java做以下修改.</p>
<p>MainActivity从ACtionBarAcitiv继承</p>
<p>调用setSupportActionBar()来启用toolbar</p>
<p>复写onCreateOptionsMenu() 和 onOptionsItemSelected()来启动toolbar菜单子目录的行为。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MainActivity.java</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Toolbar mToolbar;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">        mToolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line"> </span><br><span class="line">        setSupportActionBar(mToolbar);</span><br><span class="line">        getSupportActionBar().setDisplayShowHomeEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>添加以上代码后，运行APP，你应该能够看到如下图所示的效果  </p>
<p><img src="http://cdn1.androidhive.info/wp-content/uploads/2015/04/android-material-design-toolbar-action-items.png?" alt=""></p>
<h3 id="3-2添加Navigation_Drawer">3.2添加Navigation Drawer</h3><p>添加Natigation Drawer的方式跟lollipop以前一样,但我们使用RecyclerView来实现Menu Items.  </p>
<p>14.在java文件下创建三个包，分别命名为activity,adapter,model,把MainActivity移到activity包种，这样整个项目看起来就更有组织性。 </p>
<p>15.在build.gradle中添加以下依赖库  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">build.gradle</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:22.0.0'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:recyclerview-v7:21.0.+'</span></span><br><span class="line">&#125;  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="number">16</span>.在model包下添加NavDrawerItem.java文件作为menuItem,代码如下：   </span><br><span class="line">  </span><br><span class="line">```java  </span><br><span class="line">NavDrawerItem.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NavDrawerItem &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> showNotify;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> NavDrawerItem() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> NavDrawerItem(<span class="keyword">boolean</span> showNotify, String title) &#123;</span><br><span class="line">        <span class="keyword">this</span>.showNotify = showNotify;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isShowNotify() &#123;</span><br><span class="line">        <span class="keyword">return</span> showNotify;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setShowNotify(<span class="keyword">boolean</span> showNotify) &#123;</span><br><span class="line">        <span class="keyword">this</span>.showNotify = showNotify;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String getTitle() &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setTitle(String title) &#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17.添加nav_drawer_row.xml布局文件,代码如下：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:clickable</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/title"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:paddingLeft</span>=<span class="value">"30dp"</span></span><br><span class="line">        <span class="attribute">android:paddingTop</span>=<span class="value">"10dp"</span></span><br><span class="line">        <span class="attribute">android:paddingBottom</span>=<span class="value">"10dp"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"15dp"</span></span><br><span class="line">        <span class="attribute">android:textStyle</span>=<span class="value">"bold"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>18.下载这个图片,这图片用在导航栏的头部  </p>
<p><img src="http://api.androidhive.info/images/ic_profile.pn" alt=""></p>
<p>19.创建另一个布局文件fragment_navigation_drawer.xml,如下代码:  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">fragment_navigation_drawer.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@android:color/white"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">RelativeLayout</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/nav_header_container"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"140dp"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentTop</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:background</span>=<span class="value">"@color/colorPrimary"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"70dp"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"70dp"</span></span><br><span class="line">            <span class="attribute">android:src</span>=<span class="value">"@drawable/ic_profile"</span></span><br><span class="line">            <span class="attribute">android:scaleType</span>=<span class="value">"fitCenter"</span></span><br><span class="line">            <span class="attribute">android:layout_centerInParent</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/drawerList"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/nav_header_container"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"15dp"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>20.由于RecyclerView是自定义的，我们需要创建一个Adapter来渲染自定的布局, 因此创建NavigationDrawerAdapter.java文件  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigationDrawerAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">NavigationDrawerAdapter</span>.<span class="title">MyViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    List&lt;NavDrawerItem&gt; data = Collections.emptyList();</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater inflater;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NavigationDrawerAdapter</span><span class="params">(Context context, List&lt;NavDrawerItem&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        inflater = LayoutInflater.from(context);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        data.remove(position);</span><br><span class="line">        notifyItemRemoved(position);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.nav_drawer_row, parent, <span class="keyword">false</span>);</span><br><span class="line">        MyViewHolder holder = <span class="keyword">new</span> MyViewHolder(view);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(MyViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        NavDrawerItem current = data.get(position);</span><br><span class="line">        holder.title.setText(current.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        TextView title;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(itemView);</span><br><span class="line">            title = (TextView) itemView.findViewById(R.id.title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>21.在adapter包下创建FragmentDrawer.java，代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">FragmentDrawer.java  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentDrawer</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = FragmentDrawer.class.getSimpleName();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> RecyclerView recyclerView;</span><br><span class="line">    <span class="keyword">private</span> ActionBarDrawerToggle mDrawerToggle;</span><br><span class="line">    <span class="keyword">private</span> DrawerLayout mDrawerLayout;</span><br><span class="line">    <span class="keyword">private</span> NavigationDrawerAdapter adapter;</span><br><span class="line">    <span class="keyword">private</span> View containerView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] titles = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> FragmentDrawerListener drawerListener;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FragmentDrawer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawerListener</span><span class="params">(FragmentDrawerListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawerListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;NavDrawerItem&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;NavDrawerItem&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// preparing navigation drawer items</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; titles.length; i++) &#123;</span><br><span class="line">            NavDrawerItem navItem = <span class="keyword">new</span> NavDrawerItem();</span><br><span class="line">            navItem.setTitle(titles[i]);</span><br><span class="line">            data.add(navItem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// drawer labels</span></span><br><span class="line">        titles = getActivity().getResources().getStringArray(R.array.nav_drawer_labels);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflating view layout</span></span><br><span class="line">        View layout = inflater.inflate(R.layout.fragment_navigation_drawer, container, <span class="keyword">false</span>);</span><br><span class="line">        recyclerView = (RecyclerView) layout.findViewById(R.id.drawerList);</span><br><span class="line"> </span><br><span class="line">        adapter = <span class="keyword">new</span> NavigationDrawerAdapter(getActivity(), getData());</span><br><span class="line">        recyclerView.setAdapter(adapter);</span><br><span class="line">        recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(getActivity()));</span><br><span class="line">        recyclerView.addOnItemTouchListener(<span class="keyword">new</span> RecyclerTouchListener(getActivity(), recyclerView, <span class="keyword">new</span> ClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">                drawerListener.onDrawerItemSelected(view, position);</span><br><span class="line">                mDrawerLayout.closeDrawer(containerView);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> layout;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">(<span class="keyword">int</span> fragmentId, DrawerLayout drawerLayout, <span class="keyword">final</span> Toolbar toolbar)</span> </span>&#123;</span><br><span class="line">        containerView = getActivity().findViewById(fragmentId);</span><br><span class="line">        mDrawerLayout = drawerLayout;</span><br><span class="line">        mDrawerToggle = <span class="keyword">new</span> ActionBarDrawerToggle(getActivity(), drawerLayout, toolbar, R.string.drawer_open, R.string.drawer_close) &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerOpened</span><span class="params">(View drawerView)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onDrawerOpened(drawerView);</span><br><span class="line">                getActivity().invalidateOptionsMenu();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerClosed</span><span class="params">(View drawerView)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onDrawerClosed(drawerView);</span><br><span class="line">                getActivity().invalidateOptionsMenu();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerSlide</span><span class="params">(View drawerView, <span class="keyword">float</span> slideOffset)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onDrawerSlide(drawerView, slideOffset);</span><br><span class="line">                toolbar.setAlpha(<span class="number">1</span> - slideOffset / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        mDrawerLayout.setDrawerListener(mDrawerToggle);</span><br><span class="line">        mDrawerLayout.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mDrawerToggle.syncState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongClick</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerTouchListener</span> <span class="keyword">implements</span> <span class="title">RecyclerView</span>.<span class="title">OnItemTouchListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> GestureDetector gestureDetector;</span><br><span class="line">        <span class="keyword">private</span> ClickListener clickListener;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RecyclerTouchListener</span><span class="params">(Context context, <span class="keyword">final</span> RecyclerView recyclerView, <span class="keyword">final</span> ClickListener clickListener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clickListener = clickListener;</span><br><span class="line">            gestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">                    View child = recyclerView.findChildViewUnder(e.getX(), e.getY());</span><br><span class="line">                    <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; clickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clickListener.onLongClick(child, recyclerView.getChildPosition(child));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">            View child = rv.findChildViewUnder(e.getX(), e.getY());</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; clickListener != <span class="keyword">null</span> &amp;&amp; gestureDetector.onTouchEvent(e)) &#123;</span><br><span class="line">                clickListener.onClick(child, rv.getChildPosition(child));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTouchEvent</span><span class="params">(RecyclerView rv, MotionEvent e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FragmentDrawerListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerItemSelected</span><span class="params">(View view, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22.最后在activity_main.xml中添加DrawerLayout，如下代码:  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.v4.widget.DrawerLayout</span></span><br><span class="line"><span class="attribute">android:id</span>=<span class="value">"@+id/drawer_layout"</span></span><br><span class="line">   <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">   <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">       <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">       <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">       <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">           <span class="attribute">android:id</span>=<span class="value">"@+id/container_toolbar"</span></span><br><span class="line">           <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">           <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">           <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;<span class="title">include</span></span><br><span class="line">               <span class="attribute">android:id</span>=<span class="value">"@+id/toolbar"</span></span><br><span class="line">               <span class="attribute">layout</span>=<span class="value">"@layout/toolbar"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="title">FrameLayout</span></span><br><span class="line">           <span class="attribute">android:id</span>=<span class="value">"@+id/container_body"</span></span><br><span class="line">           <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">           <span class="attribute">android:layout_height</span>=<span class="value">"0dp"</span></span><br><span class="line">           <span class="attribute">android:layout_weight</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="title">fragment</span></span><br><span class="line">       <span class="attribute">android:id</span>=<span class="value">"@+id/fragment_navigation_drawer"</span></span><br><span class="line">       <span class="attribute">android:name</span>=<span class="value">"androidhive.info.materialdesign.activity.FragmentDrawer"</span></span><br><span class="line">       <span class="attribute">android:layout_width</span>=<span class="value">"@dimen/nav_drawer_width"</span></span><br><span class="line">       <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">       <span class="attribute">android:layout_gravity</span>=<span class="value">"start"</span></span><br><span class="line">       <span class="attribute">app:layout</span>=<span class="value">"@layout/fragment_navigation_drawer"</span></span><br><span class="line">       <span class="attribute">tools:layout</span>=<span class="value">"@layout/fragment_navigation_drawer"</span> /&gt;</span></span><br><span class="line">       </span><br><span class="line">   <span class="tag">&lt;<span class="title">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在我们已经完成了所有的的布局和jav文件,接下来我们要实现navigation draw而得功能.  </p>
<p>23.打开MainActivity,作如下修改:</p>
<p>MainActivity实现FragmentDrawer.FragmentDrawerListener接口，复写onDrawerItemSelected()</p>
<p>创建FragmentDrawer实例，并设置其选择监听事件,如下代码:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> <span class="keyword">implements</span> <span class="title">FragmentDrawer</span>.<span class="title">FragmentDrawerListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Toolbar mToolbar;</span><br><span class="line">    <span class="keyword">private</span> FragmentDrawer drawerFragment;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">        mToolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line"> </span><br><span class="line">        setSupportActionBar(mToolbar);</span><br><span class="line">        getSupportActionBar().setDisplayShowHomeEnabled(<span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        drawerFragment = (FragmentDrawer)</span><br><span class="line">                getSupportFragmentManager().findFragmentById(R.id.fragment_navigation_drawer);</span><br><span class="line">        drawerFragment.setUp(R.id.fragment_navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), mToolbar);</span><br><span class="line">        drawerFragment.setDrawerListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerItemSelected</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行APP能看到以下效果.  </p>
<p><img src="http://cdn1.androidhive.info/wp-content/uploads/2015/04/androd-material-design-navigation-drawer.png" alt=""></p>
<h3 id="3-3实现Navigation_Drawer的选择">3.3实现Navigation Drawer的选择</h3><p>虽然navigation drawer已经能够工作了，但是MENU的子选项无法工作，这是因为我们还没有处理RecyclerView item是的点击监听。   </p>
<p>由于我们有三子菜单(Home,Friends&amp;Mesages), 因此我们需要创建三个独立的Fragment  </p>
<p>24.创建fragment_home布局文件,代码如下：  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">fragment_home.xml</span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"androidhive.info.materialdesign.activity.HomeFragment"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/label"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentTop</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"100dp"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"HOME"</span></span><br><span class="line">        <span class="attribute">android:textStyle</span>=<span class="value">"bold"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/label"</span></span><br><span class="line">        <span class="attribute">android:layout_centerInParent</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"12dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"10dp"</span></span><br><span class="line">        <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"Edit fragment_home.xml to change the appearance"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">25.在activity包下，创建HomeFragment.java文件，代码如下: </span><br><span class="line">  </span><br><span class="line">```java  </span><br><span class="line">public class HomeFragment extends Fragment &#123;</span><br><span class="line"> </span><br><span class="line">    public HomeFragment() &#123;</span><br><span class="line">        // Required empty public constructor</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container,</span><br><span class="line">                             Bundle savedInstanceState) &#123;</span><br><span class="line">        View rootView = inflater.inflate(R.layout.fragment_home, container, false);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // Inflate the layout for this fragment</span><br><span class="line">        return rootView;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Activity activity) &#123;</span><br><span class="line">        super.onAttach(activity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void onDetach() &#123;</span><br><span class="line">        super.onDetach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.创建另外两个FRAGMENT，跟上面一样  </p>
<p>27.做如下修改.代码如下：</p>
<p>displayView方法用来显示menu item选中的页面.这个方法被onDrawerItemSelected()调用.  </p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> <span class="keyword">implements</span> <span class="title">FragmentDrawer</span>.<span class="title">FragmentDrawerListener</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = MainActivity.class.getSimpleName();

    <span class="keyword">private</span> Toolbar mToolbar;
    <span class="keyword">private</span> FragmentDrawer drawerFragment;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mToolbar = (Toolbar) findViewById(R.id.toolbar);

        setSupportActionBar(mToolbar);
        getSupportActionBar().setDisplayShowHomeEnabled(<span class="keyword">true</span>);

        drawerFragment = (FragmentDrawer)
                getSupportFragmentManager().findFragmentById(R.id.fragment_navigation_drawer);
        drawerFragment.setUp(R.id.fragment_navigation_drawer, (DrawerLayout) findViewById(R.id.drawer_layout), mToolbar);
        drawerFragment.setDrawerListener(<span class="keyword">this</span>);

        <span class="comment">// display the first navigation drawer view on app launch</span>
        displayView(<span class="number">0</span>);
    }


    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>{
        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
        getMenuInflater().inflate(R.menu.menu_main, menu);
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>{
        <span class="comment">// Handle action bar item clicks here. The action bar will</span>
        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
        <span class="keyword">int</span> id = item.getItemId();

        <span class="comment">//noinspection SimplifiableIfStatement</span>
        <span class="keyword">if</span> (id == R.id.action_settings) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="keyword">if</span>(id == R.id.action_search){
            Toast.makeText(getApplicationContext(), <span class="string">"Search action is selected!"</span>, Toast.LENGTH_SHORT).show();
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }

        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerItemSelected</span><span class="params">(View view, <span class="keyword">int</span> position)</span> </span>{
            displayView(position);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">displayView</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
        Fragment fragment = <span class="keyword">null</span>;
        String title = getString(R.string.app_name);
        <span class="keyword">switch</span> (position) {
            <span class="keyword">case</span> <span class="number">0</span>:
                fragment = <span class="keyword">new</span> HomeFragment();
                title = getString(R.string.title_home);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">1</span>:
                fragment = <span class="keyword">new</span> FriendsFragment();
                title = getString(R.string.title_friends);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="number">2</span>:
                fragment = <span class="keyword">new</span> MessagesFragment();
                title = getString(R.string.title_messages);
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">break</span>;
        }

        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>) {
            FragmentManager fragmentManager = getSupportFragmentManager();
            FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
            fragmentTransaction.replace(R.id.container_body, fragment);
            fragmentTransaction.commit();

            <span class="comment">// set the toolbar title</span>
            getSupportActionBar().setTitle(title);
        }
    }
}
</code></pre>
<p>现在运行app,你能够选择menu的子菜单了。如下效果。</p>
<p><img src="http://cdn1.androidhive.info/wp-content/uploads/2015/04/android-material-design-navigation-drawer-1.png" alt=""></p>
<p><img src="http://cdn1.androidhive.info/wp-content/uploads/2015/04/android-material-design-navigation-drawer-2.png" alt=""></p>
<p><img src="http://cdn1.androidhive.info/wp-content/uploads/2015/04/android-material-design-navigation-drawer-3.png" alt=""></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.androidhive.info/2015/04/android-getting-started-with-material-design/" target="_blank" rel="external">Android Getting Started with Material Design</a></li>
<li>原文作者 : <a href="http://www.androidhive.info/" target="_blank" rel="external">Ravi Tamada</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/xu6148152" target="_blank" rel="external">xu6148152</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>   </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>你可能已经听说过Android Lollipop中引入的Material Design.Material Design引入了很多新的东西，如Material 主题, 新的控件, 自定义阴影, 矢量绘制 and 自定义动画.如果你还没用过Material Design，那么本文很适合你。<br>]]>
    
    </summary>
    
      <category term="材料设计" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%9D%90%E6%96%99%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 应用性能优化系列]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-performance-patterns/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-performance-patterns/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:10:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android_应用性能优化系列">Android 应用性能优化系列</h2><blockquote>
<p>原文链接分别为 :   </p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE</a></li>
<li><a href="https://www.udacity.com/course/ud825" target="_blank" rel="external">https://www.udacity.com/course/ud825</a></li>
<li>译者 : <a href="http://hukai.me" target="_blank" rel="external">胡凯</a></li>
</ul>
</blockquote>
<ol>
<li><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">Android性能优化典范</a></li>
<li><a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a></li>
<li><a href="http://hukai.me/android-performance-compute/" target="_blank" rel="external">Android性能优化之运算篇</a></li>
<li><a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a></li>
<li><a href="http://hukai.me/android-performance-battery/" target="_blank" rel="external">Android性能优化之电量篇</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Android_应用性能优化系列">Android 应用性能优化系列</h2><blockquote>
<p>原文链接分别为 :   </p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLWz]]>
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解 Shared Element Transition (part 3a)]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-fragment-shared-element-transitions-in-depth-part3a/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-fragment-shared-element-transitions-in-depth-part3a/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:07:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="深入理解共享元素_Transition">深入理解共享元素 Transition</h2><p>这篇文章会深度分析共享元素 transitions 和它在 Activity &amp; Fragment Transitions API 中的作用。这篇文章是下面这个系列中的第三篇：</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Content Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)<a id="more"></a>
Part 3 会分成三个部分: part3a 介绍 共享元素 transitions 的底层操作，part3b 和 part3c<br>主要关注 API 的具体实现细节，例如推迟某些 共享元素 transition 的重要性和如何实现<br><strong>SharedElementCallbacks</strong>。</li>
</ul>
<p>我们首先会总结下在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a> 中提到的关于 共享元素 transition 的知识点，然后说一说在 Android Lollipop 中是怎样使用它来构建合适的过渡动画。</p>
<h2 id="什么是_共享元素_Transition_?">什么是 共享元素 Transition ?</h2><p>共享元素 transition 决定了 共享元素 视图(也叫做主角视图)在<br>Activity/Fragment 场景过渡时的动画效果。共享元素 的动画<br>在被调用 Activity/Fragment  的 <strong>进入/返回</strong>  共享元素 transition<br><a id="1" href="#b1">(1)</a> 中执行，<br>可以通过下面的<a href="http://developer.android.com/reference/android/view/Window.html" target="_blank" rel="external">Window</a>/<a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Fragment</a> 方法设置：</p>
<ul>
<li><strong>setSharedElementEnterTransition()</strong> -  <strong>B</strong> 的 <strong>进入</strong> 共享元素 transition ，执行将<br>  共享元素视图 从 <strong>A</strong> 中的起始位置移动到它在 <strong>B</strong> 中的最终位置的动画。</li>
<li><strong>setSharedElementReturnTransition()</strong>  - <strong>B</strong> 的 <strong>返回</strong> 共享元素 transition ，执行将<br>  共享元素视图 从 <strong>B</strong> 中起始位置移动到它在 <strong>A</strong> 中的最终位置的动画。</li>
</ul>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/01/12/music-opt.mp4" target="_blank" rel="external"><strong>Video 3.1</strong></a> 展示了在 Google Play Music 中是怎样使用共享元素 transition<br>的。这个 transition 包含两个元素：一个 <strong>ImageView</strong>和它的父视图 <strong>CardView</strong>。<br>Transition 期间，<strong>CardView</strong> 会扩展到全屏或收缩回原状，<br><strong>ImageView</strong> 能在这两个 Activity 里无缝的衔接。</p>
<p>在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part1 </a> 里只是简单的介绍了下这个话题，这篇文章将会对 共享元素 transition<br>做更深度的分析。例如 共享元素 Transition 在底层是如何实现的？都有哪些类型的 Transition 对象可以使用? Transition 期间 共享元素视图 是在哪里怎样绘制的？接下来的几章里<br>我们会逐个解答这些问题。</p>
<h2 id="深入共享元素_Transitions_底层">深入共享元素 Transitions 底层</h2><p>之前的文章已经介绍过 Transition 的两个主要任务分别是获取目标视图的 开始&amp;结束 状态和创建这两个状态间视图的过渡动画(Animator)。共享元素 Transition 也一样：<br>在创建动画前需要捕获每一个<br>共享元素视图的起始和结束状态(就是共享元素在 <strong>调用/被调用</strong> Activity/Fragment<br>里的位置，大小和外观)。有了这些信息 共享元素 Transition 就可以确定每一个 共享元素<br>视图应该执行的动画。</p>
<p>和 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">Content Transitions 的底层</a>相似，框架通过在运行时明确的<br>更改每个 共享元素视图 的属性将这个状态信息提供给 共享元素 Transition 。<br>更准确地说 Activity <strong>A</strong> 启动 Activity <strong>B</strong> 时将会出现以下事件：<a id="2" href="#b2">(2)</a></p>
<hr>
<ol>
<li>Activity <strong>A</strong> 调用 <strong>startActivity()</strong> 构造，测量，布局了一个<br> 最初背景色为透明的半透明窗口 Activity <strong>B</strong> 。</li>
<li>框架将 <strong>B</strong> 中每一个共享元素视图复位到对应的原来在 <strong>A</strong> 中时的位置，接着 <strong>B</strong> 的进入 transition 捕获 <strong>B</strong> 中所有共享元素视图的起始状态。</li>
<li>框架将 <strong>B</strong> 中每一个共享元素视图复位到对应的在 <strong>B</strong> 的最终位置，接着 <strong>B</strong> 的进入 transition 捕获 B 中所有共享元素视图的结束状态。</li>
<li><strong>B</strong> 的进入 transition 比较所有共享元素视图的起始和结束状态，根据它们的不同<br> 创建一个 <strong>Animator</strong>。</li>
<li>框架命令 <strong>A</strong> 隐藏共享元素视图，并运行返回的 <strong>Animator</strong>。<strong>B</strong> 中的<br> 共享元素视图到位之后，<strong>B</strong> 的窗口背景在 <strong>A </strong>上逐渐显示，直到 <strong>B</strong><br> 完全的显示出来，transition 运行完毕。</li>
</ol>
<hr>
<p>Content transitions 是根据每个过渡视图的可见性变化来调节的，<strong>共享元素 transition<br>是根据每个共享元素视图的位置，大小和外观的变化来调节的</strong>。从 API 21 开始，框架提供了<br>几个自定义共享元素场景切换动画的 <strong>Transition</strong> 实现。</p>
<ul>
<li><a href="https://developer.android.com/reference/android/transition/ChangeBounds.html" target="_blank" rel="external">ChangeBounds</a> - 捕获共享元素布局边界根据不同构造动画。<br>  <strong>ChangeBounds</strong> 在共享元素 Transition 中经常使用，大多数共享元素在两个<br>  Activity/Fragment 间会有大小 或/和 位置不同。 </li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeTransform.html" target="_blank" rel="external">ChangeTransform</a>  - 捕获共享元素缩放和角度，<br>  根据不同构建动画<a id="3" href="#b3">(3)</a>。</li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeClipBounds.html" target="_blank" rel="external">ChangeClipBounds</a> - 捕获共享元素的 <a href="https://developer.android.com/reference/android/view/View.html#getClipBounds()" target="_blank" rel="external">clip bounds</a><br>  (剪辑边界) ，根据不同构建动画。</li>
<li><a href="https://developer.android.com/reference/android/transition/ChangeImageTransform.html" target="_blank" rel="external">ChangeImageTransform</a> - 捕获共享元素 ImageView 的<br>  变换矩阵( transform matrices) ，根据不同构建动画。结合 <strong>ChangeBounds</strong>，<br>  可以让 ImageView<br>   无缝的改变大小，形状和 <a href="https://developer.android.com/reference/android/widget/ImageView.ScaleType.html" target="_blank" rel="external"> ImageView.ScaleType </a>。 </li>
<li><a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/res/res/transition/move.xml" target="_blank" rel="external">@android:transition/move</a> - 一个 <strong>TransitionSet</strong> ，同时执行上面四种<br>  transition 。在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a> 里提到过，如果没有明确的声明 进入/返回 共享元素<br>  transition ，框架会默认运行这个 transition。</li>
</ul>
<hr>
<p>在上面的例子中，我们还可以发现 <strong>共享元素视图实例并没有在 Activities/Fragments 间<br>“共享”</strong>。事实上，进入/返回 共享元素 transitions期间，用户看到的绝大多数东西都是在<br><strong>B</strong> 的 content view 中绘制的。框架并没有从 <strong>A</strong> 向 <strong>B</strong><br>传递 共享元素视图实例，<br>而是采用了不同的方法实现相同的视觉效果。当 <strong>A</strong> 启动 <strong>B</strong> ，框架收集 <strong>A</strong><br>中共享元素的所有相关信息，并传递给 <strong>B</strong>。接下来 <strong>B</strong> 使用这些信息初始化<br>共享元素视图的起始状态(它们在 <strong>A</strong> 中时对应的大小，位置和外观)。Transition<br>开始时，B 中除了共享元素视图外的所有东西都被初始化为对用户不可见。Tansition<br>的执行过程中，框架将 B 的 Activity 窗口逐渐显示，直到 B<br>中共享元素结束动画窗口变为不透明。</p>
<hr>
<h2 id="使用共享元素_Overlay_(4)">使用共享元素 Overlay <a id="4" href="#b4">(4)</a></h2><p>最后，如果想要完全理解共享元素 transition 的运作，我们必须先说说共享元素 overlay。<br>可能不是很明显，<strong>共享元素默认是在整个窗口视图层的顶层  <a href="https://developer.android.com/reference/android/view/ViewOverlay.html" target="_blank" rel="external">ViewOverlay</a><br>上绘制</strong>。简单介绍下 ，<br><strong>ViewOverlay</strong> 这个类是在 API 18 中为了方便在视图层顶层<br>绘制引入的。添加到视图 <strong>ViewOverlay</strong> 之中的Drawable<br>和 view (甚至是一个 <strong>ViewGroup</strong> 的子类) ，<br>将会被绘制在视图的最上层。这就解释了框架为什么<br>默认选择在窗口视图层的  <strong>ViewOverlay</strong> 中绘制共享元素。<br>共享元素视图应该是贯穿整个 transition 的焦点；<br>如果 transitioning views 意外的绘制在共享元素之上就会<br>破坏这个效果<a id="5" href="#b5">(5)</a>。</p>
<hr>
<p>虽然共享元素默认绘制在共享元素的 ViewOverlay 之中，但是<br>框架也提供了关闭 overlay 的方法，只要调用<br><a href="https://developer.android.com/reference/android/view/Window.html#setSharedElementsUseOverlay(boolean)" target="_blank" rel="external">Window#setSharedElementsUseOverlay(false) </a><br>就可以了。如果你关闭了 overlay<br>，要留意这样做可能会引起的副作用。例如，<a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/01/12/overlay-opt.mp4" target="_blank" rel="external">Video 3.2</a><br> 执行了一个简单的共享元素 transition 两次，<br>一次开启和一次关闭 共享元素 overlay 。第一次达到了预期想要的结果，<br>第二次关闭 overlay 后运行的效果不理想。Transition view 从底部向上移入<br>调用 Activity 的 content view 时挡住了部分 共享元素 <strong>ImageView</strong> 。虽然<br>可以改变在 View 上绘制视图的顺序或者通过在共享元素 parent 里调用<br> <strong>setClipChildren(false)</strong> 这些旁门左道来修复问题，但是与可能带来的维护问题<br> 相比真是得不偿失。总之，除非你感觉必须要关掉共享元素 overlay 才能达到你想要的效果，<br> 其他情况尽量不要关闭它，这样会保持代码简洁，并且共享元素 transition 效果更引人注目。</p>
<h2 id="结语">结语</h2><p>综上所诉，这篇文章讲了三个重点:</p>
<ol>
<li>共享元素 transition 确定 共享元素视图(主角视图) 从一个 Activity/Fragment 移动到<br> 另一个其间场景过渡的动画。</li>
<li>共享元素 transition 是根据每一个 共享元素视图 的位置，大小，和外观的变化调节的。</li>
<li>共享元素默认是绘制在窗口视图的顶层 <strong>ViewOverlay</strong> 上面的。</li>
</ol>
<p>希望这篇文章对你有所帮助 ～</p>
<hr>
<p>1 Note that the Activity Transition API gives you the ability to also specify exit and reenter shared element transitions using the setSharedElementExitTransition() and setSharedElementReenterTransition() methods, although doing so is usually not necessary. For an example illustrating one possible use case, check out this blog post. For an explanation why exit and reenter shared element transitions are not available for Fragment Transitions, see George Mount’s answer and comments in this StackOverflow post. ↩</p>
<p>2 A similar sequence of events occurs during the exit/return/reenter transitions for both Activities and Fragments. ↩</p>
<p>3 One other subtle feature of ChangeTransform is that it can detect and handle changes made to a shared element view’s parent during a transition. This comes in handy when, for example, the shared element’s parent has an opaque background and is by default selected to be a transitioning view during the scene change. In this case, the ChangeTransform will detect that the shared element’s ｀parent is being actively modified by the content transition, pull out the shared element from its parent, and animate the shared element separately. See George Mount’s StackOverflow answer for more information. ↩</p>
<p>4 Note that this section only pertains to Activity Transitions. Unlike Activity Transitions, shared elements are not drawn in a ViewOverlay by default during Fragment Transitions. That said, you can achieve a similar effect by applying a ChangeTransform transition, which will have the shared element drawn on top of the hierarchy in a ViewOverlay if it detects that its parent has changed. See this StackOverflow post for more information. ↩</p>
<p>5 Note that one negative side-effect of having shared elements drawn on top of the entire view hierarchy is that this means it will become possible for shared elements to draw on top of the System UI (such as the status bar, navigation bar, and action bar). For more information on how you can prevent this from happening, see this Google+ post. ↩</p>
<ol>
<li><p>Activity Transition API 也提供了<br><strong>setSharedElementExitTransition()</strong> 和 <strong>setSharedElementReenterTransition()</strong><br>这两个方法来设置 退出/重入 共享元素过渡，虽然通常来说是不必要的。<br><a href="https://halfthought.wordpress.com/2014/12/08/what-are-all-these-dang-transitions/" target="_blank" rel="external">这篇文章</a>介绍了一个可能会遇到的用例。在这个 <a href="http://stackoverflow.com/questions/27346020/understanding-exit-reenter-shared-element-transitions" target="_blank" rel="external">stackoverflow</a><br>提问中 George Mount 的回答解释了为什么 退出/重入 共享元素 transition 在<br>Fragment Transitions 中不可用。 <a id="b1" href="#1">↩</a></p>
</li>
<li><p>Activities 和 Fragments 的 退出/返回/重入 transition 过程中出现事件序列相似  <a id="b2" href="#2">↩</a></p>
</li>
<li><strong>ChangeTransform</strong> 还有一个超赞的特性，它可以检测并处理共享元素父视图过渡期间<br> 的改变。当共享元素父视图有一个不透明背景，在场景变换过程中默认被选为<br> transitioning view 时，<strong>ChangeTransform</strong> 就有了用武之地。如果它检测出<br> 共享元素父视图已被 content transition 更改，就会将共享元素提取出来，单独执行<br> 共享元素的动画。<a href="http://stackoverflow.com/questions/26899779/enter-transition-on-a-fragment-with-a-shared-element-targets-the-shared-element" target="_blank" rel="external">StackOverflow answer</a> 这里有 George Mount<br> 的详细说明。<br> <a id="b3" href="#3">↩</a></li>
<li>注意，这部分只与 Activity Transition 有关。和Activity Transition 不同，Fragment Transition<br> 期间共享元素默认不在 <strong>ViewOverlay</strong> 中绘制。尽管如此，你仍可以使用 ChangeTransform<br> transition 来达到相似的效果，如果它检测到父视图改变了，就会把共享元素绘制在<br> <strong>ViewOverlay</strong> 的顶层。<a href="http://stackoverflow.com/questions/27892033/is-there-a-setsharedelementsuseoverlay-method-for-fragment-transitions" target="_blank" rel="external">StackOverflow</a> 这里有更多信息。<br>  <a id="b4" href="#4">↩</a></li>
<li>注意，将共享元素绘制在整个图层最顶层也有一些负面效果。有可能<br> 会将共享元素绘制在 System UI 之上(比如 status bar, navigation bar还有 action bar)。<br> 解决方法看这里 <a href="https://plus.google.com/+AlexLockwood/posts/RPtwZ5nNebb" target="_blank" rel="external">Google+ post</a>。<br> <a id="b5" href="#5">↩</a></li>
</ol>
<hr>
<blockquote>
<ul>
<li>原文链接 :  <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">Shared Element Transitions In-Depth (part 3a)</a></li>
<li>作者 : <a href="https://plus.google.com/+AlexLockwood" target="_blank" rel="external">Alex Lockwood</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a></li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="深入理解共享元素_Transition">深入理解共享元素 Transition</h2><p>这篇文章会深度分析共享元素 transitions 和它在 Activity &amp; Fragment Transitions API 中的作用。这篇文章是下面这个系列中的第三篇：</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html">深入理解 Content Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html">深入理解共享元素 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)]]>
    
    </summary>
    
      <category term="动画" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[延迟共享元素的过渡动画 (part 3b)]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-postponed-shared-element-transitions-part3b/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-postponed-shared-element-transitions-part3b/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:05:20.000Z</updated>
    <content type="html"><![CDATA[<p>通过讨论 Lollipop Transition API 的一个重要的特性：延迟共享元素的过渡动画，这篇博文将继续我们关于共享元素 Transition 的深度解析。这也是我关于 Transition 这个专栏的第四篇文章。</p>
<ul>
<li>Part 1: <a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素的 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)</li>
</ul>
<p>我们通过一个常见的问题来解释为什么需要推迟某些共享元素的过渡动画。<br><a id="more"></a></p>
<h2 id="理解问题">理解问题</h2><p>通常问题的根源是框架在 Activity 生命周期非常早的时候启动共享元素 Transition 。回想我们的第一篇文章，Transitions 必须捕获目标 View 的起始和结束状态来构建合适的动画。因此，如果框架在共享元素获得它在调用它的 Activity 中所给定的大小和位置前启动共享元素的过渡动画，这个 Transition 将不能正确捕获到共享元素的结束状态值,生成动画也会失败(一个过渡失败的例子<a href="http://www.androiddesignpatterns.com/assets/videos/posts/2015/03/09/postpone-bug-opt.mp4" target="_blank" rel="external">Video 3.3</a>).</p>
<p>Transition 开始前，能否计算出正确的共享元素的结束值主要依靠两个因素:</p>
<p>(1) 调用共享元素的 Activity 的布局复杂度以及布局层次结构的深度<br>(2)调用共享元素Activity载入数据消耗的时间</p>
<p>布局越复杂，在屏幕上确定共享元素的大小位置耗时越长。同样，如果调用共享元素的 Activity 依赖一个异步的数据载入，框架仍有可能会在数据载入完成前自动开始共享元素 Transition。下面列出的是你可能遇到的常见问题:</p>
<ul>
<li><p><strong>存在于 Activity 托管的 Fragment 中的共享元素</strong>。<a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#commit()" target="_blank" rel="external">FragmentTransactions 在 commit 后并不会被立即执行</a>，它们会被安排到主线程中等待执行。因此，如果共享元素存在的 Fragment 的视图层和FragmentTransaction没有被及时执行，框架有可能在共享元素被正确测量大小和布局到屏幕前启动共享元素 Transition。<a id="b1" href="#1">(1)</a></p>
</li>
<li><p><strong>共享元素是一个高分辨率的图片</strong>。给 <strong>ImageView</strong> 设置一个超过其初始化边界的高分辨率图片，最终可能会导致在这个视图层里出现<a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/java/android/widget/ImageView.java#L453-L455" target="_blank" rel="external">额外的布局传递</a>，由此增加在共享元素准备好前就启动 Transition 的几率。流行的异步图片处理库比如 <a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="external"><code>Volley</code></a> 和 <a href="http://square.github.io/picasso/" target="_blank" rel="external"><code>Picasso</code></a> ，也不能可靠的解决这个问题：框架不能预先了解图片是要被下载，缩放还是在后台线程中从磁盘读取，也不管图片是否处理完毕就启动共享元素 Transition。</p>
</li>
<li><p><strong>共享元素依赖于异步的数据加载</strong>如果共享元素所需的数据是通过<strong>AsyncTask</strong>，<strong>AsyncQueryHandler</strong>,<strong>Loader</strong>或者其他类似的东西加载，在它们获得在调用它们的 Activity 的最终数据（大小、位置）前，框架就有可能在主线程中启动 Transition。</p>
</li>
</ul>
<p>现在你可能会想：如果有办法能让暂时延迟 Transition 的使用，直到我们确定了共享元素的确切大小和位置才使用它就好了。幸好 Activity Transitions API<a id="b2" href="#2">(2)</a> 为我们提供了解决方案。</p>
<p>在 Activity 的<code>onCreate()</code>中调用<a href="https://developer.android.com/reference/android/app/Activity.html#postponeEnterTransition()" target="_blank" rel="external"><code>postponeEnterTransition()</code></a> 方法来暂时阻止启动共享元素 Transition。之后，你需要在共享元素准备好后调用 <a href="https://developer.android.com/reference/android/app/Activity.html#startPostponedEnterTransition()" target="_blank" rel="external"><code>startPostponedEnterTransition</code></a> 来恢复过渡效果。常见的模式是在一个<a href="http://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener.html" target="_blank" rel="external"><code>OnPreDrawListener</code></a>中启动延时 Transition，它会在共享元素测量和布局完毕后被调用<a id="b3" href="#3">(3)</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the shared element enter transition.</span></span><br><span class="line">    postponeEnterTransition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span>: Call the "scheduleStartPostponedTransition()" method</span></span><br><span class="line">    <span class="comment">// below when you know for certain that the shared element is</span></span><br><span class="line">    <span class="comment">// ready for the transition to begin.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Schedules the shared element transition to be started immediately</span><br><span class="line"> * after the shared element has been measured and laid out within the</span><br><span class="line"> * activity's view hierarchy. Some common places where it might make</span><br><span class="line"> * sense to call this method are:</span><br><span class="line"> *</span><br><span class="line"> * (1) Inside a Fragment's onCreateView() method (if the shared element</span><br><span class="line"> *     lives inside a Fragment hosted by the called Activity).</span><br><span class="line"> *</span><br><span class="line"> * (2) Inside a Picasso Callback object (if you need to wait for Picasso to</span><br><span class="line"> *     asynchronously load/scale a bitmap before the transition can begin).</span><br><span class="line"> *</span><br><span class="line"> * (3) Inside a LoaderCallback's onLoadFinished() method (if the shared</span><br><span class="line"> *     element depends on data queried by a Loader).</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleStartPostponedTransition</span><span class="params">(<span class="keyword">final</span> View sharedElement)</span> </span>&#123;</span><br><span class="line">    sharedElement.getViewTreeObserver().addOnPreDrawListener(</span><br><span class="line">        <span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                sharedElement.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">                startPostponedEnterTransition();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略方法名，这里还有第二种方法可以延迟共享元素的返回 Transition，在调用Activity的<a href="https://developer.android.com/reference/android/app/Activity.html#onActivityReenter(int,%20android.content.Intent)" target="_blank" rel="external"><code>onActivityReenter()</code></a> 方法中延缓返回 Transition<a id="b4" href="#4">(4)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Don't forget to call setResult(Activity.RESULT_OK) in the returning</span><br><span class="line"> * activity or else this method won't be called!</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityReenter</span><span class="params">(<span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityReenter(resultCode, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Postpone the shared element return transition.</span></span><br><span class="line">    postponeEnterTransition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span>: Call the "scheduleStartPostponedTransition()" method</span></span><br><span class="line">    <span class="comment">// above when you know for certain that the shared element is</span></span><br><span class="line">    <span class="comment">// ready for the transition to begin.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管添加延时可以让共享元素 Transition 更加流畅准确，但是你也要知道在应用中引入共享元素 Transition 的延迟可能会产生一些负面影响：</p>
<ul>
<li><strong>调用<code>postponeEnterTransition</code>后不要忘记调用<code>startPostponedEnterTransition</code></strong>。<br>忘记调用<code>startPostponedEnterTransition</code>会让你的应用处于死锁状态，用户无法进入下个Activity。</li>
</ul>
<ul>
<li><strong>不要将共享元素 Transition 延迟设置到1s以上</strong>。延迟时间过长会在应用中产生不必要的卡顿，影响用户体验。</li>
</ul>
<p>感谢阅读！希望这篇文章对你有所帮助。</p>
<p><a id="1" href="#b1"><strong>1</strong></a>: 当然，许多应用通过调用 <a href="https://developer.android.com/reference/android/app/FragmentManager.html#executePendingTransactions(" target="_blank" rel="external"><code>FragmentManager#executePendingTransactions()</code></a>) 来避开这个问题，这样会强制立即执行FragmentTransactions而不是异步。</p>
<p><a id="2" href="#b2"><strong>2</strong></a>: 注意!<code>postponeEnterTransition()</code>和<code>startPostponedEnterTransition()</code>只对 Activity Transition起作用，对Fragment无效。详细信息可以在这里找到 <a href="http://stackoverflow.com/questions/26977303/how-to-postpone-a-fragments-enter-transition-in-android-lollipop" target="_blank" rel="external">StackOverflow</a> &amp; <a href="https://plus.google.com/+AlexLockwood/posts/3DxHT42rmmY" target="_blank" rel="external">Google+</a></p>
<p><a id="3" href="#b3"><strong>3</strong></a>: 小贴士:你可以先调用 <a href="http://developer.android.com/reference/android/view/View.html#isLayoutRequested(" target="_blank" rel="external"><code>View#isLayoutRequested()</code></a>) 来确认是否需要调用 <a href="http://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener.html" target="_blank" rel="external"><code>OnPreDrawListener</code></a>，有必要的话 <a href="http://developer.android.com/reference/android/view/View.html#isLaidOut(" target="_blank" rel="external"><code>View#isLaidOut()</code></a>) 在一些情况下也能派上用场</p>
<p><a id="4" href="#b4"><strong>4</strong></a>: 在开发者选项中启用不保留 Activity 选项可以方便调试共享元素返回/重新进入时对应过渡动画的行为，这也可以帮助测试在返回的过渡效果开始之前可能发生最糟糕的情况( Activity 需要重新构造布局加载数据…)</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">Postponed Shared Element Transitions (part 3b)</a></li>
<li>作者 : <a href="https://plus.google.com/+AlexLockwood" target="_blank" rel="external">Alex Lockwood</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a></li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过讨论 Lollipop Transition API 的一个重要的特性：延迟共享元素的过渡动画，这篇博文将继续我们关于共享元素 Transition 的深度解析。这也是我关于 Transition 这个专栏的第四篇文章。</p>
<ul>
<li>Part 1: <a href="https://github.com/bboyfeiyu/android-tech-frontier/tree/master/others/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAAndroid%20%E6%96%B0%E7%89%B9%E6%80%A7-Transition-Part-1">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html">深入理解 Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html">深入理解共享元素的 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)</li>
</ul>
<p>我们通过一个常见的问题来解释为什么需要推迟某些共享元素的过渡动画。<br>]]>
    
    </summary>
    
      <category term="动画" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Activity中使用Thread导致的内存泄漏]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activitys-threads-memory-leaks/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activitys-threads-memory-leaks/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:06:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>注：这篇博文涉及的源码可以在 <a href="https://github.com/alexjlockwood/leaky-threads" target="_blank" rel="external">GitHub</a> 上面下载哦</p>
</blockquote>
<p>做 Android 开发最常遇到的问题就是在 Activity 的生命周期中协调耗时任务，避免执行任务导致不易察觉的内存泄漏。不妨先读一读下面的代码，代码写了一个简单的 Activity，Activity 在启动后就会开启一个线程，并循环执行该线程中的任务<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span><br><span class="line"> *  示例向我们展示了在 Activity 的配置改变时（配置改变会导致其下的 Activity 实例被销</span><br><span class="line">    *  毁）存活。此外，Activity 的 context 也是内存泄漏的一部分，因为每一个线程都被初始</span><br><span class="line">    *  化为匿名内部类，使得每一个线程都持有一个外部 Activity 实例的隐式引用，使得</span><br><span class="line">    *  Activity 不会被 Java 的垃圾回收机制回收。</span><br><span class="line">    */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleOne();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity 配置发生改变会使 Activity 被销毁，并新建一个 Activity，我们总会觉得 Android 系统会将与被销毁的 Activity 相关的一切清理干净，例如回收与 Activity 关联的内存，Activity 执行的线程等等……然而，现实总是很残酷的，刚刚提到的这些东西都不会被回收，并导致内存泄漏，从而显著地影响应用的性能表现。</p>
<h2 id="Activity_内存泄漏的根源">Activity 内存泄漏的根源</h2><p>如果你读过我以前写的一篇有关 Handler 和 内部类的博文，那我接下来要讲的知识你肯定知道。在 Java 中，非静态匿名内部类会持有其外部类的隐式引用，如果你没有考虑过这一点，那么存储该引用会导致 Activity 被保留，而不是被垃圾回收机制回收。Activity 对象持有其 View 层以及相关联的所有资源文件的引用，换句话说，如果你的内存泄漏发生在 Activity 中，那么你将损失大量的内存空间。</p>
<p>而这样的问题在 Activity 配置改变时会更加严重，因为 Activity 的配置改变表示 Android 系统将要销毁当前 Activity 并新建一个 Activity。举例来说吧，在使用应用的时候，你执行了10次横屏/竖屏操作，每一次方向的改变都会执行下面的代码，那么我们会发现（使用<a href="http://www.eclipse.org/mat/" target="_blank" rel="external"> Eclipse 的内存分析工具</a>可以看到）每一个 Activity 对象都会因为留有一个隐式引用而被保留在内存中。</p>
<p><img src="http://www.androiddesignpatterns.com/assets/images/posts/2013/04/15/activity-leak.png" alt=""></p>
<p>每一次配置的改变都会使 Android 系统新建一个 Activity 并把改变前的 Activity 交给垃圾回收机制回收。但因为线程持有旧 Activity 的隐式引用，使该 Activity 没有被垃圾回收机制回收。这样的问题会导致每一个新建的 Activity 都将发生内存泄漏，与 Activity 相关的所有资源文件也不会被回收，其中的内存泄漏有多严重可想而知。</p>
<p>看到这里可能你会很害怕，很惶恐，很无助，那我们该怎么办……莫慌，解决办法非常简单，既然我们已经确定了问题的根源，那么对症下药就可以了：我们把该线程类声明为私有的静态内部类就可以解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">     * 示例通过将线程类声明为私有的静态内部类避免了 Activity context 的内存泄漏问题，但</span><br><span class="line">     * 在配置发生改变后，线程仍然会执行。原因在于，DVM 虚拟机持有所有运行线程的引用，无论</span><br><span class="line">     * 这些线程是否被回收，都与 Activity 的生命周期无关。运行中的线程只会继续运行，直到</span><br><span class="line">     * Android 系统将整个应用进程杀死</span><br><span class="line">     */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleTwo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> MyThread().start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，新线程再也不会持有一个外部 Activity 的隐式引用，而且该 Activity 也会在配置改变后被回收。</p>
<h2 id="线程内存泄漏的根源">线程内存泄漏的根源</h2><p>第二个问题是：对于每个新建 Activity,如果 Activity 中的线程发生发生内存泄漏。在Java中线程是垃圾回收机制的根源，也就是说，在运行系统中DVM虚拟机总会使硬件持有所有运行状态的进程的引用，结果导致处于运行状态的线程将永远不会被回收。因此，你必须为你的后台线程实现销毁逻辑！下面是一种解决办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">    * 除了我们需要实现销毁逻辑以保证线程不会发生内存泄漏，其他代码和示例2相同。在退出当前</span><br><span class="line">    * Activity 前使用 onDestroy() 方法结束你的运行中线程是个不错的选择</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MyThread mThread;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleThree();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mThread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span><br><span class="line">   * 私有的静态内部类不会持有其外部类的引用，使得 Activity 实例不会在配置改变时发生内</span><br><span class="line">   * 存泄漏</span><br><span class="line">      */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mRunning = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (mRunning) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      mRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    mThread.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们在 onDestroy() 方法中结束了线程，确保不会发生意外的线程的内存泄漏问题。如果你想要在配置改变后保留该线程（而不是每一次在关闭 Activity 后都要新建一个线程），那我建议你使用 Fragment 去完成该耗时任务。你可以翻我以前的博文，一名叫作<strong>“Handling Configuration Changes with Fragments”</strong>应该能满足你的需求，在API demo中也提供了很好理解的例子来为你阐述相关概念。</p>
<h2 id="结论">结论</h2><p>Android 开发过程中，在 Activity 的生命周期里协调耗时任务可能会很困难，你一不小心就会导致内存泄漏问题。下面是一些小提示，能帮助你预防内存泄漏问题的发生：</p>
<ul>
<li><p><strong>尽可能使用静态内部类而不是非静态内部类。</strong>每一个非静态内部类实例都会持有一个外部类的引用，若该引用是 Activity 的引用，那么该 Activity 在被销毁时将无法被回收。如果你的静态内部类需要一个相关 Activity 的引用以确保功能能够正常运行，那么你得确保你在对象中使用的是一个 Activity 的弱引用，否则你的 Activity 将会发生意外的内存泄漏。</p>
</li>
<li><p><strong>不要总想着 Java 的垃圾回收机制会帮你解决所有内存回收问题。</strong>就像上面的示例，我们以为垃圾回收机制会帮我们将不需要使用的内存回收，例如：我们需要结束一个 Activity，那么它的实例和相关的线程都该被回收。但现实并不会像我们剧本那样走。Java 线程会一直存活，直到他们都被显式关闭，抑或是其进程被 Android 系统杀死。所以，为你的后台线程实现销毁逻辑是你在使用线程时必须时刻铭记的细节，此外，你在设计销毁逻辑时要根据 Activity 的生命周期去设计，避免出现 Bug。</p>
</li>
<li><p><strong>考虑你是否真的需要使用线程。</strong>Android 应用的框架层为我们提供了很多便于开发者执行后台操作的类。例如：我们可以使用 Loader 代替在 Activity 的生命周期中用线程通过注入执行短暂的异步后台查询操作，考虑用 Service 将结构通知给 UI 的 BroadcastReceiver。最后，记住，这篇博文中对线程进行的讨论同样适用于 AsyncTask（因为 AsyncTask 使用 ExecutorService 执行它的任务）。然而，虽说 ExecutorService 只能在短暂操作（文档说最多几秒）中被使用，那么这些方法导致的 Activity 内存泄漏应该永远不会发生。</p>
</li>
</ul>
<p>这篇博文的源码可以在 <a href="https://github.com/alexjlockwood/leaky-threads" target="_blank" rel="external">GitHub</a> 中下载，你也可以在 <a href="https://play.google.com/store/apps/details?id=com.adp.leaky.threads" target="_blank" rel="external">Google Play</a> 下载 APK 使用。</p>
<p><img src="http://www.androiddesignpatterns.com/assets/images/posts/2013/04/15/leaky-threads-screenshot.png" alt=""></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.androiddesignpatterns.com/2013/04/activitys-threads-memory-leaks.html" target="_blank" rel="external">Activitys, Threads, &amp; Memory Leaks</a></li>
<li>原文作者 : <a href="https://google.com/+AlexLockwood" target="_blank" rel="external">AlexLockwood</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/yinna317" target="_blank" rel="external">yinna317</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>注：这篇博文涉及的源码可以在 <a href="https://github.com/alexjlockwood/leaky-threads">GitHub</a> 上面下载哦</p>
</blockquote>
<p>做 Android 开发最常遇到的问题就是在 Activity 的生命周期中协调耗时任务，避免执行任务导致不易察觉的内存泄漏。不妨先读一读下面的代码，代码写了一个简单的 Activity，Activity 在启动后就会开启一个线程，并循环执行该线程中的任务<br>]]>
    
    </summary>
    
      <category term="内存泄露" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 进行单元测试难在哪-序]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/against-android-unit-tests/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/against-android-unit-tests/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:13:49.000Z</updated>
    <content type="html"><![CDATA[<p>其实不仅仅只有普通 Android 开发工程师觉得测试 Android 应用很恼火，大牛们也受此困扰已久。例如 Jake Wharton 曾经明确地表示：Android 平台自诞生之初就与应用测试势如水火。Don Felker 和 Kaushik Gopal 也在他们的<a href="http://fragmentedpodcast.com/episodes/1/" target="_blank" rel="external">博文</a>里也提出了相同的观点。当然了，他们还提到 Google 的 <a href="https://github.com/google/iosched" target="_blank" rel="external">IOSched 应用</a>，根本就没有进行过测试，据说 IOSched 还是 Android 开发环境中应用开发的最优集合体呢。<a id="more"></a> IOSched 没有进行测试让我们这些开发者很困扰：1、Google 所谓的“测试是高效地进行 Android 开发中的关键一环”真的不是来唬小孩的吗；2、还是 Google 官方的工程师觉得测试 Android 应用简直就是浪费时间？不管怎样，如果这个世界上最优秀的 Android 开发工程师都觉得在 Android 中进行测试很麻烦，那我们这些小菜鸡玩不好测试也是理所当然的了。</p>
<p>多年以来，Android 开发者们为克服在 Android 中难于进行测试的问题绞尽脑汁。Roboletric 就是这些工程师的智慧结晶，它能让开发者们在 JVM 虚拟机上进行 Android 测试。而最近又有博文开始声讨 Fragment，<a href="https://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external">个中翘楚 Square 就表示</a>：老子再也不用 Fragment 这种垃圾玩意了，我们要把业务逻辑都转换到新开发的 Mortar &amp; Flow （MVP 开发框架）框架里，用纯 Java 对象进行编程，完全不依赖 Android 平台的 API。毫无疑问，这些 Java 对象在标准的 Java 测试工具中进行测试是非常简单的。</p>
<p>我坚信那些和 Square 站在统一战线上的开发团队肯定也在想办法将 UI 从实际的业务逻辑中剥离为纯 Java对象，为提高应用的可测试性不懈努力。换句话说，我觉得我们可以不在 Android 中进行单元测试，也不用实现依赖于 Android SDK 的测试单元。我们应该做的是重构应用，让我们能够为应用中的代码实现纯 Java 的测试单元，无论最终能不能真正地提高 Android 的可测试性和健壮性，我觉得这都值得一试。</p>
<p>我感觉到这个思路会是治本良方，所以我们要做的，就是将下图这样的 Android 的应用架构</p>
<p><img src="http://img.my.csdn.net/uploads/201504/26/1430014189_2164.png" alt=""></p>
<p>变成下图这样：</p>
<p><img src="http://img.my.csdn.net/uploads/201504/26/1430014189_8490.png" alt=""></p>
<p>虽然这个方法可能能从根本上解决问题，但它也有很大的风险，尽管如此，我还是坚持认为这个方法值得一试，因为它能拯救万千挣扎在实现 Android 测试单元的开发者们于水火之中，而且不用强迫他们使用第三方的库，毕竟第三库总会让他们滞后于最新的 Android 系统特性。此外，Kent Beck 认为：可测试性好的代码就是架构优秀的代码，如果他的观点是对的，或许我们还能找到架构应用更好的办法。</p>
<p>在接下来的博文里，我将探索“重构 Android 应用以使它们能轻易地通过标准的 Java 工具进行测试”这个方案的可操作性。</p>
<p>在第一、第二篇博文中，我会侧重阐述在 Android 里进行单元测试为什么会带来如此痛苦的体验。我觉得阻碍 Android 测试方法发展的根本原因就在于：Android 系统本身就难于进行测试。缺乏对 Activity 和 Fragment 的合理注入就是让应用难以测试的根本原因，而且认识到这一点是设计可测试强的应用架构的关键。</p>
<p>在第三篇博文中，我会在细节上探讨一个常见的解耦应用代码和 Android SDK的策略。简单来说，这个策略就是：将所有应用的具体行为交给一个 POJO 对象（Plain Ordinary Java Object）完成，这些 POJO 对象都是 Android 无关的接口的 Android 特定实现。</p>
<p>在第四篇博文中，我会指出实现第二篇博文中提出的策略存在的技术难点，并尝试去挖掘可以解决这些难点的方法。在这些难点中，最大的问题在于内存泄漏和繁复的重用代码。</p>
<p>在最后一篇博文中，我会通过展示我提出的架构为 Android 测试性带来的提高让大家觉得进行这样的技术探索是值得花费时间、精力，并且能获得相应回报的。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://philosophicalhacker.com/2015/04/10/against-android-unit-tests/" target="_blank" rel="external">Against Android Unit Tests</a></li>
<li>原文作者 : <a href="http://philosophicalhacker.com/" target="_blank" rel="external">Matthew Dupree</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/zhengxiaopeng" target="_blank" rel="external">Rocko</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实不仅仅只有普通 Android 开发工程师觉得测试 Android 应用很恼火，大牛们也受此困扰已久。例如 Jake Wharton 曾经明确地表示：Android 平台自诞生之初就与应用测试势如水火。Don Felker 和 Kaushik Gopal 也在他们的<a href="http://fragmentedpodcast.com/episodes/1/">博文</a>里也提出了相同的观点。当然了，他们还提到 Google 的 <a href="https://github.com/google/iosched">IOSched 应用</a>，根本就没有进行过测试，据说 IOSched 还是 Android 开发环境中应用开发的最优集合体呢。]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="单元测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[检测Android应用的启动与关闭]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-determine-when-app-is-opened-or-closed/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-determine-when-app-is-opened-or-closed/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:12:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题">问题</h2><p>当开发安卓程序的时候，我们不免需要去检测应用什么时候在前台运行，用户什么时候离开。不幸的是，没有一个简单的方法可以做到这点。当用户第一次启动的时候去检测还是不难，但如果是重新打开或关闭就不简单了。<br><a id="more"></a></p>
<p>这篇文章将会展示一个用来解决上述问题的技巧。</p>
<h2 id="入门指南">入门指南</h2><p>应用的activity是否显示在界面是决定应用是打开还是关闭的核心因素。我们先来看一个简单的例子，一个应用只有一个activity并且不支持横屏，这个activity的onstart和onstop方法就决定了这个应用是打开的还是关闭的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    <span class="comment">// The Application has been opened!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="comment">// The Application has been closed!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但有个问题，一旦我们支持横屏，上面这个方法就失效了。如果我们旋转设备，这个activity会重新创建，onstart方法会第二次执行，导致程序错误的认为应用第二次被打开。</p>
<p>为了处理设备旋转，我们需要添加一个验证步骤。这个验证需要启动一个计时器，用来检测当activity停止后，我们是否能很快看到该程序另一个activity启动。如果不能，则说明用户推出了程序，否则说明用户还在使用程序。</p>
<p>这样的验证同样支持有多个activity的应用。因为从一个activity跳转到另外一个也可以用这个验证方式处理。</p>
<p>所以利用这个技巧，我创建了一个管理activity的类，当activity的可见性发生变化的时候都要报告给这个管理类。这个类为每个activity处理验证步骤，避免意外的验证。我们同样利用了“发布-订阅”（观察者）模式，使得其他相关的类能够收到程序打开或关闭的通知。</p>
<h2 id="使用这个管理类的三个步骤">使用这个管理类的三个步骤</h2><h3 id="1)_将下面的代码添加到你的代码库">1) 将下面的代码添加到你的代码库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> android.text.format.DateUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 这个类用于追踪当前所有启动的Activity，使得我们能判断应用是否在后台运行。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppForegroundStateManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = AppForegroundStateManager.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_NOTIFY_LISTENERS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> APP_CLOSED_VALIDATION_TIME_IN_MS = <span class="number">30</span> * DateUtils.SECOND_IN_MILLIS; <span class="comment">// 30 Seconds</span></span><br><span class="line">    <span class="keyword">private</span> Reference&lt;Activity&gt; mForegroundActivity;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;OnAppForegroundStateChangeListener&gt; mListeners = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> AppForegroundState mAppForegroundState = AppForegroundState.NOT_IN_FOREGROUND;</span><br><span class="line">    <span class="keyword">private</span> NotifyListenersHandler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得一个线程安全的类实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AppForegroundStateManager INSTANCE = <span class="keyword">new</span> AppForegroundStateManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppForegroundStateManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppForegroundStateManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在主线程创建一个 handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> NotifyListenersHandler(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> AppForegroundState &#123;</span><br><span class="line">        IN_FOREGROUND,</span><br><span class="line">        NOT_IN_FOREGROUND</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnAppForegroundStateChangeListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 当应用状态发生改变时这个方法被调用（隐藏到后台或显示到前台） */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppForegroundStateChange</span><span class="params">(AppForegroundState newState)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当 Activity 可见时应该调用这个方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityVisible</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundActivity != <span class="keyword">null</span>) mForegroundActivity.clear();</span><br><span class="line">        mForegroundActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">        determineAppForegroundState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当 Activity 不再可见时应该调用这个方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityNotVisible</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 前台 Activity 可能会被一个新的 Activity 替换。</span><br><span class="line">         * 如果新 Activity 与前台 Activity 匹配，仅仅清除前台 Activity</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mForegroundActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Activity ref = mForegroundActivity.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activity == ref) &#123;</span><br><span class="line">                <span class="comment">// This is the activity that is going away, clear the reference</span></span><br><span class="line">                mForegroundActivity.clear();</span><br><span class="line">                mForegroundActivity = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        determineAppForegroundState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于判断应用是否处于前台 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isAppInForeground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mAppForegroundState == AppForegroundState.IN_FOREGROUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 用于判断当前状态，更新追踪的目标，并通知所有观察者状态是否发生了改变</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">determineAppForegroundState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 获取当前状态 */</span></span><br><span class="line">        AppForegroundState oldState = mAppForegroundState;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 决定当前状态 */</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isInForeground = mForegroundActivity != <span class="keyword">null</span> &amp;&amp; mForegroundActivity.get() != <span class="keyword">null</span>;</span><br><span class="line">        mAppForegroundState = isInForeground ? AppForegroundState.IN_FOREGROUND : AppForegroundState.NOT_IN_FOREGROUND;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果新的状态与之前的状态不一样，则之前的状态需要通知所有观察者状态发生了改变 */</span></span><br><span class="line">        <span class="keyword">if</span> (mAppForegroundState != oldState) &#123;</span><br><span class="line">            validateThenNotifyListeners();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 添加一个用于监听前台应用状态的监听器</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(@NonNull OnAppForegroundStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        mListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 移除用于监听前台应用状态的监听器</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(OnAppForegroundStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        mListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通知所有监听器前台应用状态发生了改变 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">(AppForegroundState newState)</span> </span>&#123;</span><br><span class="line">        android.util.Log.i(TAG, <span class="string">"Notifying subscribers that app just entered state: "</span> + newState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OnAppForegroundStateChangeListener listener : mListeners) &#123;</span><br><span class="line">            listener.onAppForegroundStateChange(newState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 这个方法会通知所有观察者：前台应用的状态发生了改变</span><br><span class="line">     * &lt;br&gt;&lt;br&gt;</span><br><span class="line">     * 我们只在应用进入/离开前台时立刻监听器。当打开/关闭/方向切换这些操作频繁发生时，我们</span><br><span class="line">     * 简要的传递一个一定会被无视的 NOT_IN_FOREGROUND 值。为了实现它，当我们注意到状态发</span><br><span class="line">     * 生改变，一个延迟的消息会被发出。在这个消息被接收之前，我们不会注意前台应用的状态是否</span><br><span class="line">     * 发生了改变。如果在消息被延迟的那段时间内应用的状态发生了改变，那么该通知将会被取消。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateThenNotifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the app has any pending notifications then throw out the event as the state change has failed validation</span></span><br><span class="line">        <span class="keyword">if</span> (mHandler.hasMessages(MESSAGE_NOTIFY_LISTENERS)) &#123;</span><br><span class="line">            android.util.Log.v(TAG, <span class="string">"Validation Failed: Throwing out app foreground state change notification"</span>);</span><br><span class="line">            mHandler.removeMessages(MESSAGE_NOTIFY_LISTENERS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAppForegroundState == AppForegroundState.IN_FOREGROUND) &#123;</span><br><span class="line">                <span class="comment">// If the app entered the foreground then notify listeners right away; there is no validation time for this</span></span><br><span class="line">                mHandler.sendEmptyMessage(MESSAGE_NOTIFY_LISTENERS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We need to validate that the app entered the background. A delay is used to allow for time when the application went into the</span></span><br><span class="line">                <span class="comment">// background but we do not want to consider the app being backgrounded such as for in app purchasing flow and full screen ads.</span></span><br><span class="line">                mHandler.sendEmptyMessageDelayed(MESSAGE_NOTIFY_LISTENERS, APP_CLOSED_VALIDATION_TIME_IN_MS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyListenersHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">NotifyListenersHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message inputMessage)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (inputMessage.what) &#123;</span><br><span class="line">                <span class="comment">// 解码完成</span></span><br><span class="line">                <span class="keyword">case</span> MESSAGE_NOTIFY_LISTENERS:</span><br><span class="line">                    <span class="comment">/* 通知所有观察者状态发生了改变 */</span></span><br><span class="line">                    android.util.Log.v(TAG, <span class="string">"App just changed foreground state to: "</span> + mAppForegroundState);</span><br><span class="line">                    notifyListeners(mAppForegroundState);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(inputMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2)_activity必须通知可见性的改变">2) activity必须通知可见性的改变</h3><p>所有的activity都要实现下面的方法来通知管理者其可见性的改变，最好添加到你的base activity中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    AppForegroundStateManager.getInstance().onActivityVisible(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AppForegroundStateManager.getInstance().onActivityNotVisible(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3)_订阅前台的变化">3) 订阅前台的变化</h3><p>订阅你感兴趣的前台的状态变化。application类的onCreate方法是首先需要订阅的，这样才能保证每次应用进入或退出前台的时候能收到通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AppForegroundStateManager.getInstance().addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppForegroundStateChange</span><span class="params">(AppForegroundStateManager.AppForegroundState newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AppForegroundStateManager.AppForegroundState.IN_FOREGROUND == newState) &#123;</span><br><span class="line">            <span class="comment">// App just entered the foreground. Do something here!</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// App just entered the background. Do something here!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入思考">深入思考</h2><p>有一些细节还需要再讨论。你需要做一些改变来适配你的应用。</p>
<h2 id="验证时间">验证时间</h2><p>计时器应该隔多久检测一次应用是否真正进入后台。在上面的代码中设置为30秒。</p>
<p>在应用运行的时候，第三方程序的activity可能会出现占满屏幕，比如说google的支付应用或者facebook的登录。这些程序必然会导致你的程序进入后台，因为你应用的activity都没有在前台显示。这种情况并不能当作用户离开了程序，因为他们并没有真正地离开。30秒的超时刚好可以解决这个问题。比如说绝大部分的用户都会在30秒之内完成支付操作，这样他们就不会被当作离开应用。</p>
<p>如果这种情况不适合你，那么我建议你将验证时间设置为4秒。对于那些缓慢的设备来说，这段时间已经足够用来在旋转的时候创建一个activity。</p>
<h2 id="CPU休眠">CPU休眠</h2><p>还有一个潜在问题，如果用户在退出应用之后马上就锁屏（或者在应用还在运行的时候锁屏），不能保证CPU有足够长的运行时间来完成后台检测任务。为了确保像预期的一样工作，你需要持有唤醒锁防止CPU休眠，直到应用退出事件得到验证。实际上使用唤醒锁使这个看起来并不是什么大问题。</p>
<h2 id="论应用如何启动">论应用如何启动</h2><p>到目前为止，我们知道了如何检测应用是什么时候被打开或者关闭的，但是我们还不知道应用是如何被打开的。是用户点击了通知，还是他们点击一个链接，又或者是他们只是从应用图标或最近任务点进来的？</p>
<h2 id="记录启动方式">记录启动方式</h2><p>首先我们要在某个地方记录应用打开的方式。在这段代码中，我在application类中添加了一个枚举型变量用来记录应用是如何被打开的。这个建立在上一个例子的基础之上，所以我们打印一下日志，来看看应用是什么时候被打开的和如何被打开的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String TAG = MyApplication.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> LaunchMechanism &#123;</span><br><span class="line">        DIRECT,</span><br><span class="line">        NOTIFICATION,</span><br><span class="line">        URL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LaunchMechanism mLaunchMechanism = LaunchMechanism.DIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLaunchMechanism</span><span class="params">(LaunchMechanism launchMechanism)</span> </span>&#123;</span><br><span class="line">        mLaunchMechanism = launchMechanism;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AppForegroundStateManager.getInstance().addListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppForegroundStateChange</span><span class="params">(AppForegroundStateManager.AppForegroundState newState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AppForegroundStateManager.AppForegroundState.IN_FOREGROUND.equals(newState)) &#123;</span><br><span class="line">            <span class="comment">// 应用刚进入前台</span></span><br><span class="line">            Log.i(TAG, <span class="string">"App Just Entered the Foreground with launch mechanism of: "</span> + mLaunchMechanism);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 应用刚进入前台，并设置我们的登录模式为当前的默认状态</span></span><br><span class="line">            mLaunchMechanism = LaunchMechanism.DIRECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置启动方式">设置启动方式</h2><p>现在当用户打开应用时，我们就可以打印出启动的方式，但实际上我们还没有设置它的值。所以下一步就是要在用户通过链接或通知打开应用的时候设置启动方式。如果不是上述两个方式，则说明用户是直接打开应用。</p>
<h2 id="记录链接点击">记录链接点击</h2><p>为了记录用户通过点击链接打开应用，需要在某个地方拦截这个链接，加入下面这行代码。确保这行代码在activity的onStart()之前调用的。根据你的代码结构，可能需要把代码添加到很多地方或者一个公用的链接拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getApplication().setLaunchMechanism(LaunchMechanism.URL);</span><br></pre></td></tr></table></figure>
<h2 id="记录通知事件">记录通知事件</h2><p>记录从通知进入是有诀窍的。手机显示通知，用户点击它，打开一个被绑定了的PendingIntent。这个诀窍就是在给所有的PendingIntent加一个标志，用来说明这个Intent是来自通知的。换句话说，当intent最终打开activity的时候，我们需要能够检测到这个intent来自于通知的。</p>
<p>下面就是一个创建来自通知的PendingIntent，把下面的代码添加到每一个intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_HANDLING_NOTIFICATION = <span class="string">"Notification.EXTRA_HANDLING_NOTIFICATION"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Extra 可以知道 Activity 是否通过推送启动</span></span><br><span class="line">intent.putExtra(EXTRA_HANDLING_NOTIFICATION, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>最后我们还需要做的就是检查每个activity的标志（添加到你的base activity）。如果我们检测到这个标志量，那么就知道这个activity是通过通知产生的，我们可以设置启动方式为通知启动。这个步骤必须在onCreat里面完成，这样它才可以在应用显示到前台(打印启动方式)之前设置值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.getExtras() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 Activity 是否由用户点击推送启动</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getExtras().getBoolean(EXTRA_HANDLING_NOTIFICATION, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">// 发出“应用通过用户点击推送启动”的通知</span></span><br><span class="line">            getApplication().setLaunchMechanism(LaunchMechanism.NOTIFICATION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于完成了。现在你不仅可以检测应用什么时候启动或关闭的，还可以检测出它是如何启动的。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://engineering.meetme.com/2015/04/android-determine-when-app-is-opened-or-closed/" target="_blank" rel="external">Determine when App is Opened or Closed</a></li>
<li>原文作者 : <a href="http://engineering.meetme.com/author/bdonahue/" target="_blank" rel="external">Bill Donahue</a></li>
<li><a href="www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/xianjiajun" target="_blank" rel="external">xianjiajun</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题">问题</h2><p>当开发安卓程序的时候，我们不免需要去检测应用什么时候在前台运行，用户什么时候离开。不幸的是，没有一个简单的方法可以做到这点。当用户第一次启动的时候去检测还是不难，但如果是重新打开或关闭就不简单了。<br>]]>
    
    </summary>
    
      <category term="小技巧" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Content Transition  (part 2)]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-fragment-content-transitions-in-depth-part2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/activity-fragment-content-transitions-in-depth-part2/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:07:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="深入理解Content_Transition">深入理解Content Transition</h1><p>这篇文章会深度分析 Content Transitions 和它在 Activity &amp; Fragment Transitions API 中的作用。这篇文章是下面这个系列中的第二篇：</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Content Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)<a id="more"></a>
我们先来总结下在 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a> 中提到的关于 Content Transitions 的知识点，然后<br>说一说在 Android Lollipop 中是怎样使用它来构建合适的过渡动画。</li>
</ul>
<hr>
<h2 id="Content_Transition_是什么？">Content Transition 是什么？</h2><p>Content transition 决定了非共享元素 View (也称为 transitioning view) 在<br>Activity &amp; Fragment 过渡期间是如何进入或退出场景的。出于 Google 新的设计语言<br><a href="http://www.google.com/design/spec/animation/meaningful-transitions.html" target="_blank" rel="external">Material Design</a> , content transitions 允许我们协调 Activity/Fragment 中每一个<br> view 的进入和退出 transition，轻松搞定流畅的屏幕切换动作。<br>开始使用 Android Lollipop，调用下面这些<a href="http://developer.android.com/reference/android/view/Window.html" target="_blank" rel="external"> Window </a> 和<br><a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external"> Fragment </a> 方法可以通过程序设置 content transitions :</p>
<ul>
<li><p><strong>setExitTransition()</strong> - 当 A <strong>启动</strong> B 时， <strong>A</strong> 中 views <strong>离开</strong>场景的退出过渡动画</p>
</li>
<li><p><strong>setEnterTransition()</strong> - 当 A <strong>启动</strong> B 时， <strong>B</strong> 中 views <strong>进入</strong>场景的进入过渡动画</p>
</li>
<li><p><strong>setReturnTransition()</strong> - 当 B <strong>返回</strong> A 时， <strong>B</strong> 中 views <strong>离开</strong>场景的返回过渡动画</p>
</li>
<li><p><strong>setReenterTransition()</strong> - 当 B <strong>返回</strong> A 时， <strong>A</strong> 中 views <strong>进入</strong>场景的重入过渡动画</p>
</li>
</ul>
<p>(注:A 和 B 是Activity 见 <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">part 1</a>)。</p>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/15/games-opt.mp4" target="_blank" rel="external"><strong>Video 2.1</strong></a> - Content transitions in the Google Play Games app (as of v2.2). Click to play.</p>
<hr>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/15/games-opt.mp4" target="_blank" rel="external"><strong>Video 2.1</strong></a>作为示例阐明了在 Google Play Games app 中是如何使<br>用 content transitions 实现流畅的 activitiy 切换动画。当第二个 activity 启动，<br>它的<strong>进入</strong> content transition 轻轻地从屏幕底部边缘将头像推入场景。按下返回按钮后，<br>第二个 activity 的<strong>返回</strong> content transition 将图层分成上下两块，分别推出屏幕。</p>
<hr>
<p>目前为止我们对 content transitions 的分析仅仅停留在表面，一些重要的问题仍然没有涉及。<br>例如 Content Transition 在底层是如何实现的？都有哪些类型的 <strong>Transition</strong> 对象可以使用?框架是如何确定哪些 view<br>是 transitioning view? 在 content transitions 中一个 <strong>ViewGroup</strong> 和它的子视图能不能当成一个整体<br>执行动画?下面我们就来一个一个解答这些问题。</p>
<hr>
<h2 id="Content_Transitions_底层深入">Content Transitions 底层深入</h2><p>上篇文章我们说过 Transition 的两个主要职责分别是获取目标视图的开始结束状态和创建这两个状态间的过渡动画。同样，框架必须先改变每个 transitioning view 的可见性并将状态信息交给 content<br>transition ，它才能创建过渡动画。更准确的说，当 Activity <strong>A</strong> 启动 Activity <strong>B</strong> 将会出现以下事件：<a id="1" href="#b1">(1)</a></p>
<ol>
<li><p>Activity <strong>A</strong> 调用 <strong>startActivity()</strong></p>
<ul>
<li>框架首先会遍历 <strong>A</strong> 的 view 层次结构，确定当 <strong>A</strong> 的退出 transition 运行后有哪些<br>transitioning views 会退出场景。</li>
<li><strong>A</strong> 的退出 transition 捕获 A 中 transitioning views 的起始状态。</li>
<li>框架将 <strong>A</strong> 中所有 transitioning views 设置为<strong>不可见</strong>。</li>
<li>在下一个画面中，<strong>A</strong> 的退出 transition 捕获 <strong>A</strong> 中所有 transitioning views 的结束状态。</li>
<li><strong>A</strong> 的退出 transition 比较每一个 transitioning view 开始和结束状态的不同，<br>并基于这些信息创建一个 <strong>Animator</strong>，最后运行 <strong>Animator</strong> 将所有 transitioning views<br>移出场景。</li>
</ul>
</li>
<li><p>Activity <strong>B</strong> 被启动</p>
<ul>
<li>框架遍历 <strong>B</strong> 的 view 层次结构， 确定当 B 的进入 transition 运行后有哪些<br> transitioning views 会进入场景。</li>
<li><strong>B</strong> 的进入 transition 捕获 B 中 transitioning views 的起始状态。</li>
<li>框架将 <strong>B</strong> 中所有  transitioning views  设置为<strong>可见</strong></li>
<li>在下一个画面中，<strong>B</strong> 的进入 transition 捕获 <strong>B</strong> 中所有 transitioning views 的结束状态。</li>
<li><strong>B</strong> 的进入 transition 比较每一个 transitioning view 开始和结束状态的不同，<br>并基于这些信息创建一个 <strong>Animator</strong>，最后运行 <strong>Animator</strong> 将所有 transitioning views<br>移入场景。</li>
</ul>
</li>
</ol>
<hr>
<p>框架通过在<strong>可见</strong>和<strong>不可见</strong>之间切换每个 transitioning view 的可见性来保证<br>content transition 能够获得用来构建目标动画所需要的状态信息。<br>显然所有的 content <strong>Transition</strong> 对象至少要能够获取和记录每个 transitioning view<br>起始和结束状态的可见性。还好 <a href="https://developer.android.com/reference/android/transition/Visibility.html" target="_blank" rel="external">Visibility</a> 这个抽象类已经提供了这个功能 :<br>需要创建并返回 (让 view 进入/退出场景的) <strong>Animator</strong> 的 <strong>Visibility</strong><br>子类只需要实现 <a href="https://developer.android.com/reference/android/transition/Visibility.html#onAppear(android.view.ViewGroup,%20android.transition.TransitionValues,%20int,%20android.transition.TransitionValues,%20int)" target="_blank" rel="external"><strong>onAppear()</strong></a>  和 <a href="https://developer.android.com/reference/android/transition/Visibility.html#onDisappear(android.view.ViewGroup,%20android.transition.TransitionValues,%20int,%20android.transition.TransitionValues,%20int)" target="_blank" rel="external"><strong>onDisappear()</strong></a> 这两个工厂方法。<br>从 API 21 开始，有三个已经写好的 <strong>Visibility</strong> 实现( <a href="https://developer.android.com/reference/android/transition/Fade.html" target="_blank" rel="external"><strong>Fade</strong></a>, <a href="https://developer.android.com/reference/android/transition/Slide.html" target="_blank" rel="external"><strong>Slide</strong></a> 和 <a href="https://developer.android.com/reference/android/transition/Explode.html" target="_blank" rel="external"><strong>Explode</strong></a>)，可以使用它们来构建  Activity 和 Fragment 的 content transitions。<br>有必要的话也可以自己实现 Visibility 类达到想实现的效果。后边的文章会有具体介绍。</p>
<hr>
<h2 id="Transitioning_Views_和_Transition_Groups">Transitioning Views 和 Transition Groups</h2><p>直到现在，我们已经假设 content transitions 操作一组叫做 transitioning views 的非共享 view 。<br>在这节中，我们将探讨 Transition 框架如何确定哪些 View 是非共享 View，以及如何使用 transition group 深度定制框架</p>
<p>Transition 开始前，框架会在 Activity 窗口(或 Fragment) 的视图层上执行一个递归的搜索，用来<br>构建 transitioning views 的集合。这个搜索通过对图层的根视图递归调用重写的<strong>ViewGroup#captureTransitioningViews</strong> 方法启动，部分<a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/java/android/view/ViewGroup.java#L6243-L6258" target="_blank" rel="external">源码</a>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">captureTransitioningViews</span><span class="params">(List&lt;View&gt; transitioningViews)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTransitionGroup()) &#123;</span><br><span class="line">        transitioningViews.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            View child = getChildAt(i);</span><br><span class="line">            child.captureTransitioningViews(transitioningViews);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/15/webview-opt.mp4" target="_blank" rel="external"><strong>Video 2.2</strong></a> - A simple Radiohead app that illustrates a potential bug involving transition groups and WebViews. Click to play.</p>
<hr>
<p>这个递归调用很简单: 框架遍历树的每一层，直到找到一个<strong>可见的</strong><a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/java/android/view/View.java#L19351-L19362" target="_blank" rel="external"> leaf view </a> (子视图)或者一个 transition group。Transition groups 本质上允许我们在 Activity/Fragment 的 transition<br>期间将全部 <strong>ViewGroups</strong> 当作一个整体执行过渡动画。如果一个 <strong>ViewGroup</strong> 的<br><a href="https://developer.android.com/reference/android/view/ViewGroup.html#isTransitionGroup()" target="_blank" rel="external"><code>isTransitionGroup ()</code></a> <a id="2" href="#b2">(2)</a>方法返回值为 <strong>true</strong>，它和它的子视图会被当作一<br>个整体来执行过渡动画。否则，这个递归搜索会继续执行下去， 这个 ViewGroup 的子视图在动画期间<br>会执行自己的独立的过渡动画。搜索最终会返回一个全部由 content transition<br> 执行动画的 transitioning views 集合 。<a id="3" href="#b3">(3)</a></p>
<hr>
<p>上面的 <a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/15/games-opt.mp4" target="_blank" rel="external"><strong>Video 2.1</strong></a> 展示了 transition groups  的效果。在 enter transition ，<br>用户头像是作为一个单独的 View 进入屏幕，return transition 时却是和包含它的 parent<br><strong>ViewGroup</strong> 一起消失。在  Google Play Games 里可能用了一个 transition group<br>来实现在返回前一个 activity 时，让当前场景拦腰斩断的效果。</p>
<hr>
<p>有时 transition groups 还被用来修复 Activity/Fragment transitions 中诡异的 bugs。<br>例如，Video 2.2中: <strong>调用 Activity</strong> 显示了一个电台司令专辑图的网格布局，<br><strong>被调用 Activity</strong> 展示了一个背景标题图，一个共享元素专辑封面图还有一个 <strong>WebView</strong>。<br>这个 App 使用了一个和 Google Play Games app 类似的 return transition，将背景图和底部的<br><strong>WebView</strong> 分别推出屏幕。然而这里有个小故障导致 <strong>WebView</strong> 不能流畅的退出屏幕。</p>
<p>好吧，错误在哪呢？原来 <strong>WebView</strong> 是一个 <strong>ViewGroup</strong>，因此在默认情况下 WebView 不会被当作 transitioning view<br>的。当 return transition 被执行时，<strong>WebView</strong> 会被完全忽略，直到过渡动画结束才会被移除屏幕。<br>找到问题就好解决了，只要在 return transition 开始前调用 <code>webView.setTransitionGroup(true)</code><br>就能修复这个bug。</p>
<hr>
<h2 id="结语">结语</h2><p>总之，这篇文章讲了三个重点:</p>
<ul>
<li>Content transition 决定了 Activity/Fragment 中非共享元素视图(被称为 transitioning views)<br> 在 Activity/Fragment transition 期间如何进入或退出场景。</li>
<li>Content transitions 被触发是因为它的 transitioning views 可见性改变  ，并且应该总是继承<br>  <strong>Visibility</strong> 这个抽象类。</li>
<li>Transition groups 可以让我们在 content transition 期间将 <strong>ViewGroups</strong><br>  当作一个整体执行过渡动画。</li>
</ul>
<p>希望这篇文章能够帮到你，欢迎留下评论～</p>
<hr>
<ol>
<li>Activities 和 Fragments 在  return/reenter transitions 期间出现的一系列事件相似。<br> <a id="b1" href="#1">↩</a></li>
<li>如果 ViewGroup 有一个非空的  background drawable 或者非空的默认 transition name 那么<br> <code>isTransitionGroup()</code> 将返回 <strong>true</strong> (所述方法<a href="https://developer.android.com/reference/android/view/ViewGroup.html#isTransitionGroup()" target="_blank" rel="external">文档</a>)<br> <a id="b2" href="#2">↩</a></li>
<li>当 transition 运行时，任何在 content <strong>Transition</strong> 对象中被明确地 <a href="https://developer.android.com/reference/android/transition/Transition.html#addTarget(android.view.View)" target="_blank" rel="external"> added </a>或<br> <a href="https://developer.android.com/reference/android/transition/Transition.html#excludeTarget(android.view.View,%20boolean)" target="_blank" rel="external"> excluded </a> 的 view 也会被考虑。<a id="b3" href="#3">↩</a></li>
</ol>
<blockquote>
<ul>
<li>原文链接 :  <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">Content Transitions In-Depth (part 2)</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a></li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="深入理解Content_Transition">深入理解Content Transition</h1><p>这篇文章会深度分析 Content Transitions 和它在 Activity &amp; Fragment Transitions API 中的作用。这篇文章是下面这个系列中的第二篇：</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html">深入理解 Content Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html">深入理解共享元素 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)]]>
    
    </summary>
    
      <category term="动画" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[功能测试框架 espresso]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/the-hitchhikers-guide-to-android-testing-part-2-espresso/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/the-hitchhikers-guide-to-android-testing-part-2-espresso/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:08:14.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xi8kj.com1.z0.glb.clouddn.com/VtFd68Pr19fYk.gif" alt="VtFd68Pr19fYk."></p>
<p>正如<a href="https://plus.google.com/+AliDerbane" target="_blank" rel="external">Ali Derbane</a>和我写的第一篇关于Android的功能测试的文章中提到的，有许多的框架供你使用.<br>在这个旅程的第二部分,我将讲解<a href="https://code.google.com/p/android-test-kit/" target="_blank" rel="external">Espresso</a>这个功能测试框架.</p>
<h3 id="简介">简介</h3><p>Espresso 是在2013年的 GTAC 上首次提出，目的是让开发人员能够快速地写出简洁，美观，可靠的 Android UI 测试。<br>Espresso有以下几个通用组件:<br><a id="more"></a></p>
<ul>
<li>“Espresso”类提供的“onView”和“onData”方法,仅可用于特定接口上测试最优数.</li>
<li><code>ViewMatchers</code> 包含一个实现了<code>Matcher &lt;? super View&gt;</code>接口的对象集合. 使用该类你可以收集或是检查View元素.例如,通过文本 “7” 获取一个View元素(Button).</li>
<li><code>ViewActions</code> 包含了一组<code>viewAction</code>对象，储存了将要在View上执行的动作. 这些动作被传递给<code>ViewInteraction.perform</code>方法,也许包含更多的动作. For 例如, 点击一下View元素(Button).</li>
<li><code>ViewAssertions</code> 包含<code>ViewAssertion</code>集合，用于对Views进行检查.</li>
</ul>
<p>举个例子说明一下，这些测试组件看起来就像下面这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Espresso.onView(ViewMatchers.withText(<span class="string">"7"</span>)).perform(ViewActions.click());</span><br><span class="line">Espresso.onView(withId(R.id.result)).check(ViewAssertions.matches(ViewMatchers.withText(<span class="string">"42"</span>)));</span><br></pre></td></tr></table></figure>
<p>好消息，去年谷歌推出了集成Espresso的<a href="https://developer.android.com/tools/support-library/index.html" target="_blank" rel="external">Testing Support Library</a>.因此，让我们通过实现Espresso开始吧.</p>
<blockquote>
<p> 为了方便解释, 我们要编写一些测试用例来测试<a href="https://github.com/welsinga/sample_espresso/app" target="_blank" rel="external">Android calculator application</a>这个App. 先来实现一个测试“6”x“7”等于“42”是否正确的普通测试场景。</p>
</blockquote>
<h3 id="定义test_runner">定义test runner</h3><p> 使用Espresso我们首先需要定义这些测试用例。Espresso使用新的名为AndroidJUnitRunner的测试用例。该测试用例基于“InstrumentationTestRunner”和“GoogleInstrumentationTestRunner”,运行JUnit3和JUnit4来测试你的Android应用程序。</p>
<p>首先将依赖项添加到你的<code>build.gradle</code>文件中, 这里假设你已经安装好了<a href="https://developer.android.com/tools/support-library/index.html" target="_blank" rel="external">Testing Support Library</a>.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">dependencies</span> &#123;</span><br><span class="line">  androidTestCompile <span class="string">'com.android.support.test:testing-support-lib:0.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加测试用例到你的<code>build.gradleandroid.defaultConfig</code>配置中 </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">  ...</span><br><span class="line">  testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写测试">编写测试</h3><p>你可能已经想到了，测试类必须在<code>src\androidTest\com.example.package.tests</code>中.包com.example.package是在AndroidManifest文件中指定的属性.</p>
<p>每一个测试类还必须继承抽象类<code>ActivityInstrumentationTestCase2</code>并且使用默认测试的 Activity 作为泛型.</p>
<p>它还需要通过<code>super()</code>方法传递给父类.要使被测试的Activity被测试框架调用，只需要在setup方法中同步调用<code>getActivity()</code>方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInstrumentationTest</span> <span class="keyword">extends</span> <span class="title">ActivityInstrumentationTestCase2</span>&lt;<span class="title">ActivityToTest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FunctionalInstrumentationTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ActivityToTest.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp();</span><br><span class="line">        getActivity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如前面提到的,我们想要检查“6”x“7”是否等于“42”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnswer_to_the_Ultimate_Question_of_Life_the_Universe_and_Everything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        onView(withText(<span class="string">"7"</span>)).perform(click());</span><br><span class="line">        onView(withText(<span class="string">"×"</span>)).perform(click());</span><br><span class="line">        onView(withText(<span class="string">"6"</span>)).perform(click());</span><br><span class="line">        onView(withText(<span class="string">"="</span>)).perform(click());</span><br><span class="line"></span><br><span class="line">        onView(withId(R.id.resText)).check(matches(withText(<span class="string">"42"</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到,这个示例是使用静态导入.这样做完全是为了使代码更易于阅读.</p>
<p>其他你可能会用到的操作:</p>
<ul>
<li><code>pressBack()</code>; to simulate the use of the “back” button,</li>
<li><code>isDisplayed()</code>; to check if an element is being shown and</li>
<li><code>scrollTo()</code>; to scroll to an element.</li>
<li><code>pressBack()</code>; 模拟后退按钮</li>
<li><code>isDisplayed()</code>; jian检查某个元素是否显示</li>
<li><code>scrollTo()</code>; 滚动到另外一个元素</li>
</ul>
<h3 id="运行测试">运行测试</h3><p>现在我们做做有趣的,运行测试.这可以通过<code>gradle clean assembleDebug connectedAndroidTest</code>从命令行运行,或者使用Android Studio:</p>
<ol>
<li>打开Run菜单 | Edit Configurations</li>
<li>添加一个新的Android Tests configuration</li>
<li>选择你需要测试的Module</li>
<li>定义我们的测试用例: <code>android.support.test.runner.AndroidJUnitRunner</code></li>
</ol>
<p><img src="http://7xi8kj.com1.z0.glb.clouddn.com/10OjZwNlstPj9e.gif" alt="10OjZwNlstPj9e"></p>
<p>现在你对于Espresso有一些了解了。如果需要深入，可以浏览以下链接:</p>
<ul>
<li><a href="https://code.google.com/p/android-test-kit/" target="_blank" rel="external">Espresso website</a></li>
<li><a href="https://github.com/welsinga/sample_espresso" target="_blank" rel="external">Github repo corresponding to this article</a></li>
<li><a href="https://github.com/googlesamples/android-testing" target="_blank" rel="external">General Espresso Github samples by Google</a></li>
</ul>
<blockquote>
<ul>
<li>原文链接 : <a href="http://wiebe-elsinga.com/blog/the-hitchhikers-guide-to-android-testing-part-2-espresso/" target="_blank" rel="external">the-hitchhikers-guide-to-android-testing-part-2-espresso</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/tiiime" target="_blank" rel="external">kang</a></li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xi8kj.com1.z0.glb.clouddn.com/VtFd68Pr19fYk.gif" alt="VtFd68Pr19fYk."></p>
<p>正如<a href="https://plus.google.com/+AliDerbane">Ali Derbane</a>和我写的第一篇关于Android的功能测试的文章中提到的，有许多的框架供你使用.<br>在这个旅程的第二部分,我将讲解<a href="https://code.google.com/p/android-test-kit/">Espresso</a>这个功能测试框架.</p>
<h3 id="简介">简介</h3><p>Espresso 是在2013年的 GTAC 上首次提出，目的是让开发人员能够快速地写出简洁，美观，可靠的 Android UI 测试。<br>Espresso有以下几个通用组件:<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Retrofit指南]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/retrofit-android-tutorial/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/retrofit-android-tutorial/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:08:42.000Z</updated>
    <content type="html"><![CDATA[<p>这是一篇关于如何使用Retrofit写一个Android的REST客户端的小教程。<br><a id="more"></a><br><img src="http://img.my.csdn.net/uploads/201504/13/1428932650_8819.jpg" alt="Retrofit+Android"></p>
<h2 id="我为什么选择Retrofit？">我为什么选择Retrofit？</h2><p>在使用square的<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>之前，我尝试过Volley和AsyncTask。但在使用过Retrofit之后，我的工作变得更加简单了。在开始阅读教程之前，建议先阅读一下下面的几个话题。这是一个入门项目，可以让你了解如何使用Retrofit从API获取数据。</p>
<p>这个项目也加到了<a href="https://github.com/basil2style/Retrofit-Android-Basic" target="_blank" rel="external">我的Github</a>中。</p>
<p><a href="https://instructure.github.io/blog/2013/12/09/volley-vs-retrofit/" target="_blank" rel="external">AsyncHttp ,Volley和Retrofit的对比</a></p>
<p><img src="http://img.my.csdn.net/uploads/201504/13/1428929622_5444.png" alt="volley-vs-retrofit"></p>
<p>与Retrofit相比，Volley是一个小型的、缺乏正式文档说明库。Retrofit是<a href="https://github.com/square" target="_blank" rel="external">Square</a>开发的，后者还开发过okhttp，picasso…等一些著名的库(你可以在<a href="https://square.github.io/#android" target="_blank" rel="external">这里</a>找到其他的库)。如果你需要Volley的指引，你可以在<a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="external">Google Training</a>或者<a href="https://github.com/DWorkS/VolleyPlus" target="_blank" rel="external">Volley Plus from DWork</a>找到相关文档。</p>
<h2 id="简介">简介</h2><p><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>是<a href="http://square.github.io/" target="_blank" rel="external">Square</a>开发的一个Android和Java的REST客户端库。这个库非常简单并且具有很多特性，相比其他的网络库，更容易让初学者快速掌握。它可以处理GET、POST、PUT、DELETE…等请求，还可以使用picasso加载图片。在使用Picasso或Volley之前，可以先来读读<a href="https://www.bignerdranch.com/blog/solving-the-android-image-loading-problem-volley-vs-picasso/" target="_blank" rel="external">这个</a>。</p>
<p>别纠结简介了，开始编码吧!!!</p>
<p>Demo里使用是Github的API : <a href="https://api.github.com/users/basil2style" target="_blank" rel="external">https://api.github.com/users/basil2style</a></p>
<p>你可以使用这个Demo App来搜索github的用户详细信息</p>
<p><a href="https://github.com/basil2style/Retrofit-Android-Basic" target="_blank" rel="external">GITHUB</a></p>
<p><img src="http://img.my.csdn.net/uploads/201504/13/1428929608_5673.png" alt="Download-Code"></p>
<p><a href="https://github.com/basil2style/Retrofit-Android-Basic/blob/master/APK/Retrofit%20Example.apk" target="_blank" rel="external">Download APK </a></p>
<p><a href="https://github.com/basil2style/Retrofit-Android-Basic/blob/master/APK/Retrofit%20Example.apk" target="_blank" rel="external"><img class="" src="http://img.my.csdn.net/uploads/201504/13/1428929607_5991.png" alt="qr code" width="196" height="196"></a></p>
<h2 id="1)_概述">1) 概述</h2><p><img src="http://img.my.csdn.net/uploads/201504/13/1428929609_1240.png" alt="Retrofit-3-classes"></p>
<p>1) <strong>POJO或模型实体类</strong> : 从服务器获取的JSON数据将被填充到这种类的实例中。</p>
<p>2) <strong>接口</strong> : 我们需要创建一个接口来管理像GET,POST…等请求的URL，这是一个服务类。</p>
<p>3) <strong>RestAdapter类</strong> : 这是一个REST客户端(RestClient)类，retrofit中默认用的是Gson来解析JSON数据，你也可以设置自己的JSON解析器，比如jackson，我们将在下面的教程中详细解说明。</p>
<h2 id="2)_添加Retrofit库到项目中">2) 添加Retrofit库到项目中</h2><p><em><strong>Gradle</strong></em> :</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.squareup.retrofit:retrofit:1.9.0'</span></span><br></pre></td></tr></table></figure>
<p>目前，1.9.0是最新的版本. 你可以在<a href="https://github.com/square/retrofit" target="_blank" rel="external">这里</a>获取更新的版本。</p>
<p><em><strong>JAR</strong></em> :</p>
<p> <a href="https://search.maven.org/remote_content?g=com.squareup.retrofit&amp;a=retrofit&amp;v=LATEST" target="_blank" rel="external">下载Jar包</a></p>
<h2 id="3)_创建项目">3) 创建项目</h2><p>1) 在Android Studio中创建新项目: <strong>File  =&gt;  New Project</strong> ，填写描述信息并点击<strong>Next</strong>.</p>
<p>2) 填写<strong>minimum SDK</strong>，我用的是<strong>4.0+</strong>(Retrofit支持Android <strong>2.3+</strong>或Java <strong>6</strong>以上)</p>
<p>3) 选择<strong>Blank Activity</strong>然后填写<strong>Activity Name</strong>和<strong>Layout Name</strong>，最后点击 <strong>Finish</strong>.</p>
<p>4) <strong>Gradle</strong> : 你可以在<strong>app =&gt;build.gradle</strong>中添加Retrofit的库文件。</p>
<p><img src="http://img.my.csdn.net/uploads/201504/13/1428929609_9928.png" alt="gradle-dependencies"></p>
<p>Jar包的添加方式 :  将jar包添加到libs文件夹下，右键点击Add as Library.</p>
<p>5) 创建两个包：<strong>API</strong>和<strong>model</strong>。</p>
<p>6) 在<strong>API</strong>包下右键点击<strong>New</strong> =&gt; <strong>Java Class</strong> , 填写<strong>Name</strong>为<font style="color: #ff0000;">gitapi</font>并设置为<font style="color: #ff0000;">Interface</font>。</p>
<p>6) 在<strong>API</strong>包下创建名<font style="color: #ff0000;">gitapi</font>的<font style="color: #ff0000;">接口</font>。</p>
<p>7) 在<strong>model</strong>包下右键点击<strong>New</strong> =&gt; <strong>Java Class</strong>, 填写<strong>Name</strong>为<font style="color: #ff0000;">gitmodel</font>并设置为<font style="color: #ff0000;">Class</font>。</p>
<p><img src="http://img.my.csdn.net/uploads/201504/13/1428929622_5732.png" alt="proj-structure"></p>
<h2 id="4)_Android_Manifest">4) Android Manifest</h2><p>1) 添加<font style="color: #ff0000;">INTERNET PERMISSION</font>权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>你的<code>Manifest</code>文件看起来应该是这样的 :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>  </span><br><span class="line">          <span class="attribute">package</span>=<span class="value">"com.makeinfo.flowerpi"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:allowBackup</span>=<span class="value">"true"</span></span><br><span class="line">   	   <span class="attribute">android:icon</span>=<span class="value">"@mipmap/ic_launcher"</span></span><br><span class="line">       <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">       <span class="attribute">android:theme</span>=<span class="value">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">           <span class="attribute">android:name</span>=<span class="value">".MainActivity"</span></span><br><span class="line">           <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5)_模型类">5) 模型类</h2><p>首先，我们需要创建一个POJO或模型类。服务器返回的JSON数据不能在Java里直接使用，所以我们需要用模型类来做转换。</p>
<p>URL的结构是这样的：<a href="https://api.github.com/users/" target="_blank" rel="external">https://api.github.com/users/</a> + “search term”</p>
<p>举个栗子：<a href="https://api.github.com/users/basil2style" target="_blank" rel="external">https://api.github.com/users/basil2style</a></p>
<p>我们的JSON返回数据是这样的：</p>
<p><img src="http://img.my.csdn.net/uploads/201504/13/1428929583_4905.jpg" alt="json object response"></p>
<p>这是一个<strong>JSON Object</strong>，如果你不了解<strong>JSON Array</strong>和<strong>JSON Object</strong>的区别，请看<a href="http://stackoverflow.com/questions/12289844/difference-between-jsonobject-and-jsonarray" target="_blank" rel="external">这里</a>。</p>
<p>使用<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="external">jsonschema2pojo</a>来创建POJO更加简单，不要每一个JSON数据的POJO转换都用它，有时候会报错。选择源代码类型为<strong>Json</strong>，注解类型是<strong>Gson</strong>,然后点击<strong>preview</strong>。</p>
<p>点击<a href="http://pastebin.com/4xckerN1" target="_blank" rel="external">这里</a>(需翻墙)查看<code>gitmodel.java</code>源代码。</p>
<h2 id="6)_gitapi-java">6) gitapi.java</h2><p>1) 现在我们需要使用接口调用URL.</p>
<p><strong><code>@GET(&quot;/users/{user}&quot;)</code></strong>, 添加这个注解会调用服务器，参数url基于BASE URL，服务调用的参数以’/‘开头，其中<font style="color: #ff0000;">{user}</font>是从EditText获取的字符串。</p>
<p><strong><code>@Path(&quot;user&quot;) String user</code></strong> 就是我们从EditText获取的字符串。</p>
<p>服务器端响应的数据则会被存储到POJO实例中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">gitapi</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@GET</span>(<span class="string">"/users/&#123;user&#125;"</span>)      <span class="comment">// here is the other url part.best way is to start using /</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFeed</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user, Callback&lt;gitmodel&gt; response)</span>;</span><br><span class="line">     <span class="comment">// string user is for passing values from edittext for eg: user=basil2style,google</span></span><br><span class="line">   	 <span class="comment">// response is the response from the server which is now in the POJO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7)_RestAdapter">7) RestAdapter</h2><p>现在该主要部分了，你需要设置<code>Rest Adapter</code>和<code>service</code>类.</p>
<p>1) <font style="color: #ff0000;">API</font>就是<code>Base URL</code>.</p>
<p>2) 我们需要设置<strong><code>Endpoint(API)</code></strong>并调用<strong><code>buid()</code></strong>方法来创建一个<strong><code>RestAdapter</code></strong>对象。</p>
<p>3) 使用我们的<strong><code>gitapi</code></strong>来创建一个服务适配器(service for adapter)。</p>
<p>4) 调用函数并获得响应数据，回调接口是用来异步的获取模型实例的，我们的回调接口需要实现成功回调方法(success request)和错误处理方法(error handling)。</p>
<p>5) 我们解析好的json数据的现在就存在于POJO实例中了，你可以每次调用一条。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String API = <span class="string">"https://api.github.com"</span>;</span><br><span class="line"></span><br><span class="line">RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder().setLogLevel(RestAdapter.LogLevel.FULL).setEndpoint(API).build(); </span><br><span class="line"></span><br><span class="line">gitapi git = restAdapter.create(gitapi.class);</span><br><span class="line"></span><br><span class="line">git.getFeed(user, <span class="keyword">new</span> Callback&lt;gitmodel&gt;() &#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(gitmodel gitmodel, Response response)</span> </span>&#123;</span><br><span class="line">		tv.setText(<span class="string">"Github Name :"</span> + gitmodel.getName() + </span><br><span class="line">		           <span class="string">"\nWebsite :"</span> + gitmodel.getBlog() + </span><br><span class="line">		           <span class="string">"\nCompany Name :"</span> + gitmodel.getCompany());</span><br><span class="line"></span><br><span class="line">		pbar.setVisibility(View.INVISIBLE); <span class="comment">// disable progressbar</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line"> 		tv.setText(error.getMessage());</span><br><span class="line"> 		pbar.setVisibility(View.INVISIBLE); <span class="comment">//disable progressbar</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>完整的<code>MainActivty.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.makeinfo.flowerpi;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBarActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.ProgressBar;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.makeinfo.flowerpi.API.gitapi;</span><br><span class="line"><span class="keyword">import</span> com.makeinfo.flowerpi.model.gitmodel;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> retrofit.Callback;</span><br><span class="line"><span class="keyword">import</span> retrofit.RestAdapter;</span><br><span class="line"><span class="keyword">import</span> retrofit.RetrofitError;</span><br><span class="line"><span class="keyword">import</span> retrofit.client.Response;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Button click;</span><br><span class="line">    TextView tv;</span><br><span class="line">    EditText edit_user;</span><br><span class="line">    ProgressBar pbar;</span><br><span class="line">    String API = <span class="string">"https://api.github.com"</span>;	<span class="comment">// BASE URL</span></span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"> </span><br><span class="line">        click = (Button) findViewById(R.id.button);</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        edit_user = (EditText) findViewById(R.id.edit);</span><br><span class="line">        pbar = (ProgressBar) findViewById(R.id.pb);</span><br><span class="line">        pbar.setVisibility(View.INVISIBLE);</span><br><span class="line">       </span><br><span class="line">        click.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                String user = edit_user.getText().toString();</span><br><span class="line">                pbar.setVisibility(View.VISIBLE);</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// Retrofit section start from here...</span></span><br><span class="line">                <span class="comment">// create an adapter for retrofit with base url</span></span><br><span class="line">                RestAdapter restAdapter = <span class="keyword">new</span> RestAdapter.Builder().setEndpoint(API).build(); </span><br><span class="line">                       </span><br><span class="line">                <span class="comment">// creating a service for adapter with our GET class       </span></span><br><span class="line">                gitapi git = restAdapter.create(gitapi.class);	</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// Now ,we need to call for response</span></span><br><span class="line">                <span class="comment">// Retrofit using gson for JSON-POJO conversion</span></span><br><span class="line">               </span><br><span class="line">                git.getFeed(user,<span class="keyword">new</span> Callback&lt;gitmodel&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(gitmodel gitmodel, Response response)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// we get json object from github server to our POJO or model class</span></span><br><span class="line">                       </span><br><span class="line">                        tv.setText(<span class="string">"Github Name :"</span> + gitmodel.getName() + </span><br><span class="line">                                    <span class="string">"\nWebsite :"</span>+gitmodel.getBlog() + </span><br><span class="line">                                    <span class="string">"\nCompany Name :"</span>+gitmodel.getCompany());</span><br><span class="line">                       </span><br><span class="line">                        pbar.setVisibility(View.INVISIBLE);	<span class="comment">// disable progressbar</span></span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failure</span><span class="params">(RetrofitError error)</span> </span>&#123;</span><br><span class="line">                     	tv.setText(error.getMessage());</span><br><span class="line">                        pbar.setVisibility(View.INVISIBLE);	<span class="comment">// disable progressbar</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span></span><br><span class="line">        getMenuInflater().inflate(R.menu.menu_main, menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Handle action bar item clicks here. The action bar will</span></span><br><span class="line">        <span class="comment">// automatically handle clicks on the Home/Up button, so long</span></span><br><span class="line">        <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span></span><br><span class="line">        <span class="keyword">int</span> id = item.getItemId();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        <span class="keyword">if</span> (id == R.id.action_settings) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>原文链接 : <a href="http://themakeinfo.com/2015/04/retrofit-android-tutorial/" target="_blank" rel="external">Retrofit Android Tutorial</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/yaoqinwei" target="_blank" rel="external">yaoqinwei</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaosssss</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是一篇关于如何使用Retrofit写一个Android的REST客户端的小教程。<br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="网络请求" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android测试框架--Dagger 2 + Espresso 2 + Mockito]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/dagger-2-espresso-2-mockito/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/dagger-2-espresso-2-mockito/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:16:06.000Z</updated>
    <content type="html"><![CDATA[<p>我一直在用Dagger, Espresso和Mockito做Android测试，爱死这个组合了！为了庆祝<a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a>的推出，我分享了一个用Dagger 2, Espresso 2和Mockito做Android测试的<a href="https://github.com/chiuki/android-test-demo" target="_blank" rel="external">Demo</a><br><a id="more"></a></p>
<h3 id="Dagger_组件(Components)">Dagger 组件(Components)</h3><p><a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">Dependency injection(依赖注入)</a> 允许我们在App开发和测试中可以获取到不同的模块，非常有利于创建可重用的测试用例，这个Demo App的功能是以<code>&quot;yyyy-MM-dd&quot;</code>格式显示今天的日期，我们需要测试一下来应对一些已知的日期，而非依赖于运行测试时的真实日期。</p>
<p>在<code>Dagger 2</code>中，一个组件(Component)接口可以给整个App提供模块，并且定义了在哪注入它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoComponent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="annotation">@Component</span>(modules = ClockModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> <span class="keyword">extends</span> <span class="title">DemoComponent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="annotation">@Component</span>(modules = MockClockModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestComponent</span> <span class="keyword">extends</span> <span class="title">DemoComponent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivityTest mainActivityTest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>ApplicationComponent</code></strong>组件用于App的正常运行, 而<strong><code>TestComponent</code></strong>组件则用于测试，这两个组件都可以被注入到<strong><code>MainActivity</code></strong>中。</p>
<p><strong><code>MainActivity</code></strong>如何知道使用的哪个组件(component)? 答案是通过<strong><code>DemoApplication</code></strong>来注入, 它保存着该组件(component)的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DemoComponent component = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate();</span><br><span class="line">	<span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">		component = DaggerDemoApplication_ApplicationComponent</span><br><span class="line">					.builder()</span><br><span class="line">					.clockModule(<span class="keyword">new</span> ClockModule())</span><br><span class="line">					.build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComponent</span><span class="params">(DemoComponent component)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.component = component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoComponent <span class="title">component</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试时，我们需要在<strong><code>onCreate()</code></strong>方法执行之前调用<strong><code>setComponent()</code></strong>方法，将组件设置为<strong><code>TestComponent</code></strong>。而App正常运行时,组件在<strong><code>onCreate()</code></strong>方法中就被设置为<strong><code>ApplicationComponent</code></strong>了。</p>
<h3 id="Mockito">Mockito</h3><p>App中有一个<strong><code>Clock</code></strong>类，其中有一个方法可以返回当前的时间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTime <span class="title">getNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DateTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>TestComponent</code></strong>组件中包含<strong><code>MockClockModule</code></strong>模块，后者使用<a href="http://mockito.org/" target="_blank" rel="external">Mockito</a>提供了一个模拟的<strong><code>Clock</code></strong>。这样<a href="https://github.com/chiuki/android-test-demo/blob/master/app/src/androidTest/java/com/sqisland/android/test_demo/MainActivityTest.java" target="_blank" rel="external"><strong><code>MainActivityTest</code></strong></a>就可以在测试期间提供一个预先设置的日期了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(clock.getNow()).thenReturn(<span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>因为我们使用了单例, 相同的模拟<strong><code>Clock</code></strong>将为整个App提供日期，这样就能被显示提供的日期，而非今天的日期了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onView(withId(R.id.date)).check(matches(withText(<span class="string">"2008-09-23"</span>)));</span><br></pre></td></tr></table></figure>
<h3 id="更多">更多</h3><p>这里还有很多示例, 包括使用intent启动的activity的测试和使用JUnit测试的单元测试，请点击下面链接查看:</p>
<p><a href="https://github.com/chiuki/android-test-demo" target="_blank" rel="external">Click Me</a></p>
<p>相关阅读:</p>
<blockquote>
<ul>
<li><a href="http://engineering.circle.com/instrumentation-testing-with-dagger-mockito-and-espresso/" target="_blank" rel="external">Instrumentation Testing with Dagger, Mockito, and Espresso</a></li>
<li><a href="https://gist.github.com/JakeWharton/1c2f2cadab2ddd97f9fb" target="_blank" rel="external">A JUnit @Rule which launches an activity when your test starts</a></li>
<li><a href="https://code.google.com/p/android-test-kit/wiki/EspressoStartGuide" target="_blank" rel="external">EspressoStartGuide</a> </li>
<li><a href="http://wiebe-elsinga.com/blog/whats-new-in-android-testing/" target="_blank" rel="external">What’s new in Android Testing</a></li>
<li><p><a href="https://github.com/googlesamples/android-testing" target="_blank" rel="external">https://github.com/googlesamples/android-testing</a>  </p>
</li>
<li><p>原文链接 : <a href="http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html" target="_blank" rel="external">Dagger 2 + Espresso 2 + Mockito</a></p>
</li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/yaoqinwei" target="_blank" rel="external">yaoqinwei</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我一直在用Dagger, Espresso和Mockito做Android测试，爱死这个组合了！为了庆祝<a href="http://google.github.io/dagger/">Dagger 2</a>的推出，我分享了一个用Dagger 2, Espresso 2和Mockito做Android测试的<a href="https://github.com/chiuki/android-test-demo">Demo</a><br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义Drawables]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/custom-drawables/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/custom-drawables/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:09:30.000Z</updated>
    <content type="html"><![CDATA[<p>我们都看过关于为什么你应该适当的使<a href="http://www.ryanharter.com/blog/2014/05/14/using-custom-compound-views-in-android/" target="_blank" rel="external">自定义Views</a>和如何能帮助你正确的封装你的应用程序代码的帖子。但非视图相关的部分如何转化为我们apps的其他部分的这种思考方式，我们对此并不非常了解。<br><a id="more"></a><br>在我的应用<a href="https://play.google.com/store/apps/details?id=com.pixite.fragment&amp;referrer=utm_source%3Dryanharter.com%26utm_medium%3Dpost%26utm_content%3Dcustom_drawables" target="_blank" rel="external">Fragment</a>中,有些地方我使用自定义Drawables来封装我的逻辑，就像你在customView中做的一样。</p>
<h2 id="用例">用例</h2><p>在Fragment中,有一些使用水平滚动条作为一个选择视图的地方。这意味着该中心图标就是“选中”的图标,整个条目就该平滑的平移进去或平移出。为此，一个好的显示转换将非常棒。</p>
<p><img src="http://www.ryanharter.com/images/posts/custom-drawables/example.gif" alt=""></p>
<p>虽然这并非完全必要，但我觉得它是一个能让这个滑动更加流畅并增加一个触摸的类在app上的效果。我本可以设置多个imageviews并让他们每个独立出来，但这真是使用自定义drawables的好地方~</p>
<h2 id="自定义Drawables">自定义Drawables</h2><p>在Android里，Drawables和Views实际上非常的相似。他们有相似的方法,例如padding和bounds(layout),并且都有一个可以被重写的draw方法。就我而言，我需要能够在一个选中的图片和一个未选中的图片之间进行转换基础上的一个值。</p>
<p>在我们的例子中，我们简单地创建一个包含其他Drawables(和方向)的Drawable子类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevealDrawable</span> <span class="keyword">extends</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RevealDrawable</span><span class="params">(Drawable unselected, Drawable selected, <span class="keyword">int</span> orientation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mUnselectedDrawable = unselected;</span><br><span class="line">    mSelectedDrawable = selected;</span><br><span class="line">    mOrientation = orientation;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要设定能够与图片选择过程中相关联的值。幸运的是Drawable内置了这种类型的事件，setLevel(int).</p>
<p>一个Drawable的level是介于0和10000的整数，它只是允许Drawable基于一个值去自定义它的view.在我们的例子中，我们可以定义5000作为图片被选择时的状态值，其他没被选中状态值在5000左右两侧。<br>All we need to do now is to override the draw(Canvas canvas) method to draw the appropriate drawable by clipping the canvas based on the current level.<br>现在我们要做的就是重写draw(Canvas canvas)方法，通过基于当前的level裁剪画布去绘制相应的图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If level == 10000 || level == 0, just draw the unselected image</span></span><br><span class="line">  <span class="keyword">int</span> level = getLevel();</span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">10000</span> || level == <span class="number">0</span>) &#123;</span><br><span class="line">    mRevealState.mUnselectedDrawable.draw(canvas);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If level == 5000 just draw the selected image</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (level == <span class="number">5000</span>) &#123;</span><br><span class="line">    mRevealState.mSelectedDrawable.draw(canvas);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Else, draw the transitional version</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Rect r = mTmpRect;</span><br><span class="line">    <span class="keyword">final</span> Rect bounds = getBounds();</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Draw the unselected portion</span></span><br><span class="line">      <span class="keyword">float</span> value = (level / <span class="number">5000f</span>) - <span class="number">1f</span>;</span><br><span class="line">      <span class="keyword">int</span> w = bounds.width();</span><br><span class="line">      <span class="keyword">if</span> ((mRevealState.mOrientation &amp; HORIZONTAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        w = (<span class="keyword">int</span>) (w * Math.abs(value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> h = bounds.height();</span><br><span class="line">      <span class="keyword">if</span> ((mRevealState.mOrientation &amp; VERTICAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        h = (<span class="keyword">int</span>) (h * Math.abs(value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> gravity = value &lt; <span class="number">0</span> ? Gravity.LEFT : Gravity.RIGHT;</span><br><span class="line">      Gravity.apply(gravity, w, h, bounds, r);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> &amp;&amp; h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.clipRect(r);</span><br><span class="line">        mRevealState.mUnselectedDrawable.draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Draw the selected portion</span></span><br><span class="line">      <span class="keyword">float</span> value = (level / <span class="number">5000f</span>) - <span class="number">1f</span>;</span><br><span class="line">      <span class="keyword">int</span> w = bounds.width();</span><br><span class="line">      <span class="keyword">if</span> ((mRevealState.mOrientation &amp; HORIZONTAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        w -= (<span class="keyword">int</span>) (w * Math.abs(value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> h = bounds.height();</span><br><span class="line">      <span class="keyword">if</span> ((mRevealState.mOrientation &amp; VERTICAL) != <span class="number">0</span>) &#123;</span><br><span class="line">        h -= (<span class="keyword">int</span>) (h * Math.abs(value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> gravity = value &lt; <span class="number">0</span> ? Gravity.RIGHT : Gravity.LEFT;</span><br><span class="line">      Gravity.apply(gravity, w, h, bounds, r);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w &gt; <span class="number">0</span> &amp;&amp; h &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        canvas.clipRect(r);</span><br><span class="line">        mRevealState.mSelectedDrawable.draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，我们可基于滑动的位置以简单地设置icon的level,结束了~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> offset = getOffestForPosition(recyclerView, position);</span><br><span class="line"><span class="keyword">if</span> (Math.abs(offset) &lt;= <span class="number">1f</span>) &#123;</span><br><span class="line">  holder.image.setImageLevel((<span class="keyword">int</span>) (offset * <span class="number">5000</span>) + <span class="number">5000</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  holder.image.setImageLevel(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要看自定义Drawable源码，请在Github上搜索Gist<a href="https://gist.github.com/rharter/34051da57f8a6a0991ff" target="_blank" rel="external">here</a></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.ryanharter.com/blog/2015/04/03/custom-drawables/" target="_blank" rel="external">Custom Drawables</a></li>
<li>原文作者 : <a href="http://www.ryanharter.com/" target="_blank" rel="external">Ryan Harter</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/SwinZh" target="_blank" rel="external">SwinZh</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们都看过关于为什么你应该适当的使<a href="http://www.ryanharter.com/blog/2014/05/14/using-custom-compound-views-in-android/">自定义Views</a>和如何能帮助你正确的封装你的应用程序代码的帖子。但非视图相关的部分如何转化为我们apps的其他部分的这种思考方式，我们对此并不非常了解。<br>]]>
    
    </summary>
    
      <category term="Drawables" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Drawables/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开始使用 Transitions（过渡动画） (part 1)]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/code-coverage-reports-using-robolectric/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/code-coverage-reports-using-robolectric/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:05:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用_Robolectric_和_Android_生成代码覆盖率（测试）报告">使用 Robolectric 和 Android 生成代码覆盖率（测试）报告</h2><h1 id="介绍">介绍</h1><p>我写过许多测试驱动开发与陷阱方面的文章。我认为，其中对测试驱动开发中遇到的陷阱的描述让整个介绍更加完整。测试驱动开发或者通常的测试中，最重要的是你清楚代码中哪些部分经过了测试，而哪些部分需要继续测试。<br><a id="more"></a><br>你可以使用<a href="http://www.eclemma.org/jacoco/" target="_blank" rel="external">JaCoCo</a>搞定上述的问题，它对Grandle和Robolectric有较好的集成。</p>
<h1 id="配置build-gradle">配置build.gradle</h1><p>第一步，配置build.gradle。主要代码如下所示。完整代码见<a href="https://github.com/kvandermast/my-robolectric-app" target="_blank" rel="external">GitHub</a>。</p>
<p><em>build.gradle</em></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            runProguard <span class="keyword">false</span></span><br><span class="line">            proguardFile <span class="string">'proguard-rules.txt'</span></span><br><span class="line">            debuggable <span class="keyword">true</span></span><br><span class="line">            testCoverageEnabled = <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'jacoco'</span></span><br><span class="line"></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = <span class="string">"0.7.1.201405082137"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> coverageSourceDirs = [</span><br><span class="line">        <span class="string">'../app/src/main/java'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> jacocoTestReport(type:JacocoReport, dependsOn: <span class="string">"testDebug"</span>) &#123;</span><br><span class="line">    <span class="keyword">group</span> = <span class="string">"Reporting"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">description</span> = <span class="string">"Generate Jacoco coverage reports"</span></span><br><span class="line"></span><br><span class="line">    classDirectories = <span class="keyword">fileTree</span>(</span><br><span class="line">            dir: <span class="string">'../app/build/intermediates/classes/debug'</span>,</span><br><span class="line">            excludes: [<span class="string">'**/R.class'</span>,</span><br><span class="line">                       <span class="string">'**/R$*.class'</span>,</span><br><span class="line">                       <span class="string">'**/*$ViewInjector*.*'</span>,</span><br><span class="line">                       <span class="string">'**/BuildConfig.*'</span>,</span><br><span class="line">                       <span class="string">'**/Manifest*.*'</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    additionalSourceDirs = files(coverageSourceDirs)</span><br><span class="line">    sourceDirectories = files(coverageSourceDirs)</span><br><span class="line">    executionData = files(<span class="string">'../app/build/jacoco/testDebug.exec'</span>)</span><br><span class="line"></span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = <span class="keyword">true</span></span><br><span class="line">        html.enabled = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（现在）我们来看看其中最重要的配置。</p>
<ul>
<li>buildType 声明，开启代码覆盖测试。</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            runProguard <span class="literal">false</span></span><br><span class="line">            proguardFile <span class="string">'proguard-rules.txt'</span></span><br><span class="line">            debuggable <span class="literal">true</span></span><br><span class="line">            testCoverageEnabled <span class="subst">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加入一个 JaCoCo 插件，同时，指定使用最新版 : </li>
</ul>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="symbol">plugin:</span> <span class="string">'jacoco'</span></span><br><span class="line"></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = <span class="string">"0.7.1.201405082137"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coverageSourceDirs</span></span> = [</span><br><span class="line">        <span class="string">'../app/src/main/java'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>配置 converageSourceDirs，指定一个文件夹，JaCoCo 将对文件夹中的目标进行反射。</p>
</li>
<li><p>配置 JaCoCo 插件，指定你需要测试的类（它们已经经过编译）和不需要测试的类（比如 ButterKnife 注入的 <em>ViewInjector</em>）。</p>
</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">task jacocoTestReport(type:JacocoReport, dependsOn: <span class="string">"testDebug"</span>) &#123;</span><br><span class="line">    group = <span class="string">"Reporting"</span></span><br><span class="line"></span><br><span class="line">    description = <span class="string">"Generate Jacoco coverage reports"</span></span><br><span class="line"></span><br><span class="line">    classDirectories = fileTree(</span><br><span class="line">            dir: '../app/build/intermediates/classes/debug',</span><br><span class="line">            excludes: ['<span class="keyword">*</span><span class="keyword">*</span>/R.class',</span><br><span class="line">                       '<span class="keyword">*</span><span class="keyword">*</span>/R$<span class="keyword">*</span>.class',</span><br><span class="line">                       '<span class="keyword">*</span><span class="keyword">*</span>/<span class="keyword">*</span>$ViewInjector<span class="keyword">*</span>.<span class="keyword">*</span>',</span><br><span class="line">                       '<span class="keyword">*</span><span class="keyword">*</span>/BuildConfig.<span class="keyword">*</span>',</span><br><span class="line">                       '<span class="keyword">*</span><span class="keyword">*</span>/Manifest<span class="keyword">*</span>.<span class="keyword">*</span>']</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    additionalSourceDirs = files(coverageSourceDirs)</span><br><span class="line">    sourceDirectories = files(coverageSourceDirs)</span><br><span class="line">    executionData = files('../app/build/jacoco/testDebug.exec')</span><br><span class="line"></span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = true</span><br><span class="line">        html.enabled = true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="执行_gradle_任务">执行 gradle 任务</h1><p>修改 gradle.build 文件后，你必须执行与开发环境同步，以检查加入新插件后 gradle 也工作正常。</p>
<p>在使用 JaCoCo 生成测试报告前，还需要提供 testDebug.exec 文件。（提供文件）最简单的方法是打开命令行，对你的项目上执行如下命令 ：<br><code>$ ./gradlew clean assemble</code></p>
<p>这条命令会清空之前编译生成的class文件，并重新构建。</p>
<p>现在，你就可以使用 JaCoCo 生成测试报告啦，只要执行这条命令：<br><code>$ ./gradlew jacocoTestReport</code></p>
<p>（你会看到）终端将开始执行 grable 构建脚本，其中，最后一项任务是使用 JaCoCo 生成测试报告：</p>
<p>&gt;<br>`$ ./gradlew jacocoTestReport<br>:app:preBuild<br>:app:preDebugBuild<br>:app:checkDebugManifest<br>:app:preReleaseBuild<br>:app:prepareComAndroidSupportSupportV42000Library UP-TO-DATE<br>:app:prepareDeKeyboardsurferAndroidWidgetCrouton184Library UP-TO-DATE<br>:app:prepareDebugDependencies<br>:app:compileDebugAidl UP-TO-DATE<br>:app:compileDebugRenderscript UP-TO-DATE<br>:app:generateDebugBuildConfig UP-TO-DATE<br>:app:generateDebugAssets UP-TO-DATE<br>:app:mergeDebugAssets UP-TO-DATE<br>:app:generateDebugResValues UP-TO-DATE<br>:app:generateDebugResources UP-TO-DATE<br>:app:mergeDebugResources UP-TO-DATE<br>:app:processDebugManifest UP-TO-DATE<br>:app:processDebugResources UP-TO-DATE<br>:app:generateDebugSources UP-TO-DATE<br>:app:compileDebugJava UP-TO-DATE<br>:app:compileTestDebugJava<br>:app:processTestDebugResources UP-TO-DATE<br>:app:testDebugClasses<br>:app:testDebug<br>:app:jacocoTestReport                                                           </p>
<p>BUILD SUCCESSFUL</p>
<p>Total time: 29.482 secs</p>
<p>生成的代码覆盖率测试报告保存在 ./build/reports/jacoco/jacocoTestReport 中，结果类似下图：<br><img src="http://img.blog.csdn.net/20150421201014450" alt="p">    </p>
<h1 id="注意事项">注意事项</h1><ul>
<li>你的<strong>应用名</strong></li>
</ul>
<p>在我的例子中，Android module名是”app”。因此包含 <code>&#39;../app/src/main/java&#39;</code> 中的代码。如果你的Android module 名和例子中的不同，就请修改gradle文件中路径（所有涉及到 Android module 相关的路径）。比如，如果你的Android module名是FooBar，配置文件中就应修改为 <code>&quot;..app/src/main/java&quot;</code>。</p>
<ul>
<li><strong>产品类別</strong></li>
</ul>
<p>例子中没用指明产品类别，所以构建任务使用<code>&quot;testDebug&quot;</code>和<code>&quot;../app/build/intermediates/classes/debug&quot;</code>中的class文件。但是，如果你在应用中指定产品类别（比如. Local），Gradle就找不到”testDebug”任务。所以，需要正确的命名，比如，这里你可以用 testLocalDebug 并包含正确的class文件：<code>&#39;../app/build/intermediated/classes/debug&#39;</code>。</p>
<p>如果你有任何问题，别犹豫，直接来问我。代码在 <a href="https://github.com/kvandermast/my-robolectric-app" target="_blank" rel="external">Github</a> 上已经更新，请 Check Out。</p>
<p>术语：    </p>
<ol>
<li>code coverage 代码覆盖率：软件测试中用来表示被测软件中被测试代码占整个软件的比例或程度。  </li>
</ol>
<blockquote>
<ul>
<li>原文链接 : <a href="http://raptordigital.blogspot.com/2014/08/code-coverage-reports-using-robolectric.html" target="_blank" rel="external">Code coverage reports using Robolectric and Android</a></li>
<li>原文作者 : <a href="http://raptordigital.blogspot.com/" target="_blank" rel="external">Kris Vandermast</a></li>
<li>译文出自 :  <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/normalme" target="_blank" rel="external">normalme</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 : 校对中 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用_Robolectric_和_Android_生成代码覆盖率（测试）报告">使用 Robolectric 和 Android 生成代码覆盖率（测试）报告</h2><h1 id="介绍">介绍</h1><p>我写过许多测试驱动开发与陷阱方面的文章。我认为，其中对测试驱动开发中遇到的陷阱的描述让整个介绍更加完整。测试驱动开发或者通常的测试中，最重要的是你清楚代码中哪些部分经过了测试，而哪些部分需要继续测试。<br>]]>
    
    </summary>
    
      <category term="动画" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Support库 22.1]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-support-library-221/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/01/android-support-library-221/</id>
    <published>2015-04-30T16:00:00.000Z</published>
    <updated>2015-06-29T14:10:15.000Z</updated>
    <content type="html"><![CDATA[<p>你可能听过这么一句话 “最好的代码就是没有代码。” 然而我想对你说的是：你写下的每一行代码应该能为应用增加独特的价值，而不是为应用添加一行又一行繁复、无趣的模板代码。Android提供支持库的初衷正是如此：让 Android 开发工程师把精力更多地放在逻辑实现上，而不是写业务代码。<br><a id="more"></a><br>最新发布的Android支持库一如既往地添加了许多实用的组件，并对Support V4、AppCompat、Leanback、RecyclerView、Palette和Renderscript库的内部实现逻辑作出改变。从新的 <a href="http://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppCompatActivity</a>和<a href="http://developer.android.com/reference/android/support/v7/app/AppCompatDialog.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppCompatDialog</a> 到Android TV全新的引导流程我们可以发现，新的库确实带来许多让我们耳目一新的惊喜。</p>
<h2 id="Support_V4">Support V4</h2><p>Support V4 库作为众多 Android 支持库的基础，包含许多向下兼容的类，大大简化了向下兼容的具体实现。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/graphics/drawable/DrawableCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">DrawableCompat</a>现在使drawable着色绘制向下兼容到了API 4：现在只需要通过<a href="http://developer.android.com/reference/android/support/v4/graphics/drawable/DrawableCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#wrap(android.graphics.drawable.Drawable" target="_blank" rel="external">DrawableCompat.wrap(Drawable)</a>)简单封装你的Drawable，然后<a href="http://developer.android.com/reference/android/support/v4/graphics/drawable/DrawableCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#setTint(android.graphics.drawable.Drawable,%20int" target="_blank" rel="external">setTint()</a>)、<a href="http://developer.android.com/reference/android/support/v4/graphics/drawable/DrawableCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#setTintList(android.graphics.drawable.Drawable,%20android.content.res.ColorStateList" target="_blank" rel="external">setTintList()</a>)、<a href="http://developer.android.com/reference/android/support/v4/graphics/drawable/DrawableCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#setTintMode(android.graphics.drawable.Drawable,%20android.graphics.PorterDuff.Mode" target="_blank" rel="external">setTintMode()</a>)就能完成着色绘制：完全不需要为了支持多种颜色而去创建和维护几个不同的 Drawable 文件！</p>
<p>此外，我们正在通过 <a href="http://developer.android.com/reference/android/support/v4/graphics/ColorUtils.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">ColorUtils</a> 类做一些适用于所有使用场景的 <a href="https://developer.android.com/reference/android/support/v7/graphics/Palette.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Palette</a> 内部构件，ColorUtils 可以很容易地计算出颜色之间的对比度，确定维持最小对比度的最小透明度值（完美地保证文字的阅读体验），或者将颜色转换为对应的 HSL 值（译者注：Hue[hju]色调，Saturation[‘sætʃə’reʃən]饱和度，Luminance[‘lumɪnəns]亮度）。</p>
<p>插值器是所有动画系统的重要组成部分，它负责控制一个动画中某项数值改变的比率（例如加速、减速等）。Lollipop 中的<a href="http://developer.android.com/reference/android/R.interpolator.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">android.R.interpolator</a>已经内置了许多插值器，例如用于<a href="http://www.google.com/design/spec/animation/authentic-motion.html" target="_blank" rel="external">建立真实感的动效</a>的fast_out_linear_in、fast_out_slow_in、and linear_out_slow_in。但现在我们可以用代码调用 <a href="http://developer.android.com/reference/android/support/v4/view/animation/FastOutLinearInInterpolator.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">FastOutLinearInInterpolator</a>、<a href="http://developer.android.com/reference/android/support/v4/view/animation/FastOutSlowInInterpolator.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">FastOutSlowInInterpolator</a>、<a href="http://developer.android.com/reference/android/support/v4/view/animation/LinearOutSlowInInterpolator.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">LinearOutSlowInInterpolator</a> 类为动画添加这些插值器。除了那些预建的插值器，我们还创建了允许你创建二次方或三次方贝塞尔曲线的 <a href="http://developer.android.com/reference/android/support/v4/view/animation/PathInterpolatorCompat.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">PathInterpolatorCompat</a> 类。</p>
<p>这个版本的支持库还把<a href="http://developer.android.com/reference/android/support/v4/widget/Space.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Space</a>控件从GridLayout库移动到了Support V4，使其不需要在项目中添加单独的依赖。Space控件是一种轻量的、无形的控件，可用于创建控件间的间隙效果。</p>
<h2 id="AppCompat">AppCompat</h2><p>AppCompat支持库开始地很低调，却是一个很重要的开端：为API 7及以上的设备提供了一个一致的Action Bar。<br>在<a href="http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html" target="_blank" rel="external">版本21的修订中</a>，它承担了新的职责：带来了<a href="http://developer.android.com/training/material/theme.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#ColorPalette" target="_blank" rel="external">material color palette</a>、控件着色、Toolbar支持，还有更多支持所有API 7+的设备。单从ActionBarActivity名字上看是体现不出它全部功能的。</p>
<p>在此版本中，ActionBarActivity已经过时了，新的替代者是<a href="http://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppCompatActivity</a>。然而，这不只是一个重命名。事实上，AppCompat的内在逻辑现在可以通过<a href="http://developer.android.com/reference/android/support/v7/app/AppCompatDelegate.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppCompatDelegate</a>实现-这是一个可以在所有Activity中包含的类，与合适的生命周期方法挂钩，并得到一致的主题、着色等，而不需要使用AppCompatActivity （尽管这仍然是最简单的开始方式）。</p>
<p>在全新AppCompatDelegate类的帮助下，我们继续增加了一致性体验的支持，通过<a href="http://developer.android.com/reference/android/support/v7/app/AppCompatDialog.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppCompatDialog</a>类增加了材料设计规范对话框的支持。如果你之前使用过<a href="http://developer.android.com/guide/topics/ui/dialogs.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#AlertDialog" target="_blank" rel="external">AlertDialog </a>，你会很高心，因为现在支持库中也有其对应的版本：<a href="http://developer.android.com/reference/android/support/v7/app/AlertDialog.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">support.v7.app.AlertDialog</a>，让你用相同的API享受 AppCompatDialog 带来的便利。</p>
<p>在使用AppCompat时，自动为控件着色的能力是在你的应用程序中保持品牌烙印和一致性体验中的重要保证。因为在填充布局时AppCompat会自动地为你将诸如Button、TextView 这些传统控件替换为AppCompatButton、AppCompatTextView 等新控件，以确保布局内的每一个控件都能支持着色。而在新的支持库中，色彩感知控件现在已经被公开，让控件类对自动着色的支持能延续到子类中。</p>
<p>这个列表囊括了目前所有的色彩感知控件：</p>
<blockquote>
<ul>
<li>AppCompatAutoCompleteTextView</li>
<li>AppCompatButton</li>
<li>AppCompatCheckBox</li>
<li>AppCompatCheckedTextView</li>
<li>AppCompatEditText</li>
<li>AppCompatMultiAutoCompleteTextView</li>
<li>AppCompatRadioButton</li>
<li>AppCompatRatingBar</li>
<li>AppCompatSpinner</li>
<li>AppCompatTextView</li>
</ul>
</blockquote>
<p>Lollipop增加了在一个view中通过view级别上的XML属性android:theme实现重写主题的能力-非常有用的特性，如在亮色activities上的黑色action bars。现在，AppCompat允许你为Toolbars使用android:theme（不赞成使用之前的app:theme）,更好地带来为API 11+的所有views的android:theme支持。</p>
<p>如果你刚开始接触AppCompat，那么看看下面的视频，可以察觉出是多么容易上手，这就能为你所有的用户带来了一致性的设计：</p>
<p><a href="https://youtu.be/5Be2mJzP-Uw" target="_blank" rel="external"><img src="http://img.youtube.com/vi/5Be2mJzP-Uw/0.jpg" alt="Android Support Library: Consistent Design with AppCompat"></a></p>
<h2 id="Leanback">Leanback</h2><p>Leanback库作为Android电视应用程序的最佳实践的集合，我们曾忽略去不使一个更美好的10的经验作为发行版的一部分。你会注意到加载后立即更新Leanback例子新功能的引导步骤。<br><img src="http://4.bp.blogspot.com/-I4Bjzlx8AzI/VS1fgphZnYI/AAAAAAAABhs/L5SfjRk_k40/s640/image00.png" alt=""></p>
<p>这组类和主题可以用来构建一个多步骤的过程，这在Android TV上看起来很棒。它是由一个左边上的指导视图和右边的列表操作建立了起来。每一个都是可定制的，通过一些主题与Theme.Leanback.GuidedStep 的父类或其它，如果需要更多的定制，通过自定义一个<a href="http://developer.android.com/reference/android/support/v17/leanback/widget/GuidanceStylist.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">GuidanceStylist</a>和<a href="http://developer.android.com/reference/android/support/v17/leanback/widget/GuidedActionsStylist.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">GuidedActionsStylist。</a>。</p>
<p>你还会发现大量的bug修复，性能改进，以及使它更完美贯穿在库中-所有与制作Leanback的经验，更多就是为用户和开发人员所喜欢。</p>
<h2 id="RecyclerView">RecyclerView</h2><p>除了一系列正确的bug修复，此版本增加了一个新的<a href="http://developer.android.com/reference/android/support/v7/util/SortedList.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">SortedList</a>数据结构。此集合可以很容易地保持自定义对象的排序列表，通过<a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">RecyclerView.Adapter</a>正确地分发数据改变的事件：维护item的 添加/删除/移动/改变 时RecyclerView提供的动画。</p>
<p>此外，SortedList还支持成批地一起改变，调度只是适配器上一个单一的集操作，确保大量items改变时的最佳的用户体验。</p>
<h2 id="Palette">Palette</h2><p>如果你已经使用Palette从图像中提取出颜色，你会很高兴地知道，现在在不会丢失品质下速度是之前的6~8倍！</p>
<p>Palette现在使用建造者模式来实例化。不是直接调用Palette.generate(Bitmap)或者其它相似的操作，你会使用<a href="http://developer.android.com/reference/android/support/v7/graphics/Palette.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog#from(android.graphics.Bitmap" target="_blank" rel="external">Palette.from(Bitmap)</a>)来取回一个<a href="http://developer.android.com/reference/android/support/v7/graphics/Palette.Builder.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Palette.Builder</a>实例。然后，在调用generate()或者generateAsync()检索颜色的色板之前，您可以随意更改的最大颜色数来生成并设置图像的最大尺寸来重新运行Palette。</p>
<h2 id="Renderscript">Renderscript</h2><p>Renderscript给你巨大的计算潜力，此外这个支持库版本使得一些预先定义的脚本和调用脚本内部函数在API 8+的设备上变得可用。这个版本改善了所有设备的可靠性和性能，这些提升取决于本地Renderscript可用时通过一种改进的图像边缘检测算法实现-确保最快和最可靠的实现总是我们的选择。两个额外的内部函数也被添加在此版本中：<a href="http://developer.android.com/reference/android/support/v8/renderscript/ScriptIntrinsicHistogram.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">ScriptIntrinsicHistogram</a>和<a href="http://developer.android.com/reference/android/support/v8/renderscript/ScriptIntrinsicResize.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">ScriptIntrinsicResize</a>，完成采集到10。</p>
<h2 id="SDK_现在可用了！">SDK 现在可用了！</h2><p>没有比这更好的时间来开始使用Android支持库。今天你就可以使用这个库开始开发了，从Android SDK Manager下载Android支持库和Android支持资源吧。</p>
<p>要了解更多关于Android的支持库和它提供给你的API，请访问Android开发者官网上的<a href="http://developer.android.com/tools/support-library/index.html?utm_campaign=ASL221-415&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">支持库章节</a>的网页。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://android-developers.blogspot.com/2015/04/android-support-library-221.html" target="_blank" rel="external">Android Support Library 22.1</a></li>
<li>原文作者 : <a href="https://plus.google.com/+IanLake" target="_blank" rel="external">Ian Lake</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/zhengxiaopeng" target="_blank" rel="external">Rocko</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>你可能听过这么一句话 “最好的代码就是没有代码。” 然而我想对你说的是：你写下的每一行代码应该能为应用增加独特的价值，而不是为应用添加一行又一行繁复、无趣的模板代码。Android提供支持库的初衷正是如此：让 Android 开发工程师把精力更多地放在逻辑实现上，而不是写业务代码。<br>]]>
    
    </summary>
    
      <category term="AppCompat" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/AppCompat/"/>
    
      <category term="Support Library" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Support-Library/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FaceBook推出的Android图片加载库-Fresco]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/introducing-fresco-a-new-image-library-for-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/introducing-fresco-a-new-image-library-for-android/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:28:14.000Z</updated>
    <content type="html"><![CDATA[<p>在Android设备上面，快速高效的显示图片是极为重要的。过去的几年里，我们在如何高效的存储图像这方面遇到了很多问题。图片太大，但是手机的内存却很小。每一个像素的R、G、B和alpha通道总共要占用4byte的空间。如果手机的屏幕是480*800,那么一张屏幕大小的图片就要占用1.5M的内存。手机的内存通常很小，特别是Android设备还要给各个应用分配内存。在某些设备上，分给Facebook App的内存仅仅有16MB。一张图片就要占据其内存的十分之一。<br><a id="more"></a></p>
<p>当你的App内存溢出会发生什么呢？它当然会崩溃！我们开发了一个库来解决这个问题，我们叫它Fresco。它可以管理使用到的图片和内存，从此App不再崩溃。</p>
<h2 id="内存区">内存区</h2><p>为了理解Facebook到底做了什么工作，在此之前我们需要了解在Android可以使用的堆内存之间的区别。Android中每个App的Java堆内存大小都是被严格的限制的。每个对象都是使用Java的new在堆内存实例化，这是内存中相对安全的一块区域。内存有垃圾回收机制，所以当App不在使用内存的时候，系统就会自动把这块内存回收。</p>
<p>不幸的是，内存进行垃圾回收的过程正是问题所在。当内存进行垃圾回收时，内存不仅仅进行了垃圾回收，还把 Android 应用完全终止了。这也是用户在使用 App 时最常见的卡顿或短暂假死的原因之一。这会让正在使用 App 的用户非常郁闷，然后他们可能会焦躁地滑动屏幕或者点击按钮，但 App 唯一的响应就是：在 App 恢复正常之前，请求用户耐心等待</p>
<p>相比之下，Native堆是由C++程序的new进行分配的。在Native堆里面有更多可用内存，App只被设备的物理可用内存限制，而且没有垃圾回收机制或其他东西拖后腿。但是c++程序员必须自己回收所分配的每一块内存，否则就会造成内存泄露，最终导致程序崩溃。</p>
<p>Android有另外一种内存区域，叫做Ashmem。它操作起来更像Native堆，但是也有额外的系统调用。Android 在操作 Ashmem 堆时，会把该堆中存有数据的内存区域从 Ashmem 堆中抽取出来，而不是把它释放掉，这是一种弱内存释放模式；被抽取出来的这部分内存只有当系统真正需要更多的内存时（系统内存不够用）才会被释放。当 Android 把被抽取出来的这部分内存放回 Ashmem 堆，只要被抽取的内存空间没有被释放，之前的数据就会恢复到相应的位置。</p>
<h2 id="可消除的Bitmap">可消除的Bitmap</h2><p>Ashmem不能被Java应用直接处理，但是也有一些例外，图片就是其中之一。当你创建一张没有经过压缩的Bitmap的时候，Android的API允许你指定是否是可清除的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="keyword">Options</span> = <span class="keyword">new</span> BitmapFactory.<span class="keyword">Options</span>();</span><br><span class="line"><span class="keyword">options</span>.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line">Bitmap bitmap = BitmapFactory.decodeByteArray(jpeg, <span class="number">0</span>, jpeg.length, <span class="keyword">options</span>);</span><br></pre></td></tr></table></figure>
<p>经过上面的代码处理后，可清除的Bitmap会驻留在 Ashmem 堆中。不管发生什么，垃圾回收器都不会自动回收这些 Bitmap。当 Android 绘制系统在渲染这些图片，Android 的系统库就会把这些 Bitmap 从 Ashmem 堆中抽取出来，而当渲染结束后，这些 Bitmap 又会被放回到原来的位置。如果一个被抽取的图片需要再绘制一次，系统仅仅需要把它再解码一次，这个操作非常迅速。</p>
<p>这听起来像一个完美的解决方案，但是问题是Bitmap解码的操作是运行在UI线程的。Bitmap解码是非常消耗CPU资源的，当消耗过大时会引起UI阻塞。因为这个原因，所以Google不推荐使用这个<a href="http://developer.android.com/intl/zh-cn/reference/android/graphics/BitmapFactory.Options.html#inPurgeable" target="_blank" rel="external">特性</a>。现在它们推荐使用另外一个特性——inBitmap。但是这个特性直到Android3.0之后才被支持。即使是这样，这个特性也不是非常有用，除非 App 里的所有图片大小都相同，这对Fackbook来说显然是不适用的。一直到4.4版本，这个限制才被移除了。但我们需要的是能够运行在 Android 2.3 - 最新版本中的通用解决方案。</p>
<h2 id="自力更生">自力更生</h2><p>对于上面提到的“解码操作致使 UI 假死”的问题，我们找到了一种同时使 UI 显示和内存管理都表现良好的解决方法。如果我们在 UI 线程进行渲染之前把被抽取的内存区域放回到原来的位置，并确保它再也不会被抽取，那我们就可以把这些图片放在 Ashmem 里，同时不会出现 UI 假死的问题。幸运的是，Android 的 NDK 中有一个函数可以完美地实现这个需求，名字叫做 AndroidBitmap_lockPixels。这个函数最初的目的就是：在调用 unlockPixels 再次抽取内存区域后被执行。</p>
<p>当我们意识到我们没有必要这样做的时候，我们取得了突破。如果我们只调用lockPixels而不调用对应的unlockPixels，那么我们就可以在Java的堆内存里面创建一个内存安全的图像，并且不会导致UI线程加载缓慢。只需要几行c++代码，我们就完美的解决了这个问题。</p>
<h2 id="用C++的思想写Java代码">用C++的思想写Java代码</h2><p>就像《蜘蛛侠》里面说的：“能力越强，责任越大。”可清除的 Bitmap 既不会被垃圾回收器回收，也不会被 Ashmem 内置的清除机制处理，这使得使用它们可能会造成内存泄露。所以我们只能靠自己啦。</p>
<p>在c++中,通常的解决方案是建立智能指针类,实现引用计数。这些需要利用到c++的语言特性——拷贝构造函数、赋值操作符和确定的析构函数。这种语法在Java之中不存在，因为垃圾回收器能够处理这一切。所以我们必须以某种方式在Java中实现C++的这些保证机制。</p>
<p>我们创建了两个类去完成这件事。其中一个叫做“SharedReference”，它有addReference和deleteReference两个方法，调用者调用时必须采取基类对象或让它在范围之外。一旦引用计数器归零，资源处理(Bitmap.recycle)就会发生。</p>
<p>然而，很显然，让Java开发者去调用这些方法是很容易出错的。Java语言就是为了避免做这样的事情的！所以SharedReference之上,我们构建了CloseableReference类。它不仅实现了Java的Closeable接口,而且也实现了Cloneable接口。它的构造器和clone()方法会调用addReference()，而close()方法会调用deleteReference()。所以Java开发者需要遵守下面两条简单的的规则：</p>
<ol>
<li>在分配CloseableReference新对象的时候,调用.clone()。</li>
<li>在超出作用域范围的时候，调用.close()，这通常是在finally代码块中。</li>
</ol>
<p>这些规则可以有效地防止内存泄漏,并让我们在像Fackbook的Android客户端这种大型的Java程序中享受Native内存管理和通信。</p>
<h2 id="不仅仅是加载程序，它是一个管道">不仅仅是加载程序，它是一个管道</h2><p>在移动设备上显示图片需要很多的步骤：<br><img src="http://i2.tietuku.com/4480c88a0d8004bf.png" alt=""><br>几个优秀的开源库都是按照这个顺序执行的，比如 Picasso,Universal Image Loader,Glide和 Volley等等。上面这些开源库为Android的发展做出了非常重要的贡献。我们相信Fresco在几个重要方面会表现的更好。</p>
<p>我们的不同之处在于把上面的这些步骤看作是管道，而不仅仅是加载器。每一个步骤和其他方面应该是尽可能独立的，把数据和参数传递进去，然后产生一个输出，就这么简单。它应该可以做一些操作，不管是并行还是串行。一些操作只能在特性条件下才能执行。一些有特殊要求的在线程上执行。除此之外，当我们考虑改进图像的时候，所有的图片就会变得非常复杂。很多人在低网速情况下使用Facebook，我们想要这些人能够尽快的看到图片，甚至经常是在图片没有完全下载完之前。</p>
<h2 id="不要烦恼，拥抱stream">不要烦恼，拥抱stream</h2><p>在Java中，异步代码历来都是通过Future机制来执行的。在另外的线程里面代码被提交执行，然后一个类似Future的对象可以检查执行的结果是不是已经完成了。但是，这只在假设只有一种结果的情况下行得通。在处理渐进的图像的时候，我们希望可以完整而且连续的显示结果。</p>
<p>我们的解决方式是定义一个更广义的Future版本，叫做DataSource。它提供了一个订阅方法，调用者必须传入一个DataSubscriber和Executor。DataSubscriber可以从DataSource获取到处理中和处理完毕的结果，并且提供了很简单的方法来区分。因为我们需要非常频繁的处理这些对象，所以必须有一个明确的close调用，幸运的是，DataSource本身就是Closeable。</p>
<p>在后台，每一个箱子上面都实现了一个叫做“生产者/消费者”的新框架。在这个问题是，我们是从<a href="http://reactivex.io/" target="_blank" rel="external">ReactiveX</a>获取的灵感。我们的系统拥有和<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>相似的接口，但是更加适合移动设备，并且有内置的对Closeables的支持。</p>
<p>保持简单的接口。Producer只有一个叫做produceResults的方法，这个方法需要一个Consumer对象。反过来，Consumer有一个onNewResult方法。</p>
<p>我们使用像这样的系统把Producer联系起来。假设我们有一个producer的工作是把类型I转化为类型O，那么它看起来应该是这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputProducer</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">implements</span> <span class="title">Producer</span>&lt;<span class="title">O</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Producer&lt;I&gt; mInputProducer;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OutputProducer</span><span class="params">(Producer&lt;I&gt; inputProducer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mInputProducer = inputProducer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceResults</span><span class="params">(Consumer&lt;O&gt; outputConsumer, ProducerContext context)</span> </span>&#123;</span><br><span class="line">    Consumer&lt;I&gt; inputConsumer = <span class="keyword">new</span> InputConsumer(outputConsumer);</span><br><span class="line">    mInputProducer.produceResults(inputConsumer, context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InputConsumer</span> <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">I</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;O&gt; mOutputConsumer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputConsumer</span><span class="params">(Consumer&lt;O&gt; outputConsumer)</span> </span>&#123;</span><br><span class="line">      mOutputConsumer = outputConsumer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewResult</span><span class="params">(I newResult, <span class="keyword">boolean</span> isLast)</span> </span>&#123;</span><br><span class="line">      O output = doActualWork(newResult);</span><br><span class="line">      mOutputConsumer.onNewResult(output, isLast);      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以使我们把非常复杂的步骤串起来，同时也可以保持他们逻辑的独立性。</p>
<h2 id="动画全覆盖">动画全覆盖</h2><p>使用Facebook的人都非常喜欢Stickers，因为它可以以动画形式存储GIF和Web格式。如果支持这些格式，就需要面临新的挑战。因为每一个动画都是由不止一张图片组成的，你需要解码每一张图片，存储在内存里，然后显示出来。对于大一点的动画，把每一帧图片放在内存是不可行的。</p>
<p>我们建立了AnimatedDrawable,一个强大的可以呈现动画的Drawable,同时支持GIF和WebP格式。AnimatedDrawable实现标准的Android Animatable接口,所以调用者可以随意的启动或者停止动画。为了优化内存使用，如果图片足够小的时候，我们就在内存里面缓存这些图片，但是如果太大，我们可以迅速的解码这些图片。这些行为调用者是完全可控的。</p>
<p>所有的后台都用c++代码实现。我们保持一份解码数据和元数据解析,如宽度和高度。我们引用技术数据，它允许多个Java端的Drawables同时访问一个WebP图像。</p>
<h2 id="如何去爱你？我来告诉你…">如何去爱你？我来告诉你…</h2><p>当一张图片从网络上下载下来之后，我们想显示一张占位图。如果下载失败了，我们就会显示一个错误标志。当图片加载完之后，我们有一个渐变动画。通过使用硬件加速，我们可以按比例放缩，或者是矩阵变换成我们想要的大小然后渲染。我们不总是按照图片的中心进行放缩，那么我们可以自己定义放缩的聚焦点。有些时候，我们想显示圆角甚至是圆形的图片。所有的这些操作都应该是迅速而平滑的。</p>
<p>我们之前的实现是使用Android的View对象——时机到了，可以使用ImageView替换出占位的View。这个操作是非常慢的。改变View会让Android强制刷新整个布局，当用户滑动的时候，这绝对不是你想看到的效果。比较明智的做法是使用Android的Drawables,它可以迅速的被替换。</p>
<p>所以我们创建了Drawee。这是一个像MVC架构的图片显示框架。该模型被称为DraweeHierarchy。它被实现为Drawables的一个层，对于底层的图像而言，每一个曾都有特定的功能——成像、层叠、渐变或者是放缩。</p>
<p>DraweeControllers通过管道的方式连接到图像上——或者是其他的图片加载库——并且处理后台的图片操作。他们从管道接收事件并决定如何处理他们。他们控制DraweeHierarchy实际上的操作——无论是占位图片,错误条件或是完成的图片。</p>
<p>DraweeViews 的功能不多,但都是至关重要的。他们监听Android的View不再显示在屏幕上的系统事件。当图片离开屏幕的时候,DraweeView可以告诉DraweeController关闭使用的图像资源。这可以避免内存泄露。此外,如果它已经不在屏幕范围内的话，控制器会告诉图片管道取消网络请求。因此，像Fackbook那样滚动一长串的图片的时候，不会频繁的网络请求。</p>
<p>通过这些努力，显示图片的辛苦操作一去不复返了。调用代码只需要实例化一个DraweeView,然后指定一个URI和其他可选的参数就可以了。剩下的一切都会自动完成。开发人员不需要担心管理图像内存，或更新图像流。Fresco为他们把一切都做了。</p>
<h2 id="Fresco">Fresco</h2><p>完成这个图像显示和操作复杂的工具库之后,我们想要把它分享到Android开发者社区。我们很高兴的宣布，从今天起，这个项目已经作为<a href="http://github.com/facebook/fresco" target="_blank" rel="external">开源代码</a>了！</p>
<p>壁画是绘画技术,几个世纪以来一直受到世界各地人们的欢迎。我们许多伟大的艺术家使用这种名字,从意大利文艺复兴时期的大师拉斐尔到壁画艺术家斯里兰卡。我们并不是假装达到这个伟大的水平，我们真的希望Android开发者能像我们当初享受创建这个开源库的过程一样，非常享受的使用它。</p>
<h2 id="更多">更多</h2><p><a href="http://fresco-cn.org/" target="_blank" rel="external">Fresco中文文档</a></p>
<blockquote>
<ul>
<li>原文链接:<a href="https://code.facebook.com/posts/366199913563917/introducing-fresco-a-new-image-library-for-android/" target="_blank" rel="external">Introducing Fresco: A new image library for Android</a></li>
<li>作者 :  <a href="https://www.facebook.com/tyrone.nicholas" target="_blank" rel="external">tyrone Nicholas </a></li>
<li>译者 :  <a href="https://github.com/ZhaoKaiQiang" target="_blank" rel="external">ZhaoKaiQiang</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">Chaossss</a></li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">bboyfeiyu</a></li>
<li>校对者: <a href="https://github.com/BillionWang" target="_blank" rel="external">BillionWang</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android设备上面，快速高效的显示图片是极为重要的。过去的几年里，我们在如何高效的存储图像这方面遇到了很多问题。图片太大，但是手机的内存却很小。每一个像素的R、G、B和alpha通道总共要占用4byte的空间。如果手机的屏幕是480*800,那么一张屏幕大小的图片就要占用1.5M的内存。手机的内存通常很小，特别是Android设备还要给各个应用分配内存。在某些设备上，分给Facebook App的内存仅仅有16MB。一张图片就要占据其内存的十分之一。<br>]]>
    
    </summary>
    
      <category term="图片缓存" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Square开源库Flow和Mortar介绍]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/an-investigation-into-flow-and-mortar/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/an-investigation-into-flow-and-mortar/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:40:49.000Z</updated>
    <content type="html"><![CDATA[<p>“在 App 开发过程中尽可能使用 Fragment 替代 Activity”，Google 官方的这个建议无疑让万千 Android 开发者开始关注、使用 Fragment。但随着使用 Fragment 的人数增多，Fragment 存在的各种问题也开始暴露，在各种 Android 社区中，已经开始有人质疑用 Fragment 替代 Activity 在应用开发中是否真的像 Google 说的那样有益。质疑 Fragment 的理由大体如下：<br><a id="more"></a></p>
<ul>
<li><p>在使用 Fragment 时，我们只能选择使用默认的构造方法，而不能自由地构造我们想要的构造方法。</p>
</li>
<li><p>嵌套使用 Fragment 很容易出现各种奇奇怪怪的 Bug，抑或是受到种种让人郁闷的限制。</p>
</li>
<li><p>Fragment 自身的生命周期非常复杂。</p>
</li>
</ul>
<p>更让人哭笑不得的是，让这部分开发者坚定地站在“反 Fragment”队伍中的原因竟然是：在开发过程中使用 Fragment 完全不能让这部分 Android 开发者感受到使用 Fragment 能给他们带来的便利和愉悦；相反，使用 Fragment 给他们带来的是无尽的困然和烦恼。真不知道 Google 看到这些批评 Fragment 的帖子会想什么…………</p>
<p>但在我们的 Android 学习社区 <a href="http://www.bignerdranch.com/" target="_blank" rel="external">Big Nerd Ranch</a> 中，我们制作的 <a href="https://training.bignerdranch.com/classes/android-bootcamp" target="_blank" rel="external">Android bootcamp</a> 课程一直坚持使用 Fragment ，并且为大家介绍 Fragment 给我们带来的种种便利和好处（特别是 Android 开发的新手），此外，我们还在我们做的 <a href="http://www.bignerdranch.com/we-develop" target="_blank" rel="external">资讯项目</a> 中广泛地使用了 Fragment。</p>
<p>然而，虽然我们是 Fragment 的忠实粉丝，但本着不断学习和探索新知识的心态，我们还是对现有的 Android 库进行了相当多的研究和探索，以求能够找到 Fragment 的最佳替代物，帮助这些备受煎熬的 Android 开发者早日脱离苦海，走向 Android 开发的美丽新世界。</p>
<h2 id="进入Flow和Mortar">进入Flow和Mortar</h2><p>奉行着想毁灭世界上所有 Fragment 的信条，Square 大概在一年前介绍了两个全新的库： Flow 和 Mortar。作为反 Fragment 教主，Square 还创造了许多很好的库：</p>
<ul>
<li><a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a></li>
<li><a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a></li>
<li><a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a></li>
<li><a href="http://square.github.io/otto/" target="_blank" rel="external">Otto</a></li>
<li>And so many <a href="https://github.com/square" target="_blank" rel="external">more</a></li>
</ul>
<p>我只想说，我相信他们，我认为任何来自Square的资源可能是有用的或者至少是有趣的，所以他们的项目都值得一看。</p>
<p>在我们深入了解这些库之前我想提醒大家的是，Square只在他们内部的一小部分项目中使用这些库，并且我在写本文章时这些库还在预发布阶段。也就是说，这两个库在最近几个月取得了积极的进展，这预示着一个值得尊敬的未来，虽然库就像流沙，随时可能改变，崩溃甚至停止发布，但库所依赖的核心架构原则是一成不变的。</p>
<h2 id="体系架构">体系架构</h2><p> 首先，我们先来看下 Android 应用的体系架构，在 Android  Honeycomb 被使用之前，甚至在Fragment 出现之前，开发 Android 应用的标准模式是创建许多 Activity。在那个时候最常见的现象是：大多数开发者都没有规范地遵循 MVC模式进行开发，不过这也很正常。因为模型(Model)依赖于数据，传统的一些数据库或者是以 JSON 的形式存储的 Web 请求，抑或是各种各样的java对象枚举。开发者们很高兴地通过 XML 布局去为 Activity 设置 View ，而且 View 的控制器就是每一个屏幕显示的 Actvitiy 自身。</p>
<p>虽然这只是一个简要的概述，但是你能从中了解到 Android 与 MVC 模式是如何自然契合的。<br><img src="http://www.bignerdranch.com/img/blog/2015/02/mvc-pre.png" alt="mvc-pre"></p>
<p>随着 Fragment 在 Honeycomb 中的出现，Android 团队也让处理不同形式的事件变得更简单。到了今天，标准的 Android 应用架构已经转变为由一小部分的 Activity 和 许多 Fragment 构成，使得我们的 App 能够在 手机、平板、智能手表甚至是太空船上跨平台使用。<br><img src="http://www.bignerdranch.com/img/blog/2015/02/mvc-post.png" alt="mvc-post"></p>
<p>在这样的愿景下，有关 Fragment 的一切都是美好的，Fragment 变得流行起来，将一个 Activity 分解为几个 Fragment 是被提倡的。除此以外，即使 Activity 常常被简化为 Fragment 的持有者，或者是 Fragment 和 系统之间的接口，Android 应用的架构仍然遵循着 MVC 模式。</p>
<p>但到底是 Activity 不能实现我们 App 跨平台使用的愿望，还是我们没有用正确的方式使用 Activity呢？也许，如果将 Activity 与 自定义 View结合在一起使用，说不定不需要 Fragment 就能让 Activity 实现跨平台使用的目标呢。使用 Flow 和 Mortar库背后的关键目的就是探索这个问题，并得到确切的答案。Flow 和 Mortar 的工作通过用自定义 View 代替 Fragment，并使用注入自定义 View 中的特定 Controller 对象，控制视图，以此允许我们通过 View 来代替 Fragment 完成工作。<br><img src="http://www.bignerdranch.com/img/blog/2015/02/mvc-no-fragments.png" alt="mvc-no-fragments"></p>
<p>我们将在我们的讨论中构建这个图的中间部分，弄清楚如何在不使用 Fragment 的情况下把不同的视图碎片拼凑到一个 Activity 里。我们会看着标准MVC架构演变成完全不同的东西，这将大量涉及到咱们的Flow和Mortar。</p>
<p>那么，Flow和Mortar到底是什么？它们又是如何起作用的呢？</p>
<h2 id="Flow">Flow</h2><p>Flow 将一个应用分成一个逻辑上的 Screen组合，Screen不是任何形式的特殊的库对象，而是一个被创造来代表我们应用视图的普通java对象（POJO）。每一个Screen是这个app里面自包含的段，他们有自己的功能和意图。一个Screen的用处和传统Activity的用处没有什么不同，应用程序中的每一个Screen都对应于一个特定的位置，有点像一个Android中的URL网页或者是特定的隐式Intent。所以，Screen类可以被看作是应用中某个部分自带的可读定义。</p>
<p>我们应用中的每一个Activity将会成为一个 Flow 对象，Flow对象在返回栈中保存了 Screen 的记录，和 Activity 或者 FragmentManager 的返回栈有些类似，通过这样的设计允许我们在 Screen 之间通过简单地实例化就可以轻松的切换，而不需要在应用中包含很多Activity。这里有一小部分 Activity（最好是一个）来持有这些 Screen。他们之间的关系下图类似：<br><img src="http://www.bignerdranch.com/img/blog/2015/02/screen.png" alt="screen"></p>
<p>如果我们想切换到一个新的 Screen，我们只需简单地实例化这个 Screen，并且告诉我们 Flow 对象帮助我们切换为这个 Screen。除此以外，正如我们所期待的，Flow 被实例化后也会实现 goBack() 和 goUp() 方法。然而，许多开发者都把 Java 中的 goto 语句看作洪水猛兽，但事实上 Java 中的 goto 语句并没有它听起来那么恐怖。<br><img src="http://www.bignerdranch.com/img/blog/2015/02/flow.png" alt="flow"></p>
<p>从本质上看，Flow 的作用仅仅是在 App 中告诉我们将要切换到哪一个 Screen。而这样设计的好处在于，Flow 通过这样的设计让我们能够方便地在我们定义的各种不同的自定义 View 中切换，并使我们免受在 Activity 或 Fragment 需要考虑的种种麻烦，让我们把注意力都集中在处理 View上。Flow 为我们创造了一个简单，方便，以 View 为中心的应用架构。</p>
<h2 id="Mortar">Mortar</h2><p>Mortar是一个专注拖拽和依赖注入的库，Mortar 用以下几个不同的部分将一个应用分为可组合的模块：Blueprints, Presenters and a boatload of custom Views。</p>
<p>Mortar App里的每一个部分（在这里指的是每一个 Screen，因为我们在使用 Flow）都由 Blueprint 定义，并赋予他们一个私有的 Dagger 模块。它看起来有点像是下面这样的</p>
<p><img src="http://www.bignerdranch.com/img/blog/2015/02/blueprint.png" alt="blueprint"></p>
<p>Flow 和 Mortar 结合在一起使用的效果很好，我们只需要调节我们的 Screen 类实现去 Mortar 提供的 Blueprint 接口，然后它就会给我们一个可以自由使用的 Dagger 作用域。</p>
<p><img src="http://www.bignerdranch.com/img/blog/2015/02/presenters.png" alt="presenters"></p>
<p>Presenter 是一个拥有简单生命周期和伴随其生命周期的 Bundle 的 View 私有对象，主要被用作该 View 的控制器。每一个 View 都有存在于对应的 Screen （还有 Blueprint）中，与 View 自身相关联的 Presenter。因为 Presenter 只能作用于他所在的 Screen，所以当我们使用 Flow 进入一个新的 Screen，Presenter（在我们这个架构中非常重要的一环） 很可能会被 Java 的垃圾回收机制自动回收掉。此外，在 Mortar 作用域中的 Dagger 将与自动垃圾回收机制结合在一起，使得我们 App 能更好的管理、使用其内存——其中原因当然是：当前没有被使用的控制器对象都被我们回收掉了。而在传统的 Activity 开发中，Fragment 和 Activity 的切换过程中，不经意的垃圾回收并不能很好的被注意和提防。</p>
<p>由于自定义 View 在我们的架构中被频繁地使用，以至于我们只需要通过 Dagger 简单地注入所有重要的模型数据，然后使用与 View 关联的 Presenter 去控制 View 本身。即使配置被改变，Presenters 也不会消失，而且我们还非常了解与 Activity 生命周期相关的知识，使得 Presenters 在进程被杀死之后还能被恢复。事实上，Presenter 与 Activity onSavedInstanceState() 方法的 bundle 钩连在一起，使得它能够用与 Activity 相同的机制储存和读取配置改变后产生的数据。而 Presenter 的生命周期非常简单，只有四个回调方法：</p>
<ul>
<li>onEnterScope(MortarScope scope)</li>
<li>onLoad(Bundle savedInstanceState)</li>
<li>onSave(Bundle outState)</li>
<li>onExitScope()</li>
</ul>
<p>完全没有 Fragment 那样复杂的生命周期，这可不是我吹的！</p>
<p>文章写到这里，你会发现在 Flow 和 Mortar 中有许多发生改变的部分，新的术语和类，还有新的使用规范，这难免会让人一头雾水。所以为了方便大家的理解，总的来说，我们需要重视的是下面几个部分：</p>
<ul>
<li>Screen: 在应用导航层次结构中的一个特殊存在，用来代表我们视图的对象</li>
<li>Blueprint: 应用中具有私有的 Dagger 模块的部分</li>
<li>Presenter: 一个 View 控制器对象</li>
<li>Custom Views: 通过 Java 代码定义的 View，当然，用 XML 定义也是很常见的</li>
</ul>
<p>Here’s what our final Mortar and Flow architecture looks like:</p>
<p>我们 Mortar 和 Flow 整个体系架构将会如下所示：</p>
<p><img src="https://www.bignerdranch.com/img/blog/2015/02/mortar-and-flow.png" alt=""></p>
<p>抛弃了对 MVC 模式的执念，这个架构在完成之后变得更像 MVP 模式。这样巨大的转变使得新的架构需要关注如何处理应用在运行时配置信息改变的问题，例如：旋转。在 MVC 模式中，我们的控制器（Activity 和 Fragment）会随着我们的 View 一起被杀死。然而，在 MVP 模式中，我们只有 View<br>被杀死，又在需要它的时候重现它。挺有趣的对吧？</p>
<p><img src="https://www.bignerdranch.com/img/blog/2015/02/mvp.png" alt=""></p>
<h2 id="积极的反馈">积极的反馈</h2><p>为了摆脱 Fragment，Square 付出了无数的汗水去进行重新架构和设计，并完成了 Mortar 和 Flow库，他们当然会获得相应的回报，接下来我就给大家介绍这两个库给我们带来的好处吧。</p>
<p>使用 Mortar 和 Flow 库强迫我们创建了一个符合 MVP 模式设计的模块化 App 结构，通过这样做能有效地帮助我们保持代码的整洁。</p>
<p>通过对我们自定义 View 和 Presenters 的依赖注入，测试变得更简单了</p>
<p>动画能够在 View 层被处理，而不用像从前在 Activity 和 Fragment 中使用时那样担心动画会出现Bug</p>
<p>Mortar 在 View 和 Presenter 层中自动进行垃圾回收以处理其作用域，意味着应用能更有效地利用内存</p>
<h2 id="可优化的空间">可优化的空间</h2><p>尽管 Flow 和 Mortar 给我们带来了许多好处，但是它们也还存在一些问题：</p>
<p><strong>想要熟练使用 Flow 和 Mortar，需要面对一条陡峭的学习曲线。</strong>在你真正理解这两个库的设计思想和原理之前，它们的使用模式看起来非常复杂，如果你想要将他们用的得心应手，无疑需要大量的探索和实验，此外，这些库并不是为初学者提供的，我们更建议初学者先学习如何正确和有效地使用 Activity 和 Fragment，我可不是吓唬你们，这样跟你们说吧，就算是 Android 开发大神，在面对这些库时仍需要花费大量的精力和时间去学习有关设计模式的知识，才能真正理解这个库。</p>
<p><strong>如果你正准备使用 Mortar 和 Flow 库，你真的要全面了解它们的用法。</strong>因为让它和标准的“少使用 Fragment”开发模式相互作用是很困难的。如果你想修改一个已经写好的项目，让它使用 Mortar 和 Flow，虽然不是不可能的，但是完成这个目标的过程会是非常漫长和艰难的。</p>
<p><strong>这里还存在无数的模板和配置信息需要被处理。</strong>而这正是我最大的担忧，在使用这些新的类和接口时，我常常觉得被淹没在无趣的代码海洋里，因为这些代码都被设计成和其中的各个类、接口钩连在一起，而这也的设计让我觉得这两个库并没有像我期待的那样有趣。</p>
<h2 id="接下来呢">接下来呢</h2><p>不过现在 Mortar 和 Flow 库都处于预发布阶段，现在也没有官方发布的版本。这意味着 Square 还在处理这两个库存在的问题，改动和更新，但这同样也意味着它们还需要许多时间作改进，才能真正投入到使用中。</p>
<p>使用 Mortar 和 Flow 库是个有趣的体验，我非常享受使用各种新的库和寻找官方以 Fragment 为导向的应用结构的替代品，但我并不认为 Mortar 和 Flow 是 Android 寻找的替代 Fragment 的办法，毕竟 Fragment 可能在接下来的几个月或者几年中被修改。但我仍然希望这些项目能够引起更多人关注，并且继续优化，我肯定会继续关注他们的最新进展的，希望大家继续关注我的博客哦。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.bignerdranch.com/blog/an-investigation-into-flow-and-mortar/" target="_blank" rel="external">Architecting An Investigation into Flow and Mortar</a></li>
<li>译者 : <a href="https://github.com/sundroid" target="_blank" rel="external">sundroid</a>( <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> 协同翻译)</li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>、<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>“在 App 开发过程中尽可能使用 Fragment 替代 Activity”，Google 官方的这个建议无疑让万千 Android 开发者开始关注、使用 Fragment。但随着使用 Fragment 的人数增多，Fragment 存在的各种问题也开始暴露，在各种 Android 社区中，已经开始有人质疑用 Fragment 替代 Activity 在应用开发中是否真的像 Google 说的那样有益。质疑 Fragment 的理由大体如下：<br>]]>
    
    </summary>
    
      <category term="开源库介绍" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E5%BA%93%E4%BB%8B%E7%BB%8D/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Android调试模式中使用Stetho]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/stetho-for-android-debug-builds-only/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/stetho-for-android-debug-builds-only/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:46:50.000Z</updated>
    <content type="html"><![CDATA[<p>最近FaceBook发布了一个叫做<a href="https://github.com/facebook/stetho" target="_blank" rel="external">Stetho</a>的工具.这个工具是一个谷歌浏览器的开发者工具扩展 ，它可以用来检测你的应用。我发现这东西挺好用的，因为它还提供了访问应用中SQLite数据库的接口。很明显，这种类型的工具只应该在应用的调试模式中使用。接下来我们来看看怎么用这个工具。<br><a id="more"></a></p>
<h1 id="添加依赖">添加依赖</h1><p>为了保证只在调试模式中使用Stetho，你可以添加一个调试编译依赖，而不是平时常用的普通依赖类型。</p>
<pre><code>depencencies {
<span class="comment">// your other dependencies here...</span>
debugCompile <span class="string">'com.facebook.stetho:stetho:1.0.0'</span>
}
</code></pre><h1 id="在调试模式中初始化Stetho">在调试模式中初始化Stetho</h1><p>现在我们在调试中使用Stetho。你会怎么做?当然使用牛逼闪闪的Android Gradle构建系统啦。创建一个源文件夹，目录结构为 <font color="red">src/debug/java</font>。这个目录中的代码仅仅是用于调试模式。这个目录结构和<font color="red">src/main/java</font>很像，因为构建模式就是用于应用程序的调试的。(这句话再想想)。然后添加一个<a href="https://github.com/facebook/stetho" target="_blank" rel="external">Stetho</a>主页上描述的 <a href="http://developer.android.com/reference/android/app/Application.html" target="_blank" rel="external">Application</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.facebook.stetho.Stetho;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDebugApplication</span> <span class="keyword">extends</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Stetho.initialize(</span><br><span class="line">                Stetho.newInitializerBuilder(<span class="keyword">this</span>)</span><br><span class="line">                        .enableDumpapp(Stetho.defaultDumperPluginsProvider(<span class="keyword">this</span>))</span><br><span class="line">                        .enableWebKitInspector(Stetho.defaultInspectorModulesProvider(<span class="keyword">this</span>))</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看清楚这个类是怎样继承一个已经有的<font color="red">MyApplication.</font>类的。这样写的确很方便，因为你的应用里可能已经有一个application来进行其他的初始化了。如果你还没有一个application。你从<font color="red">android.app.Application.</font>继承一个就行了。</p>
<h1 id="激活我的调试应用">激活我的调试应用</h1><p>最后一步，我们要做的工具是确保当前的应用的调试版本使用的是MyDebugApplication类。在这里我们用Gradle来验证。在<font color="red">src/debug</font>文件夹中添加一个<font color="red">AndroidManifest.xml</font></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span></span><br><span class="line">    <span class="attribute">package</span>=<span class="value">"com.mycompany"</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">        <span class="attribute">tools:replace</span>=<span class="value">"android:name"</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">".MyDebugApplication"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个<font color="red">AndroidManifest.xml</font>会合并到<font color="red">src/main</font>中的主AndroidManifest.xml文件里，并且会替换标签中的<font color="red">android:name</font>属性。这是因为我们特别添加上了tools:replace=”android:name”属性。真屌。</p>
<p>现在当你启动程序的调试模式，<a href="https://github.com/facebook/stetho" target="_blank" rel="external">Stetho</a>就会被激活。如果你切换到发布版本，Stetho绝对不会被激活，也看不到它的任何痕迹。如果想要不丢人，程序员要保证软件没有BUG。</p>
<h1 id="总结">总结</h1><p>用Android Gradle构建系统，可以很容易的给你的应用添加更多的调试功能。这门手艺不仅可以用在<a href="https://github.com/facebook/stetho" target="_blank" rel="external">Stetho</a>上，还可以用于那些你希望仅仅在调试模式中添加的类库或者工具。</p>
<ul>
<li>原文链接:<a href="http://littlerobots.nl/blog/stetho-for-android-debug-builds-only/" target="_blank" rel="external">在Android调试模式中使用Stetho</a></li>
<li>译者:<a href="https://github.com/BillionWang" target="_blank" rel="external">BillionWang</a></li>
<li>校对者:<a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a></li>
<li>状态:完成</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近FaceBook发布了一个叫做<a href="https://github.com/facebook/stetho">Stetho</a>的工具.这个工具是一个谷歌浏览器的开发者工具扩展 ，它可以用来检测你的应用。我发现这东西挺好用的，因为它还提供了访问应用中SQLite数据库的接口。很明显，这种类型的工具只应该在应用的调试模式中使用。接下来我们来看看怎么用这个工具。<br>]]>
    
    </summary>
    
      <category term="工具" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化截图－应用分发时的自动截图方案]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/screenshot_automation/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/screenshot_automation/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:40:31.000Z</updated>
    <content type="html"><![CDATA[<p>在发布 App 到应用商店时有一件的事情不得不做，就是上传最新的高清无码截图到应用商店上。可是如果你的 App 有许多页面，那你每次发布更新都可能是一场梦魇，因为你需要一页一页地去截图。为了解决众多 App 开发者的这个痛点，我将在这篇博文中介绍一个实现自动化截图的方法：<br><a id="more"></a><br>刚到 <a href="https://www.capitainetrain.com/" target="_blank" rel="external">Capitaine Train</a> 公司里，就有人让我造个能自动截图的轮子，因为我们公司的 App 每次版本更新都让人很头疼：问题在于我们的 App 对应有3种设备，4种语言，也就是有 12 种版本。此外，我们有6个需要截图的页面，也就是说，我们每次版本更新都需要72张截图。我们无法忍受这种低效并浪费时间的工作，于是我们经过不懈的努力，找到了一个自动化截图的方案，在这个方案中，要实现自动化截图有三个关键点：uiautomator 自动化测试, accessibility 和 bash脚本。</p>
<h2 id="修改_uiautomator">修改 uiautomator</h2><p>uiautomator 是一个用部分封装代码将 UI 处理成一个 JUnit 测试用例的框架。这里需要注意的是：被测试的 App 里没有包含这些测试用例，因为他们在一个独立的进程中运行。换句话说，你可以把 uiautomator 框架看作一个独立的机器人，它能帮你在设备上完成诸如：点击，滚动，截图等简单动作。</p>
<p><strong>预备知识</strong></p>
<p>在继续讲解之前，我建议你花些时间阅读官方文档，这能帮助你更好地理解接下来的内容。</p>
<p>uiautomator 框架的 API 非常简单，里面有三个类分别代表了不同类型的 UI 界面元素：</p>
<ul>
<li><p>UiObject: 基本界面元素，例如：TextView</p>
</li>
<li><p>UiCollection: 包含多个 UiObject 的界面元素，例如：LinearLayout</p>
</li>
<li><p>UiScrollable: 包含多个 UiObject ，并能滚动的界面元素，例如：ListView</p>
</li>
</ul>
<p><img src="http://flavienlaurent.com/media/2014-12-05-screenshot_automation/uml.png" alt=""></p>
<p>框架里这两个类你也需要了解：</p>
<ul>
<li><p>UiDevice：用于执行设备常见的动作，例如：点击按钮，截图等等</p>
</li>
<li><p>UiSelector：通过 id, 类型等获得屏幕上的 UI 界面元素</p>
</li>
</ul>
<p>最后，UiAutomatorTestCase 是框架里你绝对不能忽略的类，因为我们必须通过继承它来获得一个 uiautomator 测试用例。</p>
<p>当然了，我刚刚提到的这些类在官方文档里面都有详细的解释，此外，文档还提供了一些示例来帮助我们熟悉 uiautomator 。</p>
<p><strong>安装，创建和运行</strong></p>
<p>接下来我们要做的就是创建 uiautomator ，但很不幸，uiautomator 并没有一个官方的 Gradle 整合模块，所以我们必须自己去完成这项工作。把这些工作都完成后，才能在我们的 App 上使用 uiautomator。uiautomator 测试用例的最终输出应该是一个独立的 JAR 包。具体步骤如下：</p>
<p>在你的项目里新建一个 Gradle 模块，并在其中添加与 local.properties 相同的 android.jar 依赖包：</p>
<p>.build.gradle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties()</span><br><span class="line">props.load(<span class="keyword">new</span> FileInputStream(file(<span class="string">"../local.properties"</span>)))</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: props[<span class="string">'sdk.dir'</span>] + <span class="string">'/platforms/'</span> + androidSdkTarget, include: <span class="string">'*.jar'</span>)</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过使用 local.properties 和 gradle.properties 新建一个 ant 文件，使其获得与项目相同的配置信息(target, sdk path)：</p>
<p>build.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">project</span> <span class="attribute">name</span>=<span class="value">"uiautomator"</span> <span class="attribute">default</span>=<span class="value">"help"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">loadproperties</span> <span class="attribute">srcFile</span>=<span class="value">"../local.properties"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">loadproperties</span> <span class="attribute">srcFile</span>=<span class="value">"gradle.properties"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">value</span>=<span class="value">"$&#123;androidSdkTarget&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">import</span> <span class="attribute">file</span>=<span class="value">"$&#123;sdk.dir&#125;/tools/ant/uibuild.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用ant 构建JAR（不要使用Gradle构建），并把它加到你的设备中，然后运行你的测试用例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ant build</span><br><span class="line">$ adb push uiautomator.jar data/local/tmp</span><br><span class="line">$ adb shell uiautomator runtest uiautomator.jar -c com.your.TestCase</span><br></pre></td></tr></table></figure>
<p><strong>自动切换设置信息</strong></p>
<p>现在我准备讲解怎么在设置中自动切换设置项和设置信息（特别是从一个语言切换到另一个语言）。首先，这是一个练习使用 uiautomator 的机会。同时，这也是自动化截图的关键步骤。但你要记住，我接下来介绍的只是一个能在 Android 5.0 系统上正常使用的办法，如果你有更好的建议或者想法，也可以通过留言和我交流，一起优化这个步骤。</p>
<ul>
<li>打开快捷设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mUiDevice.openQuickSettings();</span><br></pre></td></tr></table></figure>
<ul>
<li>点击设置按钮以打开设置界面</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UiObject(<span class="keyword">new</span> UiSelector().resourceId(<span class="string">"com.android.systemui:id/settings_button"</span>)).click();</span><br></pre></td></tr></table></figure>
<ul>
<li>因为在设置界面里我们没有可用的 View 的 id 值，所以我们必须根据设置栏的文字改变相对应的语言设置。所以我们滚动到某一项（FrameLayout）并点击它</li>
</ul>
<p><img src="http://flavienlaurent.com/media/2014-12-05-screenshot_automation/settings_app.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UiScrollable scrollable = <span class="keyword">new</span> UiScrollable(<span class="keyword">new</span> UiSelector().resourceId(<span class="string">"com.android.settings:id/dashboard"</span>));</span><br><span class="line"></span><br><span class="line">scrollable.getChildByText(<span class="keyword">new</span> UiSelector().className(FrameLayout.class), <span class="string">"Language &amp; input"</span>, <span class="keyword">true</span>).click();</span><br></pre></td></tr></table></figure>
<ul>
<li>通过上面的代码处理，整个“寻找并点击”的自动化逻辑已经能在语言设置栏里被使用了。<br><img src="http://flavienlaurent.com/media/2014-12-05-screenshot_automation/settings_language.png" alt=""></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UiScrollable scrollable = <span class="keyword">new</span> UiScrollable(<span class="keyword">new</span> UiSelector().className(ListView.class));</span><br><span class="line">scrollable.getChildByText(<span class="keyword">new</span> UiSelector().className(LinearLayout.class), <span class="string">"Language"</span>, <span class="keyword">true</span>).click();</span><br></pre></td></tr></table></figure>
<ul>
<li>添加这样的代码后，就能使得目标语言被选中了。</li>
</ul>
<p><img src="http://flavienlaurent.com/media/2014-12-05-screenshot_automation/settings_language_selection.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UiScrollable scrollable = <span class="keyword">new</span> UiScrollable(<span class="keyword">new</span> UiSelector().className(ListView.class));</span><br><span class="line">scrollable.getChildByText(<span class="keyword">new</span> UiSelector().className(LinearLayout.class), <span class="string">"Français (France)"</span>, <span class="keyword">true</span>).click();</span><br><span class="line">Locale.setDefault(<span class="keyword">new</span> Locale(<span class="string">"fr"</span>));</span><br></pre></td></tr></table></figure>
<p>完成了上面的操作后，你还需要强制设置新的语言环境以避免 uiautomator 操作过程中保存了翻译缓存。</p>
<p><strong>小提示</strong></p>
<ul>
<li><p>为了保证 uiautomator 的稳定性，当你在使用 uiautomator 时，必须关掉设备上的所有动画效果（你可以通过下面的设置完成：Settings &gt; Developer options &gt; Window animation|Transition animation|Animator duration scale）</p>
</li>
<li><p>如果你想打 Log 方便你的调试，你可以使用 android.util.Log。为了更好地区分 Log 信息，你可以使用特定的标记来筛选它们。</p>
</li>
<li><p>每一次你需要在 View 的不同层级间切换都要使用 uiautomatorviewer。因为它能为你提供一个精确的选择器，使你能够获得目标 UI 界面元素（uiautomatorviewer 在 sdk/tools/uiautomatorviewer 里）。</p>
</li>
<li><p>记住，uiautomator 测试用例不是 Android 的测试用例，所以你不需要使用任何形式的 Context。</p>
</li>
<li><p>你不能通过 uiautomator 进入你的 App 类，你只能引用 Android 框架中的类。</p>
</li>
<li><p>你可以在命令行中使用 -e 命令把 uiautomator 命令行的参数传递到测试用例类中，又或者是使用测试用例类中的 UiAutomatorTestCase.html#getParams()。</p>
</li>
</ul>
<p>这样处理下来，你会发现自动完成语言的切换很简单对吧？uiautomator 虽然是个很好的工具，但如果你的 App 不是可访问的，它就没什么用了。特别是你的 App 需要创建完全自定义的 View 时，就可能会出现各种问题，所以接下来我们要解决的问题就是让 App 可以被访问，特别是自定义 View。</p>
<h2 id="让自定义_View_可访问">让自定义 View 可访问</h2><p>可访问性对一个 App 来说非常重要，其作用主要体现在两个方面：有些用户/开发者需要它（但总有开发者会忽略这个需求），此外，uiautomator 都以可访问性为基础，也就是说，如果一个应用不能提供可访问的入口，我们将无法在其中使用 uiautomator 自动化测试工具。</p>
<p>大部分情况下，你都没有必要让你的 App 可以被其他应用访问。但事实上，大部分 View 都是可访问的，例如 TextView，ListView 等等。不过在你使用自定义 View 时，获得访问性可能会麻烦点，因为这需要你花费一些功夫去改变其中的代码。</p>
<p>在 Capitaine Train App 里，为了满足对日历视图的特殊需求，我们创建了一个自定义 View。这个 View 是基于 ListView 设计的，ListView 中的每一项都有好几个自定义 View，并且每一个自定义 View 都代表一个月（我们称为 MonthView）。MonthView 是一个纯粹的 View，它继承于 View，并没有子类。这样使得 MonthView 中的一切都需要通过 onDraw() 方法进行绘制。因此，MonthView 在默认情况下不能被访问。</p>
<p>首先要做的事情很简单：使用 View#setContentDescription 方法为每一个 MonthView 设置内容描述，这样我们能够把 ListView 滚动到一个特殊的月份上。</p>
<p>然后，一旦 ListView 停留在某一个给定的月份上，我们希望我们能够选择一个确定的日期。为了实现这个需求，我们需要使 MonthView 的内容是可访问的。幸运的是，Android 的支持库在类似的处理上提供了一个很有用的 Helper类：ExploreByTouchHelper。由于 MonthView 不是以树形结构结合展示其中的 View 集合，所以创建伪树状结构的 View 集合需要基于触摸反馈实现。</p>
<p><strong>为自定义 View 实现 ExploreByTouchHelper</strong></p>
<p>我们有四个方法可以实现：</p>
<ul>
<li><p>getVirtualViewAt(float x, float y)<br>返回参数 x,y处所对应的虚拟 View 的 id。如果对应位置上没有虚拟 View，则返回 ExploreByTouchHelper.INVALID_ID</p>
</li>
<li><p>getVisibleVirtualViews(List<integer> virtualViewIds)<br>将自定义 View 中所有虚拟 View 的 id 添加到 virtualViewIds 数组中。</integer></p>
</li>
<li><p>onPopulateEventForVirtualView(int virtualViewId, AccessibilityEvent event)<br>让虚拟 View 的相关信息可以被访问，例如：文字，内容描述</p>
</li>
<li><p>onPopulateNodeForVirtualView(int virtualViewId, AccessibilityNodeInfo node)<br>让给定结点能够访问虚拟 View 的相关信息，例如文字，内容描述，类名，与父类的关系。如果两者之间产生了交互，你必须在给定结点中说明。</p>
</li>
<li><p>onPerformActionForVirtualView(int virtualViewId, int action, Bundle arguments)<br>在虚拟 View 中实现某种动作（在前面的方法中被指定）</p>
</li>
</ul>
<p>怎么让 ExploreByTouchHelper 的接口变得更简单：</p>
<ul>
<li>创建一个 VirtualView 类去持有虚拟 View 的各种信息，例如：id，文字，内容描述，与父类的关系。</li>
<li>在你的自定义 View 中使用一系列的 VirtualView。尽快初始化它们，并在绘制后更新它们</li>
</ul>
<p>YourAccessibilityTouchHelper.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">YourAccessibilityTouchHelper</span> <span class="keyword">extends</span> <span class="title">ExploreByTouchHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YourAccessibilityTouchHelper</span><span class="params">(View forView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(forView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getVirtualViewAt</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VirtualView vw = findVirtualViewByPosition(x, y);</span><br><span class="line">        <span class="keyword">if</span> (vw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ExploreByTouchHelper.INVALID_ID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vw.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getVisibleVirtualViews</span><span class="params">(List&lt;Integer&gt; virtualViewIds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mVirtualViews.size(); i++) &#123;</span><br><span class="line">            mVirtualViews.add(mVirtualViews.get(i).id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPopulateEventForVirtualView</span><span class="params">(<span class="keyword">int</span> virtualViewId, AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VirtualDayView vw = findVirtualViewById(virtualViewId);</span><br><span class="line">        <span class="keyword">if</span> (vw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        event.getText().add(vw.description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPopulateNodeForVirtualView</span><span class="params">(<span class="keyword">int</span> virtualViewId, AccessibilityNodeInfoCompat node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> VirtualDayView vw = findVirtualViewById(virtualViewId);</span><br><span class="line">        <span class="keyword">if</span> (vw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.setText(Integer.toString(vw.text));</span><br><span class="line">        node.setContentDescription(vw.description);</span><br><span class="line">        node.setClassName(vw.className);</span><br><span class="line">        node.setBoundsInParent(vw.boundsInParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在你的自定义 View 中使用 Helper 类</strong></p>
<p>我们需要在 ListView.getView 方法被执行后通过 setAccessibilityDelegate() 方法重设代理，因为我们需要实现 dispatchHoverEvent() 方法来激活对触摸事件的探索。（如果你的自定义 View 没有在 ListView 中被使用的话，只需要在构造器中设置代理）。</p>
<p>YourCustomView.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourCustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> YourAccessibilityTouchHelper mTouchHelper;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">YourCustomView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">      mTouchHelper = <span class="keyword">new</span> YourAccessibilityTouchHelper(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAccessibilityDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      setAccessibilityDelegate(mTouchHelper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchHoverEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mTouchHelper.dispatchHoverEvent(event)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.dispatchHoverEvent(event);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>用 uiautmatorviewer 检查你的接口能否正常运行</strong></p>
<p>如果一切都正常运行，在你用 uiautmatorviewer 截图后，你应该能在虚拟 View 图层看到在可访问结点中预设置的所有信息。</p>
<p><img src="http://flavienlaurent.com/media/2014-12-05-screenshot_automation/accessibility_calendar_uiautomator.png" alt=""></p>
<p>另一方面，在我写这篇博文的时候我发现 Capitaine Train App里的一个问题：每一个虚拟 View 的类名都是 com.capitainetrain.x，因为我们忘了用 Proguard。</p>
<p>现在 App 中的一切都是可访问的，我们总算可以在 App 中顺利使用 uiautomator 进行自动化截图了。打铁趁热，我们不妨对我们的代码稍作修改，让它能够“优雅地截图”。</p>
<h2 id="优雅地截取图片">优雅地截取图片</h2><p>这篇博文要讲解的最后一个问题就是怎么改进 uiautomator ，使得它能在多种语言中优雅地自动截图。实现这个功能需要两个步骤：第一，使用 bash 脚本运行 uiautomator 测试用例，并按照你需要的图片数量进行自动化截图，之后用 imagemagick 处理你获得的照片。</p>
<p>首先要做的就是创建 uiautomator JAR包，然后运行测试用例。因为你已经在前面的讲解中学习了怎么在测试用例中转换语言，所以你只需要传递两个参数到测试用例中：当前设置中使用的语言和你将要切换的语言。</p>
<p>screenshot.sh</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Build and push the uiautomator JAR</span><br><span class="line">ant build</span><br><span class="line">adb push bin/uiautomator.jar data/local/tmp</span><br><span class="line"></span><br><span class="line">adb shell uiautomator runtest uiautomator.jar</span><br><span class="line">  -e current_language $&#123;currentLanguage&#125;</span><br><span class="line">  -e new_language $&#123;newLanguage&#125;</span><br><span class="line">  -c com.your.TestCase</span><br></pre></td></tr></table></figure>
<p>接下来我们只要再创建一个能够切换语言，打开 App并截图的简单测试用例就可以啦：</p>
<p>TestCase.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> <span class="keyword">extends</span> <span class="title">UiAutomatorTestCase</span> </span>&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUp();</span><br><span class="line">        <span class="keyword">final</span> Bundle params = getParams();</span><br><span class="line">        mCurrentLanguage = params.getString(<span class="string">"current_language"</span>);</span><br><span class="line">        mNewLanguage = params.getString(<span class="string">"new_language"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        switchLanguage(mCurrentLanguage, mNewLanguage);</span><br><span class="line">        openApp();</span><br><span class="line">        takeScreenshot(<span class="string">"data/local/tmp/screenshots"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>switchLanguage(String,String)只需要使用我在”修改 uiautomator”中讲解的方法就能轻松地实现 </li>
<li>openApp() 在 <a href="https://developer.android.com/tools/testing/testing_ui.html#sample" target="_blank" rel="external">这里</a>有详细的解释</li>
<li>takeScreenshot() 使用了 UiDevice#takeScreenshot 方法。在这里只有一个小提示：如果一个 App 使用了可滚动的 View，在滚动条消失之前我们必须安静地等一会儿，不然的话我们会在最后的截图里看到它。</li>
</ul>
<p>现在截图都被储存在设备里了，我们只需要把它们取出来就大功告成了：</p>
<p>screenshot.sh</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mkdir</span> screenshots</span><br><span class="line"><span class="title">adb</span> pull <span class="typedef"><span class="keyword">data</span>/local/tmp/screenshots screenshots</span></span><br></pre></td></tr></table></figure>
<p>在多语言环境中运行测试用例。它会从设备当前使用的语言开始运行，因为我找不到一个合适的方式去表示它，然后会在不同的语言环境下（我们需要截图的那些语言）运行测试用例。</p>
<p>screenshot.sh</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">screenshot() &#123;</span><br><span class="line">    currentLanguage=<span class="label">$1</span></span><br><span class="line">  newLanguage=<span class="label">$2</span></span><br><span class="line">  adb <span class="keyword">shell</span> uiautomator <span class="keyword">runtest</span> uiautomator.jar</span><br><span class="line">      -<span class="keyword">e</span> current_language <span class="label">$&#123;currentLanguage&#125;</span></span><br><span class="line">      -<span class="keyword">e</span> new_language <span class="label">$&#123;newLanguage&#125;</span></span><br><span class="line">      -c com.your.TestCase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">screenshot <span class="label">$deviceLanguage</span> fr</span><br><span class="line">screenshot fr <span class="keyword">en</span></span><br><span class="line">screenshot <span class="keyword">en</span> <span class="keyword">de</span></span><br></pre></td></tr></table></figure>
<p>App 每次卸载/安装后在相同的环境下运行测试用例都能正常地实现自动化截图的功能：</p>
<p>screenshot.sh</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">screenshot() &#123;</span><br><span class="line">    currentLanguage=<span class="label">$1</span></span><br><span class="line">  newLanguage=<span class="label">$2</span></span><br><span class="line"></span><br><span class="line">  # Uninstall/Install the <span class="keyword">app</span></span><br><span class="line">  adb uninstall com.your.<span class="keyword">app</span></span><br><span class="line">  adb install ../<span class="keyword">app</span>/build/outputs/apk/yourapp-release.apk</span><br><span class="line">  </span><br><span class="line">  adb <span class="keyword">shell</span> uiautomator <span class="keyword">runtest</span> uiautomator.jar</span><br><span class="line">      -<span class="keyword">e</span> current_language <span class="label">$&#123;currentLanguage&#125;</span></span><br><span class="line">      -<span class="keyword">e</span> new_language <span class="label">$&#123;newLanguage&#125;</span></span><br><span class="line">      -c com.your.TestCase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后把所有模块糅合在一起：</p>
<p>screenshot.sh</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">screenshot() &#123;</span><br><span class="line">  currentLanguage=<span class="label">$1</span></span><br><span class="line">  newLanguage=<span class="label">$2</span></span><br><span class="line"></span><br><span class="line">  # Uninstall/Install the <span class="keyword">app</span></span><br><span class="line">  adb uninstall com.your.<span class="keyword">app</span></span><br><span class="line">  adb install ../<span class="keyword">app</span>/build/outputs/apk/yourapp-release.apk</span><br><span class="line"></span><br><span class="line">  # <span class="keyword">Run</span> the <span class="keyword">test</span> case</span><br><span class="line">  adb <span class="keyword">shell</span> uiautomator <span class="keyword">runtest</span> uiautomator.jar</span><br><span class="line">      -<span class="keyword">e</span> current_language <span class="label">$&#123;currentLanguage&#125;</span></span><br><span class="line">      -<span class="keyword">e</span> new_language <span class="label">$&#123;newLanguage&#125;</span></span><br><span class="line">      -c com.your.TestCase</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">mkdir</span> screenshots</span><br><span class="line">  adb pull data/<span class="keyword">local</span>/tmp/screenshots screenshots</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Build and push the uiautomator JAR</span><br><span class="line">ant build</span><br><span class="line">adb push bin/uiautomator.jar data/<span class="keyword">local</span>/tmp</span><br><span class="line"></span><br><span class="line"># Build the APK</span><br><span class="line"><span class="keyword">cd</span> .. &amp;&amp; ./gradlew assembleRelease &amp;&amp; <span class="keyword">cd</span> uiautomator</span><br><span class="line"></span><br><span class="line"># Screenshot everything</span><br><span class="line">screenshot <span class="label">$currentLanguage</span> fr</span><br><span class="line">screenshot fr <span class="keyword">en</span></span><br><span class="line">screenshot <span class="keyword">en</span> <span class="keyword">de</span></span><br></pre></td></tr></table></figure>
<p><strong>美化截图</strong><br>分享一篇好文：<a href="http://cyrilmottier.com/2012/07/11/creating-professional-looking-screenshots/" target="_blank" rel="external">Creating professional looking screenshots</a>。</p>
<p>每一个 App 的运营者都应该尽其所能美化 App 的截图，因为这是用户在应用商店中对 App 的第一印象。大多数情况下，用户都不会阅读应用的描述，而是直接打开应用的截图，因为阅读文字比看图片更费劲。虽然不能说经过下面的处理能获得完美无瑕的图片，但也在水平线以上了。那么什么样的 App 截图是优雅的截图呢？</p>
<ul>
<li><p>始终保持状态栏的整洁</p>
</li>
<li><p>移除导航栏</p>
</li>
<li><p>适配多种屏幕的尺寸</p>
</li>
</ul>
<p>第二点可以用一个超神奇的工具—imagemagick 实现，虽然它的官方文档非常大，但我们用不到那么多的特性，所以我们只需要关注两个特性：组合和转换。</p>
<p><strong>用组合图覆盖状态栏</strong></p>
<p>组合图是用来把一个图片覆盖到另一个上面的，这是获得简洁状态栏的完美办法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composite -quality <span class="number">100</span> -compose atop clean_status_bar.png screenshot.png clean_screenshot.png</span><br></pre></td></tr></table></figure>
<p><strong>通过转换裁剪导航栏</strong></p>
<p>转换特性被用于转换图片的格式，使其格式与裁剪后的图片相同，这是从截图中移除导航栏的完美办法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert -quality <span class="number">100</span> screenshot.png -gravity South -chop <span class="number">0x144</span> clean_screenshot.png</span><br></pre></td></tr></table></figure>
<p>144是在Nexu5上导航栏的高度像素值。</p>
<p><strong>结论</strong></p>
<p>因为有了这篇博文，通常要花费半天，甚至一天的截图工作现在能通过 Capitaine Train 上用的这个自动化截图工具缩短到 20～30 分钟完成（我相信没有人想手动地做这些工作，或者因为嫌弃这样的工作，从不更新 App 的截图）。这个工具能高效地节省时间，如果能够更多的人和资源投入到这个工具的开发之中，我相信这个工具还能变得更好，也不会那么容易出错和崩溃。</p>
<p>接下来可能做的：</p>
<p>使用 Google Play 发布的 API 简化上传这些自动生成的截图的流程，并把这个工具整合到 Jenkins 里，让 App 每一次版本更新都能自动地获取最新的截图，并将其显示在应用商店中。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://flavienlaurent.com/blog/2014/12/05/screenshot_automation/" target="_blank" rel="external">Screenshots Through Automation</a></li>
<li>作者 : <a href="http://flavienlaurent.com/" target="_blank" rel="external">Flavien Laurent</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/sundroid" target="_blank" rel="external">sundroid</a>  </li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在发布 App 到应用商店时有一件的事情不得不做，就是上传最新的高清无码截图到应用商店上。可是如果你的 App 有许多页面，那你每次发布更新都可能是一场梦魇，因为你需要一页一页地去截图。为了解决众多 App 开发者的这个痛点，我将在这篇博文中介绍一个实现自动化截图的方法：<br>]]>
    
    </summary>
    
      <category term="自动化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开始使用 Transitions（过渡动画） (part 1)]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/activity-fragment-transitions-in-android-lollipop-part1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/activity-fragment-transitions-in-android-lollipop-part1/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:53:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="首先">首先</h2><p>这篇文章主要介绍 Android 5.0 新加入的 Transition (过渡动画) API，这是这个系列的第一篇文章。主要介绍下面几个话题:</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html" target="_blank" rel="external">深入理解 Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html" target="_blank" rel="external">深入理解共享元素的 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)<a id="more"></a>
今天这篇文章是 Transition 的概述，同时也象征着这个专栏的开始，希望大家喜欢啦。</li>
</ul>
<h1 id="先说下什么是_Transition(过渡动画)-">先说下什么是 Transition(过渡动画).</h1><p>Lollipop 中 Activity 和 Fragment 的过渡动画是基于 Android 一个叫作 Transition 的新特性实现的。<br>初次引入这个特性是在 KitKat 中，Transition 框架提供了一个方便的 API 来构建应用中不同 UI 状态切换时的动画。<br>这个框架始终围绕两个关键概念:场景和过渡。<br><strong>场景</strong> 描述应用中 UI 的状态，<a href="https://developer.android.com/reference/android/transition/Transition.html" target="_blank" rel="external"><strong>过渡</strong></a> 确定两个场景转换之间的过渡动画。</p>
<p>当场景转换，Transition 的主要职责是：</p>
<ol>
<li>捕获每一个 View 的起始和结束状态</li>
<li>根据这些数据来创建从一个场景到另一个场景间的过渡动画。</li>
</ol>
<p>下面是一个简单示例，当用户点击，我们需要 Activity 的 View 视图产生消失和出现的效果。使用 Transition ，实现这个需求只要几行代码，代码如下：<a id="1" href="#b1">(1)</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup mRootView;</span><br><span class="line">    <span class="keyword">private</span> View mRedBox, mGreenBox, mBlueBox, mBlackBox;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mRootView = (ViewGroup) findViewById(R.id.layout_root_view);</span><br><span class="line">        mRootView.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mRedBox = findViewById(R.id.red_box);</span><br><span class="line">        mGreenBox = findViewById(R.id.green_box);</span><br><span class="line">        mBlueBox = findViewById(R.id.blue_box);</span><br><span class="line">        mBlackBox = findViewById(R.id.black_box);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        TransitionManager.beginDelayedTransition(mRootView, <span class="keyword">new</span> Fade());</span><br><span class="line">        toggleVisibility(mRedBox, mGreenBox, mBlueBox, mBlackBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toggleVisibility</span><span class="params">(View... views)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (View view : views) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isVisible = view.getVisibility() == View.VISIBLE;</span><br><span class="line">            view.setVisibility(isVisible ? View.INVISIBLE : View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更好地理解底层中发生了什么，我们一步一步地分析下这段代码，首先假设屏幕上的所有的 View 都是<strong>可见</strong>的:</p>
<ol>
<li><p>首先，点击按钮后调用了 <a href="https://developer.android.com/reference/android/transition/TransitionManager.html#beginDelayedTransition(android.view.ViewGroup,%20android.transition.Transition)" target="_blank" rel="external">beginDelayedTransition()</a>，<br>将根场景和<a href="https://developer.android.com/reference/android/transition/Fade.html" target="_blank" rel="external">Fade</a> Transition对象（淡入/淡出过渡效果）作为参数传递出去。框架立即对场景中所有 View 调用 Transitions 的 <a href="https://developer.android.com/reference/android/transition/Transition.html#captureStartValues(android.transition.TransitionValues)" target="_blank" rel="external">captureStartValues()</a> 方法，同时， Transitions 将记录每个 View 的可见性。</p>
</li>
<li><p>调用结束后，开发者将场景中所有 View 设置为<strong>不可见</strong>的。</p>
</li>
<li><p>在下一个画面，框架对场景中所有 View(近期更新的) 调用 Transitions 的<a href="https://developer.android.com/reference/android/transition/Transition.html#captureEndValues(android.transition.TransitionValues)" target="_blank" rel="external">captureEndValues()</a><br>方法， Transitions 记录可见性。</p>
</li>
<li><p>框架调用 Transitions 的 <a href="https://developer.android.com/reference/android/transition/Transition.html#createAnimator(android.view.ViewGroup,%20android.transition.TransitionValues,%20android.transition.TransitionValues)" target="_blank" rel="external">createAnimator()</a> 方法。Transition 分析每一个 View 的起始/结束状态，注意到 View 的可见性发生了变化。之后 <strong>Fade</strong> 对象利用这些信息创建了一个<strong>AnimatorSet</strong> 对象，并将其返回到框架中，进而将每个 View 的 <strong>alpha</strong> 值渐变到 <strong>0f</strong>。</p>
</li>
<li><p>框架运行返回的<strong>动画</strong>,让所有 View 从屏幕中淡出。</p>
</li>
</ol>
<p>这个例子强调了 Transition 框架的两个优点：第一，<strong>Transition</strong> 将开发人员所需要的<strong>动画</strong>概念抽象，减少了 Activity 和 Fragment 内的代码复用，使得我们只要设置好 View 的 起始 和 结束 时的状态，就能通过 Transition 自动创建动画。第二，只要更换 <strong>Transition</strong> 对象就可以修改两个场景间的动画。</p>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/04/trivial-opt.mp4" target="_blank" rel="external"> 示例 <strong>Video 1.1</strong></a>,只要少量代码就可以创建复杂的动画效果。<br>后续文章会介绍如何做到。</p>
<h1 id="Lollipop_中的_Activity_&amp;_Fragment_Transitions">Lollipop 中的 Activity &amp; Fragment Transitions</h1><p>在 Android 5.0 中， 切换 <strong>Activitys</strong> 或者 <strong>Fragments</strong> 时可以使用 <strong>Transitions</strong> 来构建精致的过场动画。虽然在之前的版本中已经引入 Activity 和 Fragment 的切换动画(通过 <a href="http://developer.android.com/reference/android/app/Activity.html#overridePendingTransition(int,%20int)" target="_blank" rel="external">Activity#overridePendingTransition()</a> 和 <a href="http://developer.android.com/reference/android/app/FragmentTransaction.html#setCustomAnimations(int,%20int,%20int,%20int)" target="_blank" rel="external">FragmentTransaction#setCustomAnimation()</a> 方法实现)，但是动画的对象只能是<strong>Activity/Fragment</strong>整体。而新的 API 将这个特性延伸，使我们可以为每个 View 单独设置动画，甚至可以在两个独立的 Activity/Fragment 容器内共享某些 View的动画。</p>
<p>接下来介绍些术语。注意，虽然下面是以 Activity 为例，但是在 Fragment 中这些术语也同样有效:</p>
<blockquote>
<p>假设 <strong>A</strong> 和 <strong>B</strong> 是两个 Activity，通过 <strong>A</strong> 来启动 <strong>B</strong>。<br><strong>A</strong> 叫做 “调用Activity”(调用 <code>startActivity()</code> 的那个)<br><strong>B</strong> 就是 “被调用Activity”</p>
</blockquote>
<p>Activity transition API 是围绕退出，进入，返回还有重入过渡动画效果构建的。根据之前的定义我们可以这样描述它们:</p>
<blockquote>
<p>Activity <strong>A</strong> 的 退出 Transition 确定 <strong>A</strong> 启动 <strong>B</strong> 时 <strong>A</strong> 中 View 的动画</p>
<p>Activity <strong>B</strong> 的 进入 Transition 确定 <strong>A</strong> 启动 <strong>B</strong> 时 <strong>B</strong> 中 View 的动画</p>
<p>Activity <strong>B</strong> 的 返回 Transition 确定 <strong>B</strong> 返回 <strong>A</strong> 时 <strong>B</strong> 中 View 的动画</p>
<p>Activity <strong>A</strong> 的 重入 Transition 确定 <strong>B</strong> 返回 <strong>A</strong> 时 <strong>A</strong> 中 View 的动画</p>
</blockquote>
<p>最后，Transition 框架提供了 <strong>Content(内容)</strong>和<strong>共享元素(Shared Element)</strong> 两种类型的Activity过渡动画，每个都可以让我们以独特的方式自定义 Activity 切换间的动画</p>
<blockquote>
<p><strong>Content(内容) Transition</strong> 确定了非共享元素如何 进入/退出 Activity 场景</p>
<p><strong>共享元素(Shared Element) Transition</strong> 确定了两个Activity 共享 View (也被叫做主角视图)的动画效果。</p>
</blockquote>
<p><a href="http://www.androiddesignpatterns.com/assets/videos/posts/2014/12/04/news-opt.mp4" target="_blank" rel="external">Video 1.2</a>这段视频很好的解释了 Content Transition 和 共享元素 Transition，我猜想它使用了下面的过渡动画。</p>
<ul>
<li><strong>A</strong>(调用Activity) 的<strong>退出</strong>和<strong>重新进入</strong> Content Transition 都是 <strong>null</strong>。因为用户退出和重新进入时 Activity A中的非共享视图没有动画效果。<a id="2" href="#b2">(2)</a></li>
</ul>
<ul>
<li><p><strong>B</strong>(被调用Activity) 的<strong>进入</strong> Content Transition 使用了一个自定义的 Slide Transition 将list item从底部移至屏幕中。</p>
</li>
<li><p>Activity <strong>B</strong> 的<strong>返回</strong> Content Transition是一个 <strong>TransitionSet</strong>，同时进行两个子 Transition:一个Slide (Gravity.TOP) Transition<br>针对Activity上半部分的View，一个Slide (Gravity.BOTTOM) Transition 针对Activity 下半部分View。当用户点击按钮返回Activity A，Activity呈现一种断成两半的感觉。</p>
</li>
<li><p>共享元素的进入和退出 Transition 都是 <strong>ChangeImageTransform</strong>，使ImageView过渡动画可以在两个Activity间无缝衔接。</p>
</li>
</ul>
<p>你可能也注意到了在共享元素 Transition 下还有一个圆形的过渡动画(circular reveal)，我们会在将来的章节中介绍它是如何实现的。现在，我们来继续了解 Activity 和 Fragment transition APIs</p>
<h1 id="介绍Activity_Transition_API">介绍Activity Transition API</h1><p>使用 Lollipop 的 APIs 创建一个 Activity 过渡动画 非常简单，下面的总结是实现一个过渡动画的必要步骤。在接下来的文章中我们还会介绍很多提升水平的用例，不过现在先让我们来入个门:</p>
<ul>
<li><p>在你的A(调用Activity)和B(被调用Activity)的 <code>.java</code> 文件或者<br><code>xml</code><a id="3" href="#b3">(3)</a>布局中请求启用<br><a href="http://developer.android.com/reference/android/view/Window.html#FEATURE_ACTIVITY_TRANSITIONS" target="_blank" rel="external"><code>Window.FEATURE_ACTIVITY_TRANSITIONS</code></a> 窗口特性，<br>使用Material主题的应用默认已开启。</p>
</li>
<li><p>为A和B单独设置 <a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a> Content Transition 。<br>Material主题的 <a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a> Content Transition 默认分别是<br><code>null</code>和<code>Fade</code>。如果没有明确定义 <a href="https://developer.android.com/reference/android/view/Window.html#setSharedElementReenterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>reenter</strong></a> 或 <a href="https://developer.android.com/reference/android/view/Window.html#setReturnTransition(android.transition.Transition)" target="_blank" rel="external"><strong>return</strong></a><br>Content Transition 将会使用 Activity 的 <a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a><br>Transition 来代替。</p>
</li>
<li><p>为 A 和 B 设置 <a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a> 共享元素 Transition。<br>Material主题中共享元素默认设置 <a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/res/res/transition/move.xml" target="_blank" rel="external"><code>@android:transition/move</code></a> 作为<br><a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a> 过渡动画。如果没有明确定义<br><a href="https://developer.android.com/reference/android/view/Window.html#setSharedElementReenterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>reenter</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setReturnTransition(android.transition.Transition)" target="_blank" rel="external"><strong>return</strong></a> 的过渡动画将会使用 Activity 的<br><a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external"><strong>exit</strong></a> 和 <a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external"><strong>enter</strong></a> 过渡动画作为替代。</p>
</li>
<li>启动一个包含 Content Transition 和 共享元素 Transition 的 Activity 时要调用<br><code>startActivity(Context, Bundle)</code>方法，其中第二参数 Bundle 通过下面这段代码获得：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions.makeSceneTransitionAnimation(activity, pairs).toBundle();</span><br></pre></td></tr></table></figure>
<p><strong>pairs</strong> 是一个 <strong>Pair&lt; View, String &gt;</strong> 数组，记录Activity间<a id="4" href="#b4">(4)</a> 共享元素的View 和 相对应的特征字符串。别忘了在<a href="https://developer.android.com/reference/android/view/View.html#setTransitionName(java.lang.String)" target="_blank" rel="external">程序</a>中或 <a href="https://developer.android.com/reference/android/view/View.html#attr_android:transitionName" target="_blank" rel="external">xml</a> 文件里给共享元素设置不重复的名称，否则过渡动画不会正常运行。</p>
<ul>
<li><p>通过启动程序返回一个 Transition，调用 <strong>finishAfterTransition()</strong> 代替 <strong>finish()</strong>。</p>
</li>
<li><p>Material主题应用默认会在他们的<strong>退出/重入</strong> Transition 完成前一点点启动<strong>进入/返回</strong> Content Transition，这样会在两个动画间产生一些重叠，让过渡动画更好看。如果你想关闭这个特性可以调用 <a href="http://developer.android.com/reference/android/view/Window.html#setAllowEnterTransitionOverlap(boolean)" target="_blank" rel="external"> setWindowAllowEnterTransitionOverlap()</a> 和 <a href="http://developer.android.com/reference/android/view/Window.html#setAllowReturnTransitionOverlap(boolean)" target="_blank" rel="external">setWindowAllowReturnTransitionOverlap()</a> 方法或者在xml文件里给定适当的属性</p>
</li>
</ul>
<h2 id="Fragment_的_Transition_API">Fragment 的 Transition API</h2><p>如果你使用 Fragment 的 transition API，大部分 API 相似，但是会有一些小的不同:</p>
<ul>
<li><p>Content 的<a href="https://developer.android.com/reference/android/view/Window.html#setExitTransition(android.transition.Transition)" target="_blank" rel="external">退出</a>，<a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external">进入</a>，<a href="https://developer.android.com/reference/android/view/Window.html#setSharedElementReenterTransition(android.transition.Transition)" target="_blank" rel="external">重入</a>和<a href="https://developer.android.com/reference/android/view/Window.html#setReturnTransition(android.transition.Transition)" target="_blank" rel="external">返回</a> 过渡动画应该在 Fragment 的<code>.java</code>文件中调用对应的方法或者在 xml 属性声明里设置。</p>
</li>
<li><p>共享元素 的<a href="https://developer.android.com/reference/android/view/Window.html#setEnterTransition(android.transition.Transition)" target="_blank" rel="external">进入</a>和 <a href="https://developer.android.com/reference/android/view/Window.html#setReturnTransition(android.transition.Transition)" target="_blank" rel="external">返回</a> 过渡动画应该在 Fragment 的<code>.java</code>文件中调用对应的方法或者在 xml 属性声明里设置。</p>
</li>
<li><p>鉴于Activity的 Transition 是通过调用 <strong>startActivity()</strong> 和 <strong>finishAfterTransition()</strong> 直接启动的,Fragment 的过渡是在 Fragment<br>被add, remove, attach, detach, show,或 hidden 后由 FragmentTransaction 自动启动。</p>
</li>
<li><p>共享元素应该在transaction(事务)提交前调用<a href="https://developer.android.com/reference/android/app/FragmentTransaction.html#addSharedElement(android.view.View,%20java.lang.String)" target="_blank" rel="external"><code>addSharedElement(View, String)</code></a>声明为 <strong>FragmentTransaction</strong> 的一部分。</p>
</li>
</ul>
<h2 id="结语">结语</h2><p>这篇文章里我们只是简单的介绍了 Activitiy 和 Fragment transition API，但是在接下来的文章你会发现扎实的基础给你带来的好处，尤其是在讲到<strong>自定义过渡动画</strong>时。后面我们会非常深入的讲解 Content Transition 和 共享元素 Transition，让你更加了解 Activity 和 Fragment 背后的工作。</p>
<p>希望你喜欢我的文章，感谢观看～</p>
<ol>
<li><p>如果你想尝试这个例子，这里有<a href="https://gist.github.com/alexjlockwood/a96781b876138c37e88e" target="_blank" rel="external">xml代码</a> <a id="b1" href="#1">↩</a></p>
</li>
<li><p>第一眼看上去可能感觉是Activity A fade in/out 屏幕, 事实上是Activity B 在 Activity A 的上面渐变. A 中的 View 事实上是没有动画的. 你可以在被调用 Activity 的 Window 中使用 <a href="http://developer.android.com/reference/android/view/Window.html#setTransitionBackgroundFadeDuration(long)" target="_blank" rel="external">setTransitionBackgroundFadeDuration()</a> 方法调节背景渐变持续时间。 <a id="b2" href="#2">↩</a></p>
</li>
<li><p>了解更多关于 <strong>FEATURE_ACTIVITY_TRANSITIONS</strong> 和 <strong>FEATURE_CONTENT_TRANSITIONS</strong> 窗口特性的不同可以看<a href="http://stackoverflow.com/questions/28975840/feature-activity-transitions-vs-feature-content-transitions" target="_blank" rel="external">这里StackOverflow Post</a><a id="b3" href="#3">↩</a></p>
</li>
<li><p>启动一个包含Content Transition 而不是共享元素 Transition 的Activity,可以这样创建<strong>Bundle</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions.makeSceneTransitionAnimation(activity).toBundle()</span><br></pre></td></tr></table></figure>
<p>如果想完全禁用Content Transition 和 共享元素 Transition 可以将 Bundle 设为 <strong>null</strong>. <a id="b4" href="#4">↩</a></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html" target="_blank" rel="external">Getting Started with Activity &amp; Fragment Transitions (part 1)</a></li>
<li>作者 : <a href="https://plus.google.com/+AlexLockwood" target="_blank" rel="external">Alex Lockwood</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a></li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="首先">首先</h2><p>这篇文章主要介绍 Android 5.0 新加入的 Transition (过渡动画) API，这是这个系列的第一篇文章。主要介绍下面几个话题:</p>
<ul>
<li>Part 1: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-transitions-in-android-lollipop-part1.html">在 Activity 和 Fragment 中使用 Transition </a></li>
<li>Part 2: <a href="http://www.androiddesignpatterns.com/2014/12/activity-fragment-content-transitions-in-depth-part2.html">深入理解 Transition</a></li>
<li>Part 3a: <a href="http://www.androiddesignpatterns.com/2015/01/activity-fragment-shared-element-transitions-in-depth-part3a.html">深入理解共享元素的 Transition</a></li>
<li>Part 3b:  <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html">延迟共享元素的 Transition</a></li>
<li>Part 3c: 共享元素回调实践 (coming soon!)</li>
<li>Part 4:  Activity &amp; Fragment 过渡动画示例(coming soon!)]]>
    
    </summary>
    
      <category term="动画" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用RxJava.Observable取代AsyncTask和AsyncTaskLoader]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/04/30/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2015-06-29T13:40:34.000Z</updated>
    <content type="html"><![CDATA[<p>在网上有很多关于RxJava入门指南的帖子，其中一些是基于Android环境的。但是，我想到目前为止，很多人只是喜欢他们所看到的这些，当要解决在他们的Android项目中出现的具体问题时，他们并不知道如何或者是为什么要使用RxJava。在这一系列的文章中，我想要探索在我工作过的一些依赖于RxJava架构的Android项目中的模式。<br><a id="more"></a><br>在文章的开始，我想要处理一些Android开发者在使用RxJava的时候，很容易遇到的状况。从这个角度，我将提供更高级和更合适的解决方案。在这一系列的文章中，我希望可以听到其他开发者在使用RxJava的过程中解决类似的问题，或许他们和我发现的一样呢。</p>
<h1 id="问题一：后台任务">问题一：后台任务</h1><p>Android开发者首先遇到的挑战就是如何有效的在后台线程中工作，然后在UI线程中更新UI。这经常是因为需要从web service中获取数据。对于已经有相关经验的你可能会说：“这有什么挑战性？你只需要启动一个AsyncTask，然后所有的工作它就都给你做了。”如果你是这样想的，那么你有一个机会去改善这种状况。这是因为你已经习惯了这种复杂的方式并且忘记这本应该是很简洁的，或者是说你没有处理所有应该处理的边界情况。让我们来谈谈这个。</p>
<h2 id="默认的解决方案：AsyncTask">默认的解决方案：AsyncTask</h2><p>AsyncTask是在Android里面默认的处理工具，开发者可以做里面一些长时间的处理工作，而不会阻塞用户界面。(注意：最近，AsyncTaskLoader用来处理一些更加具体的数据加载任务，我们以后会再谈谈这个)</p>
<p>表面上，这似乎很简单，你定义一些代码在后台线程中运行，然后定义一些代码运行在UI线程中，在后台任务处理完之后，它在UI线程会处理从后台任务传递过来的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallWebServiceTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Result</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInBackground</span><span class="params">(String... someData)</span> </span>&#123;</span><br><span class="line">	        Result result = webService.doSomething(someData);</span><br><span class="line">	        <span class="keyword">return</span> result;</span><br><span class="line">	    &#125;</span><br><span class="line">    </span><br><span class="line">	    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (result.isSuccess() &#123;</span><br><span class="line">	            resultText.setText(<span class="string">"It worked!"</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">使用AsyncTask的最大的问题是在细节的处理上，让我们谈谈这个问题。</span><br><span class="line"></span><br><span class="line">###错误处理</span><br><span class="line">这种简单用法的第一个问题就是：“如果出现了错误怎么办？”不幸的是，暂时没有非常好的解决方案。所以很多的开发者最终要继承AsyncTask，然后在doInBackground()中包裹一个<span class="keyword">try</span>/<span class="keyword">catch</span>，返回一个&lt;TResult, Exception&gt;，然后根据发生的情况，分发到新定义的例如onSuccess()或者是onError()中。(我也曾经见过仅捕获异常的引用，然后在 onPostExcecute()中进行检查的写法) </span><br><span class="line"></span><br><span class="line">这最终是有点帮助的，但是你必须为你的每个项目写上额外的代码，随着时间的推移，这些自定义的代码在开发者之间和项目之间，可能不会保持很好的一致性和可预见性。</span><br><span class="line"></span><br><span class="line">###Activity和Fragment的生命周期</span><br><span class="line">另外一个你必须面对的问题是：“当AsyncTask正在运行的时候，如果我退出Activity或者是旋转设备的话会发生什么？”嗯，如果你只是发送一些数据，之后就不再关心发送结果，那可能是没有问题的，但是如果你需要根据Task的返回结果更新UI呢？如果你不做一些事情阻止的话，那么当你试图去调用Activity或者是view的话，你将得到一个空指针异常导致程序崩溃，因为他们现在是不可见或者是<span class="keyword">null</span>的。</span><br><span class="line"></span><br><span class="line">同样，在这个问题上AsyncTask没有做很多工作去帮助你。作为一个开发者，你需要确保保持一个Task的引用，并且要么当Activity正在被销毁的时候取消Task，要么当你试图在onPostExecute()里面更新UI的时候，确保Activity是在一个可达状态。当你只想明确的做一些工作，并且让项目容易维护的时候，这将会继续提高维护项目的难度。</span><br><span class="line"></span><br><span class="line">###旋转时的缓存(或是其他情况)</span><br><span class="line">当你的用户还是待在当前Activity，仅仅是旋转屏幕会发生什么？在这种情况下，取消Task没有任何意义，因为在旋转之后，你最终还是需要重新启动Task。或者是你不想重启Task，因为状况在一些地方以非幕等的方式发生了突变(because it mutates some state somewhere in a non-idempotent way),但是你确实想要得到结果，因为这样你就可以更新UI来反映这种情况。</span><br><span class="line"></span><br><span class="line">如果你专门的做一个只读的加载操作，你可以使用AsyncTaskLoader去解决这个问题。但是对于标准的Android方式来说，它还是很沉重，因为缺少错误处理，在Activity中没有缓存，还有很多独有的其他怪癖。</span><br><span class="line"></span><br><span class="line">###组合的多个Web Server调用</span><br><span class="line">现在，假如说我们已经想办法把上面的问题都解决了，但是我们现在需要做一些连续的网络请求，每一个请求都需要基于前一个请求的结果。或者是，我们想做一些并发的网络请求，然后把结果合并在一起发送到UI线程，但是，再次抱歉，AsyncTask在这里帮不到你。</span><br><span class="line"></span><br><span class="line">一旦你开始做这样的事情，随着更多的复杂线程模型的增长，之前的问题会导致处理这样的事情非常的痛苦和苍白无力。如果想要这些线程一起运行，要么你就让它们单独运行，然后回调，要么让它们在一个后台线程中同步运行，最后复制组成不同。(To chain calls together, you either keep them separate and end up in callback hell, or run them synchronously together in one background task end up duplicating work to compose them differently in other situations.)</span><br><span class="line"></span><br><span class="line">如果要并行运行，你必须创建一个自定义的executor然后传递给AsyncTaskTask，因为默认的AsyncTask不支持并行。并且为了协调并行线程，你需要使用像是CountDownLatchs, Threads, Executors 和 Futures去降低更复杂的同步模式。</span><br><span class="line"></span><br><span class="line">###可测试性</span><br><span class="line">抛开这些不说，如果你喜欢测试你的代码，AsyncTask并不能给你带来什么帮助。如果我们不做额外的工作，测试AsyncTask非常困难，它很脆弱并且难以维持。这是一篇有关如何成功测试AsyncTask的[帖子](http:<span class="comment">//www.making-software.com/2012/10/31/testable-android-asynctask/)。</span></span><br><span class="line"></span><br><span class="line">##更好的解决方案：RxJava’s Observable</span><br><span class="line"></span><br><span class="line">幸运的是，一旦我们决定使用RxJava依赖库的时候，我们讨论的这些问题就都迎刃而解了。下面我们看看它能为我们做什么。</span><br><span class="line"></span><br><span class="line">下面我们将会使用Observables写一个请求代码来替代上面的AsyncTask方式。(如果你使用Retrofit，那么你应该很容易使用，其次它还支持Observable 返回值，并且它工作在一个后台的线程池，无需你额外的工作)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">	webService.doSomething(someData)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(</span><br><span class="line">        result -&gt; resultText.setText(<span class="string">"It worked!"</span>)),</span><br><span class="line">        e -&gt; handleError(e)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="错误处理">错误处理</h3><p>你可能会注意到，没有做额外的工作，我们已经处理了AsyncTask不会处理的成功和错误的情况，并且我们写了很少的代码。你看到的额外的组件是我们想要Observer 在UI主线程中处理的结果。这样可以让我们前进一点点。并且如果你的webService对象不想在后台线程中运行，你也可以在这里通过使用.subscribeOn(…) 声明。(注意：这些例子是使用Java 8的lambda语法，使用<a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="external">Retrolambda</a>就可以在Android项目中进行使用了，但在我看来，这样做的回报是高于风险的，和写这篇文章相比，我们更喜欢在我们的项目中使用。)</p>
<h3 id="Activity和Fragment的生命周期">Activity和Fragment的生命周期</h3><p>现在，我们想在这里利用RxAndroid解决上面提到的生命周期的问题，我们不需要指定mainThread() scheduler(顺便说一句，你只需要导入RxAndroid)。就像下面这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AppObservable.bindFragment(<span class="keyword">this</span>, webService.doSomething(someData))</span><br><span class="line">   .subscribe(</span><br><span class="line">       result -&gt; resultText.setText(<span class="string">"It worked!"</span>)),</span><br><span class="line">       e -&gt; handleError(e)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p>我通常的做法是在应用的Base Fragment里面创建一个帮助方法来简化这一点，你可以参考我维护的一个<a href="https://github.com/rosshambrick/standardlib/blob/master/src/main/java/com/rosshambrick/standardlib/RxFragment.java" target="_blank" rel="external">Base RxFragment</a> 获得一些指导。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bind(webService.doSomething(someData))</span><br><span class="line">   .subscribe(</span><br><span class="line">       result -&gt; resultText.setText(<span class="string">"It worked!"</span>)),</span><br><span class="line">       e -&gt; handleError(e)</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p>如果我们的Activity或者是Fragment不再是可见状态，那么AppObservable.bindFragment()可以在调用链中插入一个垫片，来阻止onNext()运行。如果当Task试图运行的时候，Activity、Fragment是不可达状态，subscription 将会取消订阅并且停止运行，所以不会存在空指针的风险，程序也不会崩溃。一个需要注意的是，当我们离开Activity和Fragment时，我们会暂时或者是永久的泄露，这取决于问题中的Observable 的行为。所以在bind()方法中，我也会调用LifeCycleObservable机制，当Fragment销毁的时候自动取消。这样做的好处是一劳永逸。</p>
<p>所以，这解决了首要的两个问题，但是下面这一个才是RxJava大发神威的地方。</p>
<h3 id="组合的多个Web_Server调用">组合的多个Web Server调用</h3><p>在这里我不会详细的说明，因为这是一个<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">复杂的问题</a>，但是通过使用Observables，你可以用非常简单和易于理解的方式完成复杂的事情。这里是一个链式Web Service调用的例子，这些请求互相依赖，在线程池中运行第二批并行调用，然后在将结果返回给Observer之前，对数据进行合并和排序。为了更好的测量，我甚至在里面放置了一个过滤器。所有的业务逻辑都在下面这短短五行代码里面…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Observable&lt;List&lt;CityWeather&gt;&gt; getWeatherForLargeUsCapitals() &#123;</span><br><span class="line">   <span class="keyword">return</span> cityDirectory.getUsCapitals() </span><br><span class="line">       .flatMap(cityList -&gt; Observable.from(cityList))</span><br><span class="line">       .filter(city -&gt; city.getPopulation() &gt; <span class="number">500</span>,<span class="number">000</span>)</span><br><span class="line">       .flatMap(city -&gt; weatherService.getCurrentWeather(city)) <span class="comment">//each runs in parallel</span></span><br><span class="line">       .toSortedList((cw1,cw2) -&gt; cw1.getCityName().compare(cw2.getCityName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转时的缓存(或是其他情况)">旋转时的缓存(或是其他情况)</h3><p>既然这是一个加载的数据，那么我们可能需要将数据进行缓存，这样当我们旋转设备的时候，就不会触发再次调用全部web service的事件。一种实现的方式是保留Fragment，并且保存一个对Observable 的缓存的引用，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">    weatherObservable = weatherManager.getWeatherForLargeUsCapitals().cache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(...)</span><br><span class="line">    bind(weatherObservable).subscribe(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在旋转之后，订阅者的缓存实例就会立即发出和第一次请求相同的请求，防止真实的Web Service请求发生。</p>
<p>如果你想要避免缓存的Fragment(并且有很充足的理由去避免它)，我们可以通过使用AsyncSubject实现缓存。无论何时被订阅，AsyncSubject 都会重新发出最后的事件。或者我们可以使用BehaviorSubject获得最后的值和新值改变整个应用程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">WeatherListFragment.<span class="function">java </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated()</span><br><span class="line">   bind(weatherManager.getWeatherForLargeUsCapitals()).subscribe(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WeatherManager.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Observable&lt;List&lt;CityWeather&gt;&gt; getWeatherForLargeUsCapitals() &#123;</span><br><span class="line">   <span class="keyword">if</span> (weatherSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">       weatherSubject = AsyncSubject.create();</span><br><span class="line"></span><br><span class="line">       cityDirectory.getUsCapitals() </span><br><span class="line">           .flatMap(cityList -&gt; Observable.from(cityList))</span><br><span class="line">           .filter(city -&gt; city.getPopulation() &gt; <span class="number">500</span>,<span class="number">000</span>)</span><br><span class="line">           .flatMap(city -&gt; weatherService.getCurrentWeather(city))</span><br><span class="line">           .toSortedList((cw1,cw2) -&gt; cw1.getCityName().compare(cw2.getCityName()))</span><br><span class="line">           .subscribe(weatherSubject);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> weatherSubject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为“缓存”是由Manager单独管理的，它不会与Fragment/Activity的周期绑定，并且在Activity/Fragment中将持续存在。如果你想强迫刷新基于以类似的方式来保留Fragment缓存实例的生命周期事件，你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate()</span><br><span class="line">   <span class="keyword">if</span> (savedInstanceState == <span class="keyword">null</span>) &#123;</span><br><span class="line">       weatherManager.invalidate(); <span class="comment">//invalidate cache on fresh start</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这件事情的伟大之处在于，它不像是Loaders，我们可以很灵活的缓则缓存很多Activity和Services中的结果。只需要去掉oncreate()中的invalidate()调用，并让你的Manager对象决定何时发出新的气象数据就可以了。可能是一个Timer，或者是用户定位改变，或者是其他任何时刻，这真的没关系。你现在可以控制什么时候如何去更新缓存和重新加载。并且当你的缓存策略发生改变的时候，Fragment和你的Manager对象之间的接口不需要进行改变。它只不过是一个 List<weatherdata>的Observer。</weatherdata></p>
<h3 id="可测试性">可测试性</h3><p>测试是我们想要实现干净、简单的最后一个挑战。(让我们忽略一个事实，在测试期间,我们可能想要模拟出实际的Web服务。这样做很简单，下面通过一个接口注入到那些依赖你可能已经正在做的标准模式中。)</p>
<p>幸运的是，Observables给我们一个简单的方式来将一个异步方法变成同步，你要做的就是使用toblocking()方法。我们看一个测试例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List results = getWeatherForLargeUsCapitals().toBlocking().first();</span><br><span class="line">assertEquals(<span class="number">12</span>, results.size());</span><br></pre></td></tr></table></figure>
<p>就像这样，我们没有必要去使用Futures或者是CountDownLatchs让做一些脆弱的操作，比如线程睡眠或者是让我们的测试变得很复杂，我们的测试现在是简单、干净、可维护的。</p>
<h2 id="结论">结论</h2><p>更新：我已经创建了一对简单的项目来演示<a href="https://github.com/rosshambrick/AsyncExamples" target="_blank" rel="external">AsyncTask风格</a>和<a href="https://github.com/rosshambrick/rain-or-shine" target="_blank" rel="external">AsyncTaskLoader</a>风格。</p>
<p>RxJava，你值得拥有。我们使用rx.Observable来替换AsyncTask和AsyncTaskLoader可实现更加强大和清晰的代码。使用RxJava Observables很快乐，而且我期待能够呈现更多的Android问题的解决方案。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://stablekernel.com/blog/replace-asynctask-asynctaskloader-rx-observable-rxjava-android-patterns/" target="_blank" rel="external">Replace AsyncTask and AsyncTaskLoader with rx.Observable – RxJava Android Patterns</a></li>
<li>译者 : <a href="https://github.com/ZhaoKaiQiang" target="_blank" rel="external">ZhaoKaiQiang</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在网上有很多关于RxJava入门指南的帖子，其中一些是基于Android环境的。但是，我想到目前为止，很多人只是喜欢他们所看到的这些，当要解决在他们的Android项目中出现的具体问题时，他们并不知道如何或者是为什么要使用RxJava。在这一系列的文章中，我想要探索在我工作过的一些依赖于RxJava架构的Android项目中的模式。<br>]]>
    
    </summary>
    
      <category term="AsyncTask" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/AsyncTask/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>