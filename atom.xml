<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Android博客]]></title>
  <subtitle><![CDATA[读万卷书]]></subtitle>
  <link href="http://likebamboo.com/AndroidBlog/atom.xml" rel="self"/>
  <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//"/>
  <updated>2015-07-11T09:10:16.000Z</updated>
  <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//</id>
  
  <author>
    <name><![CDATA[likebamboo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MVP在Android平台上的应用]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/introduction-to-model-view-presenter-on-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/introduction-to-model-view-presenter-on-android/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:10:16.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章向你介绍Android平台上的MVP模式，从一个简浅的例子开始实践之路。文章也会介绍一个一个库让你在Android平台上轻松的实现MVP<br><a id="more"></a></p>
<h2 id="简单吗？我怎么才能从中受益？">简单吗？我怎么才能从中受益？</h2><h3 id="什么是MVP？">什么是MVP？</h3><ul>
<li><strong>View</strong>层主要是用于展示数据并对用户行为做出反馈。在Android平台上，他可以对应为Activity, Fragment,View或者对话框。</li>
<li><strong>Model</strong>是数据访问层，往往是数据库接口或者服务器的API。</li>
<li><strong>Presenter</strong>层可以想View层提供来自数据访问层的数据，除此以外，他也会处理一些后台事务。</li>
</ul>
<p>在Android平台上，MVP可以将后台事务从Activity/View/Fragment中分离出来，让它们独立于大部分生命周期事件。这样，一个应用将会变得简单， 整个应用可靠性可以提高10倍，应用的代码将会变短, 代码的可维护性提高，开发者也为此感到高兴。</p>
<h3 id="Android为什么需要MVP">Android为什么需要MVP</h3><h4 id="理由1：尽量简单">理由1：尽量简单</h4><p>如果你还有读过这篇文章，请阅读它：<a href="https://people.apache.org/~fhanik/kiss.html" target="_blank" rel="external">Kiss原则</a>（Keep It Stupid Simple）</p>
<ul>
<li>大部分的安卓应用只使用View-Model结构</li>
<li>程序员现在更多的是和复杂的View打交道而不是解决业务逻辑。</li>
</ul>
<p>当你在应用中只使用Model-View时，到最后，你会发现“所有的事物都被连接到一起”。<br><img src="http://konmik.github.io/images/mvp_everything_is_connected_with_everything.png" alt=""></p>
<p>如果这张图看上去还不是很复杂，那么请你想象一下以下情况：每一个View在任意一个时刻都有可能出现或者消失。不要忘记View的保存和恢复，在临时的view上挂载一个后台任务。</p>
<p>“所有的事物都被连接到一起”的替代品是一个万能对象(god object)。</p>
<p><img src="http://konmik.github.io/images/mvp_a_god_object.png" alt=""></p>
<p>god object是十分复杂的，他的每一个部分都不能重复利用，无法轻易的测试、或者调试和重构。</p>
<h3 id="With_MVP">With MVP</h3><h3 id="使用MVP">使用MVP</h3><p><img src="http://konmik.github.io/images/mvp_mvp.png" alt=""></p>
<p>复杂的任务被分成细小的任务，并且很容易解决。越小的东西，bug越少，越容易debug，更好测试。在MVP模式下的View层将会变得简单，所以即便是他请求数据的时候也不需要回调函数。View逻辑变成十分直接。</p>
<p>理由2：后台任务</p>
<p>当你编写一个Actviity、Fragment、自定义View的时候，你会把所有的和后台任务相关的方法写在一个静态类或者外部类中。这样，你的Task不再和Activity联系在一起，这既不会导致内存泄露，也不依赖于Activity的重建。</p>
<p>这里有若干种方法处理后台任务，但是它们的可靠性都不及MVP。</p>
<h3 id="为什么它是可行的？">为什么它是可行的？</h3><p>这里有一张表格，用于展示在configuration改变、Activity 重启、Out-Of-Memory时，不同的应用部分会发生什么？</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">情景 1</th>
<th style="text-align:center">情景 2</th>
<th style="text-align:center">情景 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">配置改变</td>
<td style="text-align:center">Activity 重启</td>
<td style="text-align:center">进程重启</td>
</tr>
<tr>
<td style="text-align:center">对话框</td>
<td style="text-align:center">重置</td>
<td style="text-align:center">重置</td>
<td style="text-align:center">重置</td>
</tr>
<tr>
<td style="text-align:center">Activity, View, Fragment</td>
<td style="text-align:center">保存/恢复</td>
<td style="text-align:center">保存/恢复</td>
<td style="text-align:center">保存/恢复</td>
</tr>
<tr>
<td style="text-align:center">Fragment with setRetainInstance(true)</td>
<td style="text-align:center">无变化</td>
<td style="text-align:center">保存/恢复</td>
<td style="text-align:center">保存/恢复</td>
</tr>
<tr>
<td style="text-align:center">Static variables and threads</td>
<td style="text-align:center">无变化</td>
<td style="text-align:center">无变化</td>
<td style="text-align:center">重置</td>
</tr>
</tbody>
</table>
<p>情景 1: 当用户切换屏幕、更改语言设置或者链接外部的模拟器时，往往意味着设置改变。 相关更多请阅读<a href="http://developer.android.com/reference/android/R.attr.html#configChanges" target="_blank" rel="external">这里</a>。</p>
<p>情景 2:Activity的重启发生在当用户在开发者选项中选中了“Don’t keep activities”（“中文下为 不保留活动”）的复选框，然后另一个Activity在最顶上的时候。</p>
<p>情景 3: 进程的重启发生在应用运行在后台，但是这个时候内存不够的情况下。</p>
<h3 id="总结">总结</h3><p>现在你可以发现，一个调用了setRetainInstance(true)的Fragment也不奏效，我们还是需要保存/恢复fragment的状态，所以为简化问题，我们暂不考虑上述情况的Fragment。<a href="http://en.wikipedia.org/wiki/Occam&#39;s_razor" target="_blank" rel="external">Occam’s razor</a></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">配置改变,   Activity重启</th>
<th style="text-align:center">进程重启</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Activity, View, Fragment, DialogFragment</td>
<td style="text-align:center">保存/恢复</td>
<td style="text-align:center">保存/恢复</td>
</tr>
<tr>
<td style="text-align:center">Static variables and threads</td>
<td style="text-align:center">无变化</td>
<td style="text-align:center">重置</td>
</tr>
</tbody>
</table>
<p>现在，看上去更舒服了，我们只需要写两段代码为了恢复应用：</p>
<ul>
<li><p>保存/恢复 for Activity, View, Fragment, DialogFragment;</p>
</li>
<li><p>重启后台请求由于进程重启</p>
</li>
</ul>
<p>第一个部分,用Android的API可以实现。第二个部分，就是Presenter的作用了。Presenter将会记住有哪些请求需要执行，当进程在执行过程中重启时，Presenter将会出现执行它们。</p>
<h5 id="一个简单的例子(no_MVP)">一个简单的例子(no MVP)</h5><p>这个例子用于从远程服务器加载数据并呈现，当发生异常时，会通过Toast提示。</p>
<p>我推荐使用<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>构建Presenter，因为这个库更容易控制数据流。</p>
<p>我想对创造如此简单的API的伙计说声谢谢，我把它用于<a href="http://www.icndb.com/" target="_blank" rel="external">The Internet Chuck Norris Database</a></p>
<p>无MVP的<a href="https://github.com/konmik/MVPExamples/tree/master/example00" target="_blank" rel="external">例子00</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"Chuck Norris"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayAdapter&lt;ServerAPI.Item&gt; adapter;</span><br><span class="line">    <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ListView listView = (ListView)findViewById(R.id.listView);</span><br><span class="line">        listView.setAdapter(adapter = <span class="keyword">new</span> ArrayAdapter&lt;&gt;(<span class="keyword">this</span>, R.layout.item));</span><br><span class="line">        requestItems(DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestItems</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        unsubscribe();</span><br><span class="line">        subscription = App.getServerAPI()</span><br><span class="line">            .getItems(name.split(<span class="string">"\\s+"</span>)[<span class="number">0</span>], name.split(<span class="string">"\\s+"</span>)[<span class="number">1</span>])</span><br><span class="line">            .delay(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;ServerAPI.Response&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(ServerAPI.Response response)</span> </span>&#123;</span><br><span class="line">                    onItemsNext(response.items);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    onItemsError(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsNext</span><span class="params">(ServerAPI.Item[] items)</span> </span>&#123;</span><br><span class="line">        adapter.clear();</span><br><span class="line">        adapter.addAll(items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, throwable.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subscription != <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscription.unsubscribe();</span><br><span class="line">            subscription = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有经验的开发者会注意到这个例子有以下不妥：</p>
<p>当用户翻转屏幕时候会开始请求，应用发起了过多的请求，将会是屏幕在切换的时候呈现空白的界面。</p>
<p>当用户频繁的切换屏幕，这将会造成内存泄露，请求运行时，每一个回调将会持有MainActivity的引用，让其保存在内存中。因此引起的OOM和应用反应迟缓，会引发应用的Crash。</p>
<p>MVP模式下的<a href="https://github.com/konmik/MVPExamples/tree/master/example01" target="_blank" rel="external">例子 01</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"Chuck Norris"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerAPI.Item[] items;</span><br><span class="line">    <span class="keyword">private</span> Throwable error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MainActivity view;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        App.getServerAPI()</span><br><span class="line">            .getItems(DEFAULT_NAME.split(<span class="string">"\\s+"</span>)[<span class="number">0</span>], DEFAULT_NAME.split(<span class="string">"\\s+"</span>)[<span class="number">1</span>])</span><br><span class="line">            .delay(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;ServerAPI.Response&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(ServerAPI.Response response)</span> </span>&#123;</span><br><span class="line">                    items = response.items;</span><br><span class="line">                    publish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                    error = throwable;</span><br><span class="line">                    publish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTakeView</span><span class="params">(MainActivity view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line">        publish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (items != <span class="keyword">null</span>)</span><br><span class="line">                view.onItemsNext(items);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error != <span class="keyword">null</span>)</span><br><span class="line">                view.onItemsError(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从严格意义上来说，MainPresenter有三个事件处理线程： <em>onNext</em>, <em>onError</em>, <em>onTakeView</em>。他们调用了<code>publish()</code>方法，<em>onNext</em> 或 <em>onError</em>的值将会在MainActivity中发布，而不是由onTakeView提供。      </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayAdapter&lt;ServerAPI.Item&gt; adapter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MainPresenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ListView listView = (ListView)findViewById(R.id.listView);</span><br><span class="line">        listView.setAdapter(adapter = <span class="keyword">new</span> ArrayAdapter&lt;&gt;(<span class="keyword">this</span>, R.layout.item));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (presenter == <span class="keyword">null</span>)</span><br><span class="line">            presenter = <span class="keyword">new</span> MainPresenter();</span><br><span class="line">        presenter.onTakeView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        presenter.onTakeView(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (isFinishing())</span><br><span class="line">            presenter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsNext</span><span class="params">(ServerAPI.Item[] items)</span> </span>&#123;</span><br><span class="line">        adapter.clear();</span><br><span class="line">        adapter.addAll(items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, throwable.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainActivty构建了MainPresenter，将其维持在onCreate/onDestroy周期外，MainActivity持有MainPresenter的静态引用，所以每一个进程由于OOM重启时，MainActivity可以确认Presenter是否仍然存在，必要时创建。</p>
<p>当然，确认和使用静态变量可能是代码变得臃肿，稍后我们会告诉你如何好看些：。:)</p>
<h4 id="重要思路：">重要思路：</h4><ul>
<li>示例程序不会在每次切换屏幕的时候都开始一个新的请求</li>
<li>当进程重启时，示例程序将会重新加载数据。</li>
<li>当MainActivity销毁时，MainPresenter不会持有MainActivity的引用，因此不会在切换屏幕的时候发生内存泄漏，而且没必要去unsubscribe请求。</li>
</ul>
<h3 id="Nucleus"><a href="https://github.com/konmik/nucleus" target="_blank" rel="external">Nucleus</a></h3><p>Nucleus是我从<a href="https://github.com/square/mortar" target="_blank" rel="external">Mortar</a>和 Keep It Stupid Simple 这篇文章得到的灵感而建立的库。</p>
<p>它有以下特征：</p>
<ul>
<li><p>它支持在View/Fragment/Activity的Bundle中保存/恢复Presenter的状态，一个Presenter可以保存请求参数，以便之后重启它们</p>
</li>
<li><p>只需要一行代码，它就可以直接将请求结果或者错误反馈给View，所以你不需要写<code>!= null</code>之类的核对代码。</p>
</li>
<li><p>它允许你可以有多个持有Presenter的实例。 不过你不能在用<a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a>实例化的presenter中这样使用(传统方法).</p>
</li>
<li><p>它可以用一行代码快速的将View和Presenter绑定。</p>
</li>
<li><p>它提供一些现成的基类，例如: <code>NucleusView</code>, <code>NucleusFragment</code>, <code>NucleusSupportFragment</code>, <code>NucleusActivity</code>. 你可以将他们的代码拷贝出来改造出一个自己的类以利用Nucleus的presenter。</p>
</li>
<li><p>支持在进程重启后，自动重新发起请求，在<code>onDestroy</code>方法中，自动的退订RxJava的订阅。</p>
</li>
<li><p>最后，它简洁明了，每一个开发者都会理解，Presenter的驱动只用了180行代码，RxJava用了230行代码。</p>
</li>
</ul>
<p>使用了<a href="https://github.com/konmik/nucleus" target="_blank" rel="external">Nucleus</a> 的<a href="https://github.com/konmik/MVPExamples/tree/master/example02" target="_blank" rel="external">例 02</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">RxPresenter</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"Chuck Norris"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedState);</span><br><span class="line"></span><br><span class="line">        App.getServerAPI()</span><br><span class="line">            .getItems(DEFAULT_NAME.split(<span class="string">"\\s+"</span>)[<span class="number">0</span>], DEFAULT_NAME.split(<span class="string">"\\s+"</span>)[<span class="number">1</span>])</span><br><span class="line">            .delay(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .compose(<span class="keyword">this</span>.&lt;ServerAPI.Response&gt;deliverLatestCache())</span><br><span class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;ServerAPI.Response&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(ServerAPI.Response response)</span> </span>&#123;</span><br><span class="line">                    getView().onItemsNext(response.items);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                    getView().onItemsError(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@RequiresPresenter</span>(MainPresenter.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">NucleusActivity</span>&lt;<span class="title">MainPresenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayAdapter&lt;ServerAPI.Item&gt; adapter;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        ListView listView = (ListView)findViewById(R.id.listView);</span><br><span class="line">        listView.setAdapter(adapter = <span class="keyword">new</span> ArrayAdapter&lt;&gt;(<span class="keyword">this</span>, R.layout.item));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsNext</span><span class="params">(ServerAPI.Item[] items)</span> </span>&#123;</span><br><span class="line">        adapter.clear();</span><br><span class="line">        adapter.addAll(items);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, throwable.getMessage(), Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你看到的，跟上一个代码相比，这个例子十分简洁。Nucleus 可以构造/销毁/变成 Presenter, 向Presenter中添加/分离 View ，并且自动向附加的view发送请求。。</p>
<p><code>MainPresenter</code>的代码比较短，因为它使用<code>deliverLatestCache（）</code>的操作，延迟了由一个数据源发出所有的数据和错误，直到View可用。它还把数据缓存在内存中，以便它可以在Configuration change时可以被重用。</p>
<p><code>MainActivity</code>的代码比较短，因为主Presenter的创作由<code>NucleusActivity</code>管理。当你需要绑定一个Presenter的时候，只需要添加注解<code>@RequiresPresenter（MainPresenter.class）</code>。</p>
<p>警告！注释！在Android中，如果你使用注解，这是最好检查以下这么做会不会降低性能。以我使用的’Galaxy S`（2010年设备）为例，处理此批注耗时不超过0.3毫秒。只在实例化view的时候才会发生，因此注解在这里对性能的影响可以忽略。</p>
<h4 id="更多例子">更多例子</h4><p>一个扩展的例子,带有请求参数的Presenter：<a href="https://github.com/konmik/nucleus/tree/master/nucleus-example" target="_blank" rel="external">Nucleus Example</a>。</p>
<p>带有单元测试的例子： <a href="https://github.com/konmik/nucleus/tree/master/nucleus-example-with-tests" target="_blank" rel="external">Nucleus Example With Tests</a></p>
<h4 id="deliverLatestCache()_方法"><code>deliverLatestCache()</code> 方法</h4><p>这个RxPresenter的工具方法有三个变种：</p>
<ul>
<li><p><code>deliver()</code> will just delay all onNext, onError and onComplete emissions until a View becomes available. Use it for cases when you’re doing a one-time request, like logging in to a web service. <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onCreate(android.os.Bundle" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>deliver()</code>只是推迟onNext、onError、onComplete的调用，直到视图有效。使用它，你只需要一次请求，就像发起登陆web服务一样。<a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onCreate(android.os.Bundle" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>deliverLatest（）</code>当有新的的onNext值，将会舍弃原有的值，如果你有可更新的数据源，这将让你去除那些不需要的数据。<a href="http://konmik.github.io/nucleus/nucleus/presenter/RxPresenter.html#deliverLatest" target="_blank" rel="external">Javadoc</a></p>
</li>
<li><p><code>deliverLatestCache（）</code>，和<code>deliverLatest（）</code>一样，但除了它会在内存中保存最新的结果外，当View的另一个实例可用（例如：在配置更改的时候）时，还是会触发一次。如果你不想组织请求在你的View中的保存/恢复事务（比方说，结果太大或者不能很容易地保存在Bundle中），这个方法可以让用户体验更好。<a href="http://konmik.github.io/nucleus/nucleus/presenter/RxPresenter.html#deliverLatestCache" target="_blank" rel="external">Javadoc</a></p>
</li>
</ul>
<h4 id="Presenter的生命周期">Presenter的生命周期</h4><p>相比Android组件，Presenter的生命周期更加简短。</p>
<ul>
<li><p><code>void onCreate(Bundle savedState)</code> - 每一个Presenter构造时 .  <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onCreate(android.os.Bundle" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>void onDestroy()</code> - 用户离开View时调用 . <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onDestroy(" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>void onSave(Bundle state)</code> - 在View的<code>onSaveInstanceState</code>方法中调用，用于持有Presenter的状态.  <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onSave(android.os.Bundle" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>void onTakeView(ViewType view)</code> - 在Activity或者Fragment的<code>onResume()</code>方法中或者<code>android.view.View#onAttachedToWindow()</code>调用.  <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onTakeView(ViewType" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>void onTakeView(ViewType view)</code> - 在Activity或者Fragment的<code>onResume()</code>方法中或者<code>android.view.View#onAttachedToWindow()</code>调用.  <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onTakeView(ViewType" target="_blank" rel="external">Javadoc</a>)</p>
</li>
<li><p><code>void onDropView()</code> -  在Activity或者Fragment的<code>onPause()</code>方法中或者<code>android.view.View#onDetachedFromWindow()</code>调用. <a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onDropView" target="_blank" rel="external">Javadoc</a></p>
</li>
</ul>
<h4 id="View的回收与View栈">View的回收与View栈</h4><p>通常来说,你的view（比如fragment或者自定义的view）在用户的交互过程中挂载与解挂（attached and detached）都是随机发生的。 这倒是不让presenter在view每次解挂（detached）的时候都销毁的一个启发。你可以在任何时候挂载与解挂view，但是presenter可以在这些行为中幸存下来，继续后台的工作。</p>
<p>这里还存在着一个关于View回收的问题：一个Fragment在Configuration change或者从stack中弹出的情况下，不知道自身有没有解挂（detached）。</p>
<p>默认只在Activity处于finish时，才在调用View的<code>onDetachedFromWindow()</code>/<code>onDestroy()</code> 销毁Presenter。</p>
<p>所以，当你在常规的Activity生命周期内，销毁View，你需要给给View一个销毁Presenter的信号。在这里，公有方法<code>NucleusLayout.destroyPresenter()</code> and <code>NucleusFragment.destroyPresenter()</code>就派上用场了。</p>
<p>例如，在我的项目中，下面的是我如何进行FragmentManager的<code>pop()</code>操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fragment = fragmentManager.findFragmentById(R.id.fragmentStackContainer);</span><br><span class="line">fragmentManager.popBackStackImmediate();</span><br><span class="line"><span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> NucleusFragment)</span><br><span class="line">    ((NucleusFragment)fragment).destroyPresenter();</span><br></pre></td></tr></table></figure>
<p>在进行<em>replace</em>Fragment栈和对处于底部的Fragment进行<em>push</em>操作时，你可能需要进行相同的操作。</p>
<p>在View从Activity解挂（detached）时，您可能会选择摧毁Presenter来避免问题的发生，但是，这将意味着当View解挂（detached）时，后台任务无法继续进行。</p>
<p>所以这一节的 “view recycling”完全留你你自己考虑，也许有一天我会找到更好的解决办法，如果你有一个办法，请告诉我。</p>
<h4 id="最佳实践">最佳实践</h4><p>在Presenter中保存你的请求参数。</p>
<p>规则很简单：Presenter的主要作用是管理请求。所以，View不应该自己处理或者重启请求。从View中，我们可以看见，后台事务不会消失，总是会返回结果或者错误，<em>而不是通过回调的方式</em>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">RxPresenter</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = DEFAULT_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedState);</span><br><span class="line">        <span class="keyword">if</span> (savedState != <span class="keyword">null</span>)</span><br><span class="line">            name = savedState.getString(NAME_KEY);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSave</span><span class="params">(@NonNull Bundle state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSave(state);</span><br><span class="line">        state.putString(NAME_KEY, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我推荐使用一个很棒的库<a href="https://github.com/frankiesardo/icepick" target="_blank" rel="external">Icepick</a>。在不使用运行时注解的前提下，它可以减少代码量，并简化应用程序逻辑 - 所有的事都在编译过程中已经处理好了。这个库和<a href="http://jakewharton.github.io/butterknife" target="_blank" rel="external">ButterKnife</a>搭配是个不错的选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainPresenter</span> <span class="keyword">extends</span> <span class="title">RxPresenter</span>&lt;<span class="title">MainActivity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Icicle</span> String name = DEFAULT_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedState);</span><br><span class="line">        Icepick.restoreInstanceState(<span class="keyword">this</span>, savedState);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSave</span><span class="params">(@NonNull Bundle state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSave(state);</span><br><span class="line">        Icepick.saveInstanceState(<span class="keyword">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你有不止一对请求参数，这个库在不使用运行时注解的前提下。您可以创建<code>BasePresenter</code>并把<em>Icepick</em>到该类中，所有的子类将会自动保存标有<code>@Icicle</code>这一注解的变量，而你将不再需要去实现<code>OnSave</code>。这也适用于保存Activity，Fragment，View的状态。</p>
<h4 id="在主线程中调用onTakeView进行即时查询Javadoc)">在主线程中调用<code>onTakeView</code>进行即时查询<a href="http://konmik.github.io/nucleus/nucleus/presenter/Presenter.html#onTakeView(ViewType" target="_blank" rel="external">Javadoc</a>)</h4><p>有时候，你要进行少量的数据查询，如从数据库中读取少量的数据。虽然你可以很容易地用Nucleus创建一个可重启的请求，你不必到处使用这个强大的工具。如果你在fragment创建的时候初始化一个后台请求，即使只有几毫秒，用户也会看到一会儿的空白屏。因此，为了使代码更短，用户体验更好，可以使用主线程。</p>
<h4 id="不要让Presenter控制你的View">不要让Presenter控制你的View</h4><p>这不是很好的工作方式 - 由于这种不自然的方式，应用程序逻辑变得太复杂。</p>
<p>自然的方式是操作流由用户发起，通过View，Presenter和Model，最后流向数据。毕竟，用户将使用应用,用户是控制应用程序的源头。因此，控制应该从用户开始而不是一些应用的内部结构。</p>
<p>从view，到presenter到model是很直接的形式，很容易书写这样的代码。你将得到以下序列： <strong>user -&gt; view -&gt; presenter -&gt; model -&gt; data</strong> 。但是，当控制流变成这样时: <strong>user -&gt; view -&gt; presenter -&gt; view -&gt; presenter -&gt; model -&gt; data</strong>，它只是违反KISS原则.</p>
<p>Fragments？不好意思它是违背了这种自然操作流程的。它们太复杂。这里是一个非常好讲诉Fragment的文章：<a href="http://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external">抨击Android的Fragment</a>。fragment的替代者<a href="https://github.com/square/flow" target="_blank" rel="external">Flow</a> 并没有简化多少东西。</p>
<h4 id="MVC">MVC</h4><p>如果你对MVC（模型-View-控制器）-不要去使用。模型-View-控制器和MVP完全不同，不能解决接口开发者面对的问题。</p>
<h4 id="What_is_MVC?">What is MVC?</h4><h4 id="什么是MVC?">什么是MVC?</h4><ul>
<li><p><strong>Model</strong>代表着应用程序的内部状态。它可以负责存储，当然也可以不考虑。</p>
</li>
<li><p><strong>View</strong>是唯一的与MVP相同的部分 - 它用于将模型呈现在屏幕上，应用程序的一部分。</p>
</li>
<li><p><strong>Controller</strong>表示输入装置，如键盘，鼠标或操纵杆。</p>
</li>
</ul>
<p>MVC在过去以键盘为驱动的应用中（比如游戏），是比较好的模式。没有窗口和图形用户界面的交互——应用接受输入(Controller),维持状态（Model），产生输出（View）。同样，数据和控制的关系是这样的。<strong>controller -&gt; model -&gt; view</strong>。这种模式是在Android绝对无用。</p>
<p>这里有一些关于MVC的困惑。人们（Web开发人员）觉得他们使用MVC，而实际上，他们使用的MVP。许多Android开发者认为Controller是用于控制View的，所以他们试图在创建View时，从视图（View）中提取视图逻辑，交由专门的控制器控制。我个人是没有看出这种架构的好处。</p>
<h4 id="在数据复杂的项目中使用固定的数据结构">在数据复杂的项目中使用固定的数据结构</h4><p>在这方面，<a href="https://github.com/google/auto/tree/master/value" target="_blank" rel="external">AutoValue</a>是十分好的库，在它的描述中，你会发现一大堆好处，我建议你阅读它。Android平台上还有一个接口：<a href="https://github.com/frankiesardo/auto-parcel" target="_blank" rel="external">AutoParcel</a>。其主要原因是，你可以四处传递，而不用关心是否在程序的某个地方被修改了。而且他们也是线程安全的。</p>
<h3 id="总结-1">总结</h3><p>试试MVP吧，然后告诉你的朋友。:)</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://konmik.github.io/introduction-to-model-view-presenter-on-android.html" target="_blank" rel="external">Introduction to Model-View-Presenter on Android</a></li>
<li>原文作者 : <a href="http://konmik.github.io/" target="_blank" rel="external">konmik</a></li>
<li>译文出自 : <a href="http://konmik.github.io/introduction-to-model-view-presenter-on-android.html" target="_blank" rel="external">  其他  http://konmik.github.io/introduction-to-model-view-presenter-on-android.html</a></li>
<li>译者 : <a href="https://github.com/MiJack" target="_blank" rel="external">MiJack</a>  </li>
<li>校对者: <a href="https://github.com/MiJack" target="_blank" rel="external">MiJack</a>  </li>
<li>状态 : 校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章向你介绍Android平台上的MVP模式，从一个简浅的例子开始实践之路。文章也会介绍一个一个库让你在Android平台上轻松的实现MVP<br>]]>
    
    </summary>
    
      <category term="MVP" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/MVP/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Android架构" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Android%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 进行单元测试难在哪-part4]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/how-to-make-our-android-apps-unit-testable-pt-2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/how-to-make-our-android-apps-unit-testable-pt-2/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:10:55.000Z</updated>
    <content type="html"><![CDATA[<p>在<strong><a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-11/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part3.md" target="_blank" rel="external">上一篇博文</a></strong>中，我给大家介绍了新的应用架构方式 - Square 大法，就像我之前说的，Square 大法是 Square 用于使 Fragment 内的业务逻辑能够进行单元测试的通用方法，我还给大家展示了如何使用 Square 大法重构 Google 的 IOSched 应用的 SessionCalendarService 类，使得对 SessionCalendarService 类内的业务逻辑进行单元测试由几乎不可能变为可行。而在今天的这篇博文中，我会和大家一起继续探索 Square 大法，让我们对应用的 UI 组件进行单元测试成为可能，也让测试变得容易。<br><a id="more"></a></p>
<h2 id="这篇博文有“依赖”">这篇博文有“依赖”</h2><p>将 Sqaure 大法应用到 App 的 UI 组件中（例如 Activity 和 Fragment） 比起将它应用到无 UI 的应用中要复杂一些，造成这种情况的根源正好与我们重构代码的核心方法相关联，解决了这些额外的复杂性问题，我们也就能够改变对 UI 组件进行单元测试时需要使用的预测试状态，以及修改测试后状态。如果你听到“预测试状态”和“测试后状态”后感觉一头雾水，或者觉得有一点点印象却不记得具体是什么意思的话，最好复习复习我之前写的<code>[Android 进行单元测试难在哪-part1](https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-9/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part1.md)</code>。如果你清楚地理解这两个概念的话，确保你知道 SessionDetailActivity 干了啥。为了学习该如何将 Square 大法应用到应用的 UI 组件类中，我们将重构 SessionDetailActivity 类的代码，使我们能够对类中的 onStop() 方法中的业务逻辑进行单元测试。</p>
<p>开始之前我在唠叨几句吧，如果你有了解过 MVP 模式的话对你理解用 Square 大法重构应用 UI 组件大有裨益，不过呢，由于 Square 已经写了一篇非常精彩的<a href="https://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external">博文</a>介绍 MVP 模式了，我就不再给大家介绍啦，有兴趣的话看 Square 写的博文就好了。如果你在学习 MVP 模式的时候觉得很难理解与 View 相关的操作，不妨看看我之前写的一篇<a href="http://philosophicalhacker.com/2015/04/05/dont-call-it-mvp/" target="_blank" rel="external">博文</a>，这篇博文能帮你区分进行 Android 开发时我们使用的 View 和 MVP 模式中的“View”。除此以外，我在这篇博文中将 Presenter 用于更新应用界面显示的对象称为 “ViewTranslator” 而不是 “View”。</p>
<h2 id="用_Square_大法重构应用_UI_组件类">用 Square 大法重构应用 UI 组件类</h2><p>虽然用 Square 大法重构应用的 UI 组件可能会更复杂些，但我们的重构策略始终没有发生变化：抽取出应用组件类中的业务逻辑（例如 Activity，Fragment，Service），并将业务逻辑放到我之前说的被进行了依赖注入的“业务对象”中，也就是与 Android 无关接口的 Android 特定实现。</p>
<p>下面是重构后的 onStop() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (mInitStarred != mStarred) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UIUtils.getCurrentTime(<span class="keyword">this</span>) &lt; mSessionStart) &#123;</span><br><span class="line">            <span class="comment">// Update Calendar event through the Calendar API on Android 4.0 or new versions.</span></span><br><span class="line">            Intent intent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line">                <span class="comment">// Set up intent to add session to Calendar, if it doesn't exist already.</span></span><br><span class="line">                intent = <span class="keyword">new</span> Intent(SessionCalendarService.ACTION_ADD_SESSION_CALENDAR,</span><br><span class="line">                        mSessionUri);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_START,</span><br><span class="line">                        mSessionStart);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_END,</span><br><span class="line">                        mSessionEnd);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_ROOM, mRoomName);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_TITLE, mTitleString);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Set up intent to remove session from Calendar, if exists.</span></span><br><span class="line">                intent = <span class="keyword">new</span> Intent(SessionCalendarService.ACTION_REMOVE_SESSION_CALENDAR,</span><br><span class="line">                        mSessionUri);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_START,</span><br><span class="line">                        mSessionStart);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_END,</span><br><span class="line">                        mSessionEnd);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_TITLE, mTitleString);</span><br><span class="line">            &#125;</span><br><span class="line">            intent.setClass(<span class="keyword">this</span>, SessionCalendarService.class);</span><br><span class="line">            startService(intent);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line">                setupNotification();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我之前提到的，这段代码存在一个问题：代码并没有通过被注入到 SessionDetailActivity 的依赖中的方法启动 SessionCalendarService。那我们现在就用 Square 大法来解决这个问题。首先，我们将业务逻辑抽取出来，并放入业务对象中，Square 的工程师们为这个在 Activity（或 Fragment，或其他……）中使用的业务对象起了一个名字 —— “Presenter”。</p>
<p>Presenter 负责用 Model 中的数据更新 View，为了使单元测试在 Presenter 中是可行的，这就意味着 Model 和 View 都必须是注入到 Presenter 中的依赖。也正是这三个对象的组合使用构成了我们所说的 MVP 架构模式。</p>
<p>下面就是 SessionDetailPresenter 中与 onStop() 方法等价的实现啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDetailViewPresenter</span> <span class="keyword">implements</span> <span class="title">RepositoryManagerCallbacks</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionDetailViewPresenter</span><span class="params">(SessionDetailView sessionDetailView,</span><br><span class="line">                                      RepositoryManager loaderManager,</span><br><span class="line">                                      ServiceStarter serviceStarter,</span><br><span class="line">                                      <span class="keyword">long</span> calendarId</span><br><span class="line">                                      )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        mSessionDetailView = sessionDetailView;</span><br><span class="line">        mLoaderManager = loaderManager;</span><br><span class="line">        mServiceStarter = serviceStarter;</span><br><span class="line">        mCalendarId = calendarId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewTranslatorStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (mInitStarred != mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &lt; mSessionStart) &#123;</span><br><span class="line"> </span><br><span class="line">                CalendarSession calendarSession = <span class="keyword">new</span> CalendarSession(mSessionUri, mSessionStart, mSessionEnd, mTitleString, mRoomName);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">                    mServiceStarter.startAddCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    mServiceStarter.startRemoveCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">                setupSessionNotification();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成这个类的关键在于：SessionDetailPresenter 的依赖通过它的构造器传递，因为这些依赖都被注入了，所以我们现在可以修改 SessionDetailPresenter 类中 onViewTranslatorStopped() 方法的测试单元的测试后状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.samples.apps.iosched.test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.service.CalendarSession;</span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.ui.RepositoryManager;</span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.ui.ServiceStarter;</span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.ui.sessiondetail.SessionDetailViewPresenter;</span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.ui.sessiondetail.SessionDetailViewTranslator;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Matchers.any;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Matchers.anyLong;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.mock;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.verify;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by MattDupree on 5/8/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDetailPresnterTests</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldLaunchAddSessionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Arrange</span></span><br><span class="line">        SessionDetailViewTranslator sessionDetailViewTranslator = mock(SessionDetailViewTranslator.class);</span><br><span class="line"> </span><br><span class="line">        RepositoryManager repositoryManager = mock(RepositoryManager.class);</span><br><span class="line"> </span><br><span class="line">        ServiceStarter serviceStarter = mock(ServiceStarter.class);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> calendarId = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        SessionDetailViewPresenter sessionDetailViewPresenter = <span class="keyword">new</span> SessionDetailViewPresenter(sessionDetailViewTranslator,</span><br><span class="line">                                                                                               repositoryManager,</span><br><span class="line">                                                                                               serviceStarter,</span><br><span class="line">                                                                                               calendarId);</span><br><span class="line">        sessionDetailViewPresenter.onViewCreated(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Act</span></span><br><span class="line">        sessionDetailViewPresenter.onViewStopped();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//Assert</span></span><br><span class="line">        verify(serviceStarter).startAddCalendarSessionService(anyLong(), any(CalendarSession.class));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们现在可以修改测试单元的测试后状态了，但这还不够，因为这个测试单元无法完成测试。为什么呢？我们不妨一起看看 onViewTranslatorStopped() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewTranslatorStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (mInitStarred != mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &lt; mSessionStart) &#123;</span><br><span class="line"> </span><br><span class="line">            CalendarSession calendarSession = <span class="keyword">new</span> CalendarSession(mSessionUri, mSessionStart, mSessionEnd, mTitleString, mRoomName);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">                mServiceStarter.startAddCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                mServiceStarter.startRemoveCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">            setupSessionNotification();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onViewTranslatorStopped() 方法的代码被包裹在一个判断模块中，只有在“starred button”的状态与其初始化状态相异时才会执行判断模块中的代码。mInitStarred 将会在 Loader 回调中被初始化，IOSched 应用检索数据库以判断用户选中的 I/O 大会是否已经被添加到日历中，并在用户返回到 SessionDetailActivity 后通过消息更新 UI。但在上面这段业务逻辑的测试单元中，mInitStarred  和 mStarred 都将有一个初始值 <code>false</code>，使得判断模块内的代码永远不会被执行。</p>
<p>即使我们能执行判断模块内的代码，我们还是不能获得进行单元测试所需要的一切，因为启动 SessionCalendarService 的代码在另一个用于确保在 System.currentTimeMillis() 的返回值小于 mSessionStart 时才执行相关代码的判断模块中。既然我们不能修改 mSessionStart 的值，也就不能保证启动 SessionCalendarService 的代码会被运行。</p>
<p>这些问题都是我思考如何在 Android 中进行单元测试时想到的普遍问题的极端例子：我们常常缺乏对测试单元预测试状态的控制力。然而，由于我们将 SessionRepositoryManager 注入到 SessionDetailPresenter 中，我们现在可以判断 mSessionStart 和 mInitStarred 的值了，因为 SessionRepositoryManager 是一个 Android 无关的接口¹:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.samples.apps.iosched.ui;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.io.model.Session;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * </span><br><span class="line"> * Created by MattDupree on 5/6/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepositoryManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initRepository</span><span class="params">(<span class="keyword">int</span> id, Bundle bundle, SessionRepositoryManagerCallbacks repositoryManagerCallbacks)</span></span>;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">SessionRepositoryManagerCallbacks</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onLoadFinished</span><span class="params">(Session session)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，当我们创建 SessionDetailPresenter，我们注入了包含 LoaderManager 的 Android 无关接口 <code>SessionRepositoryManager</code> 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDetailActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">SessionDetailViewTranslator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">        ServiceStarter serviceStarter </span>= <span class="keyword">new</span> AndroidServiceStarter(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        SessionRepositoryManager repositoryManager = <span class="keyword">new</span> AndroidSessionRepositoryManager(getLoaderManager());</span><br><span class="line"> </span><br><span class="line">        mSessionDetailViewPresenter = <span class="keyword">new</span> SessionDetailViewPresenter(<span class="keyword">this</span>, repositoryManager, </span><br><span class="line">                                                                     serviceStarter, calendarId);</span><br><span class="line">        mSessionDetailViewPresenter.onViewCreated(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 SessionRepositoryManager 只是一个接口，所以我们能轻松地定义 MockRepositoryManager 帮助我们完成单元测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.google.samples.apps.iosched.ui.sessiondetail;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.google.samples.apps.iosched.io.model.Session;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by MattDupree on 5/8/15.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockSessionRepositoryManager</span> <span class="keyword">implements</span> <span class="title">SessionRepositoryManager</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Session mSession;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MockSessionRepositoryManager</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        mSession = session;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRepository</span><span class="params">(<span class="keyword">int</span> id, Bundle bundle,</span><br><span class="line">                               SessionRepositoryManagerCallbacks repositoryManagerCallbacks)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        repositoryManagerCallbacks.onLoadFinished(mSession);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道大家有没有注意到：当有操作通过向构造器传递一个 Session 对象调用 initRepository() 方法时，我们能够指定 MockSessionRepositoryManager 的返回值。SessionDetailPresenter 中类似 mSessionStart 这样的值能在 Session 的模板对象中通过 startTimeStamp 实例初始化。这样一来，我们就能掌控这些值了，也就是说，我们现在几乎拥有了在对 onViewTranslatorStopped() 方法进行单元测试时，准备阶段所需要的一切。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldLaunchAddSessionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Arrange</span></span><br><span class="line">    SessionDetailViewTranslator sessionDetailViewTranslator = mock(SessionDetailViewTranslator.class);</span><br><span class="line"> </span><br><span class="line">    Session session = <span class="keyword">new</span> Session();</span><br><span class="line">    session.startTimestamp = <span class="string">"1431081943"</span>;</span><br><span class="line"> </span><br><span class="line">    SessionRepositoryManager repositoryManager = <span class="keyword">new</span> MockSessionRepositoryManager(session);</span><br><span class="line"> </span><br><span class="line">    ServiceStarter serviceStarter = mock(ServiceStarter.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> calendarId = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    SessionDetailViewPresenter sessionDetailViewPresenter = <span class="keyword">new</span> SessionDetailViewPresenter(sessionDetailViewTranslator,</span><br><span class="line">                                                                                           repositoryManager,</span><br><span class="line">                                                                                           serviceStarter,</span><br><span class="line">                                                                                           calendarId);</span><br><span class="line">    sessionDetailViewPresenter.onViewCreated(<span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Act</span></span><br><span class="line">    sessionDetailViewPresenter.onViewStopped();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Assert</span></span><br><span class="line">    verify(serviceStarter).startAddCalendarSessionService(anyLong(), any(CalendarSession.class));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我之所以说“几乎”，是因为 onViewTranslatorStopped() 方法中还有一个地方不能通过上面的代码处理。在 onViewTranslatorStopped() 方法的最下面有一个只有在 mStarred 的值为 true 时才会运行的代码块。这段代码会启动一个 Service 提醒用户参与并且/或者排列他们添加到日历中的 IO 大会：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDetailViewPresenter</span> <span class="keyword">implements</span> <span class="title">RepositoryManagerCallbacks</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionDetailViewPresenter</span><span class="params">(SessionDetailView sessionDetailView,</span><br><span class="line">                                      RepositoryManager loaderManager,</span><br><span class="line">                                      ServiceStarter serviceStarter,</span><br><span class="line">                                      <span class="keyword">long</span> calendarId</span><br><span class="line">                                      )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        mSessionDetailView = sessionDetailView;</span><br><span class="line">        mLoaderManager = loaderManager;</span><br><span class="line">        mServiceStarter = serviceStarter;</span><br><span class="line">        mCalendarId = calendarId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewTranslatorStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (mInitStarred != mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &lt; mSessionStart) &#123;</span><br><span class="line"> </span><br><span class="line">                CalendarSession calendarSession = <span class="keyword">new</span> CalendarSession(mSessionUri, mSessionStart, mSessionEnd, mTitleString, mRoomName);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">                    mServiceStarter.startAddCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    mServiceStarter.startRemoveCalendarSessionService(mCalendarId, calendarSession);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line"> </span><br><span class="line">                setupSessionNotification();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让这段代码运行，我们需要确保 mStarred 的值为 true。我们能通过调用 SessionDetailPresenter 的 onSessionStarred() 方法完成这项工作，因为 onSessionStarred() 方法就是在用户点击 star button 时 SessionDetailViewTranslator（如果你觉得这些命名让你觉得晕乎乎的，你可以把它当作 SessionDetailView）调用的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onToggleSessionStarred</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    mStarred = !mStarred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldLaunchAddSessionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Arrange</span></span><br><span class="line">    SessionDetailViewTranslator sessionDetailViewTranslator = mock(SessionDetailViewTranslator.class);</span><br><span class="line"> </span><br><span class="line">    Session session = <span class="keyword">new</span> Session();</span><br><span class="line">    session.startTimestamp = <span class="string">"1431081943"</span>;</span><br><span class="line"> </span><br><span class="line">    SessionRepositoryManager repositoryManager = <span class="keyword">new</span> MockSessionRepositoryManager(session);</span><br><span class="line"> </span><br><span class="line">    ServiceStarter serviceStarter = mock(ServiceStarter.class);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> calendarId = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    SessionDetailViewPresenter sessionDetailViewPresenter = <span class="keyword">new</span> SessionDetailViewPresenter(sessionDetailViewTranslator,</span><br><span class="line">                                                                                           repositoryManager,</span><br><span class="line">                                                                                           serviceStarter,</span><br><span class="line">                                                                                           calendarId);</span><br><span class="line">    sessionDetailViewPresenter.onViewCreated(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//****** We call onToggleSessionStarred() to make sure that mStarrred is true</span></span><br><span class="line">    sessionDetailViewPresenter.onToggleSessionStarred();</span><br><span class="line">    <span class="comment">//******</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Act</span></span><br><span class="line">    sessionDetailViewPresenter.onViewStopped();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Assert</span></span><br><span class="line">    verify(serviceStarter).startAddCalendarSessionService(anyLong(), any(CalendarSession.class));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把上面提到的所有工作万仇后，我们终于能够在 onViewTranslatorStopped() 方法中进行单元测试了。</p>
<h2 id="结论">结论</h2><p>你可能觉得我们为单元测试的准备阶段进行了大量的工作，我不得不承认你的感觉是对的。最后，我提一点个人想法：我认为 SessionDetailActivity 类中的代码实在是太多了，都有1000多行……正是这个原因，使得为其实现测试单元变得如此艰难。此外，因为这篇博文的目的只是展示 Square 大法的核心用法，所以我并不打算讨论优化单元测试的方案。²</p>
<p>Square 大法是告别传统 Android 开发架构的里程碑，因为我们确实发现了遵循传统架构进行开发的种种缺陷。为此，我将在下一篇博文中指出 Square 大法潜在的问题，并提出可能的解决办法。此外，本系列的最后一篇博文也会告诉大家 Square 大法的种种优点，而且我所说的优点可不是只有增强应用的可测试性哦。</p>
<h2 id="注：">注：</h2><ol>
<li><p>严格来说这个接口并不是 Android 无关的，因为它的核心方法使用 Bundle 作为参数，但我不确定这会不会带来什么问题，毕竟 Bundle 非常普通，并不会是什么我们想要测试的东西。退一万步说，即使要对它进行测试也没啥麻烦。</p>
</li>
<li><p>在 Droidcon Montreal 中，Richa Khandelwal 在 Coursa 上开了一节课建议我们使用<a href="https://speakerdeck.com/richk/clean-android-architecture" target="_blank" rel="external">更简洁、更易于测试的架构进行开发</a>，这或许也能让实现单元测试变得简单些。</p>
</li>
</ol>
<blockquote>
<ul>
<li>原文链接 : <a href="http://philosophicalhacker.com/2015/05/08/how-to-make-our-android-apps-unit-testable-pt-2/" target="_blank" rel="external">HOW TO MAKE OUR ANDROID APPS UNIT TESTABLE (PT. 2)</a></li>
<li>原文作者 : <a href="http://philosophicalhacker.com/" target="_blank" rel="external">Matthew Dupree</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<strong><a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-11/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part3.md">上一篇博文</a></strong>中，我给大家介绍了新的应用架构方式 - Square 大法，就像我之前说的，Square 大法是 Square 用于使 Fragment 内的业务逻辑能够进行单元测试的通用方法，我还给大家展示了如何使用 Square 大法重构 Google 的 IOSched 应用的 SessionCalendarService 类，使得对 SessionCalendarService 类内的业务逻辑进行单元测试由几乎不可能变为可行。而在今天的这篇博文中，我会和大家一起继续探索 Square 大法，让我们对应用的 UI 组件进行单元测试成为可能，也让测试变得容易。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="单元测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ted Mosby - 软件架构]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/ted_mosby/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/ted_mosby/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>我给这篇关于Android库的博客起的名字灵感来源于《老爸老妈浪漫史》中的建筑设计师Ted Mosby。这个Mosby库可以帮助大家在Android上通过Model-View-Presenter模式做出一个完善稳健、可重复使用的软件，还可以借助ViewState轻松实现屏幕翻转。<br><a id="more"></a></p>
<h2 id="Model-View-Presenter_(MVP)">Model-View-Presenter (MVP)</h2><p><strong>MVP</strong>模式是一个把view从低层模型分离出来的一种现代模式。<strong>MVP</strong>由model–view–controller (MVC)软件模式衍生而来，常用于构建UI</p>
<ul>
<li><strong>MVP</strong>中的<strong>M</strong>（model）代表的是将会显示在view（UI）中的数据。</li>
<li><strong>MVP</strong>中的<strong>V</strong>（view）是显示数据（model）并且将用户指令（events）传送到presenter以便作用于那些数据的一个接口。View通常含有Presenter的引用。</li>
<li><strong>MVP</strong>中的<strong>P</strong>（presenter）扮演的是“中间人”的作用（就如MVC中的controller），且presenter同时引用view和model。值得注意的是，“Model”这个词并不正确。严格意义上来说，它指的应该是检索或控制一个Model的业务逻辑层。举个例子，比如你的数据库里面包含了User，而你的View想要显示一个User列表，那么Presenter会引用数据库中的业务逻辑层（比如DAO）从而查询到一个User列表。如图1-1.<br><img src="http://hannesdorfmann.com/images/mosby/mvp-overview.png" alt=""></li>
</ul>
<p>从数据库中查询或显示User列表的具体流程如图1-2：<br><img src="http://hannesdorfmann.com/images/mosby/mvp-workflow.png" alt=""></p>
<p>以上工作流程图应该能够说明问题了。但是，还有以下几点值得注意的地方：</p>
<ul>
<li><p><strong>Presenter</strong>不是一个<strong>OnClickListener</strong>。<strong>View</strong>主要是负责处理用户输入并调用presenter相应的方法。那么问题来了，为什么不把<strong>Presenter</strong> 直接做成一个<strong>OnClickListener</strong>，从而把“转发流程”给省略掉呢？大家想想，如果这样做的话，首先，<strong>presenter</strong>需要知道view的内部构件。举个例子，如果一个View有两个按钮，且这个view在这两个按钮上都把<strong>Presenter</strong> 注册成<strong>OnClickListener</strong>的话，那么发生点击事件时Presenter （在不知道view中按钮引用等内部构件的情况下）怎么能够区分出是哪一个按钮被点击了呢？Model，View和Presenter三者应解耦。其次，如果让Presenter 执行OnClickListener，Presenter就被绑定到了Android平台上。理论上来说<strong>presenter</strong>和业务逻辑层都是纯旧式的能够与桌面应用或其他任何java应用共享的java代码。</p>
</li>
<li><p>大家在第1步和第2步中可以看到，<strong>View</strong> 只执行<strong>Presenter</strong> 指示的操作：用户点击“load user button”（第1步）后，view并没有直接显示加载动画，而是在第2步presenter明确告诉其显示加载动画后才显示的。这一Model-View-Presenter的变体称之为MVP 被动视图。这个view可以说是要多笨有多笨。这时我们需要让presenter以一种更抽象的方式来控制view。比如，presenter在调用 <strong>view.showLoading()</strong> 时并不控制view的诸如动画等具体事项。所以presenter不应调用<strong>view.startAnimation()</strong> 等方法。</p>
</li>
<li><p>通过执行<strong>MVP</strong>被动视图，并发性以及多线程更容易处理。大家可以看到，第3步中数据库查询异步运行，并且<strong>presenter作为Listener/Observer</strong>，在数据准备显示时presenter收到通知。</p>
</li>
</ul>
<h2 id="Android上的MVP"><strong>Android</strong>上的<strong>MVP</strong></h2><p>目前为止一切顺利。但是大家怎么样把MVP运用到自己的Android 应用上呢？第一个问题在于，我们要把MVP模式运用到什么地方？Activity上、Fragment上、还是像RelativeLayout这类的ViewGroup上？我们来看看Android平板上的Gmail应用，如图1-3：</p>
<p><img src="http://hannesdorfmann.com/images/mosby/mvp-gmail.png" alt=""></p>
<p>在我看来，上图屏幕中有四个可以使用MVP的地方。我所说的“可以使用MVP的地方”是指屏幕上显示的、在逻辑上属于一个整体的UI元素。因此这些地方也可以称为是可以运用MVP的一个单独的UI单元。如图 1-4.</p>
<p><img src="http://hannesdorfmann.com/images/mosby/mvp-gmail-candidates.png" alt=""></p>
<p>看起来MVP似乎很适合运用到Activity，特别是Fragment上。通常Fragment只负责显示单一的如ListView之类的内容，就像依靠<strong>MailProvider</strong> 来获取一系列<strong>Mails</strong>的<strong>InboxPresenter</strong> 控制下的 <strong>InboxView</strong>一样。但是，<strong>MVP</strong>不仅仅限于Fragment或Activity，它还可以运用到SearchView中显示的ViewGroup中。在我的大多数app里面我都在Fragment运用MVP模式。但是大家可以自行决定把MVP运用到什么地方，前提是view是独立的，这样这样presenter才能在不与其他Presenter冲突的情况下控制View。</p>
<h2 id="我们为什么要实现MVP？">我们为什么要实现<strong>MVP</strong>？</h2><p>我们如何在不使用MVP模式时显示Email列表到Fragment? 通常，我们需要获取并且合并本地SQL数据库和从IMAP邮件服务器获取的邮件列表，然后将邮件列表绑定到收件箱view中。那么，此时fragment的代码又会是怎么样的呢？我们需要运行两个<strong>AsyncTasks</strong> 并实现一个“等待机制”（等到两个任务将两者的加载数据合并到一个单独的mail列表）。我们还需要注意的是在加载时要显示加载动画（ProgressBar），之后用ListView替代。我们需要把所有的代码放到Fragment中吗？要是加载过程中出现错误怎么办？屏幕翻转怎么办？谁来负责撤销<strong>AsyncTasks</strong> ？这一系列的问题都可以通过MVP得到解决。让我们跟那些带有上千行大杂烩代码的activity和fragment说拜拜吧</p>
<p>但是，在我们深入研究如何将MVP运用到Android中之前，我们需要弄清楚的一个问题是：Activity或Fragment究竟是一个View还是一个Presenter。Activity或Fragment似乎既是<strong>View</strong>也是<strong>Presenter</strong>，因为它们都有 <strong>onCreate()</strong> 或<strong>onDestroy()</strong>之类的生命周期回调功能，并且它们负责从一个UI控件到另一个UI 控件的转换（比如在加载时显示ProgressBar，然后显示带有数据的ListView）等View操作。大家可能会觉得这里的Activity或Fragment就是一个Controller，我猜可能也是这么一个初衷。但是在经历了几年的Android应用开发之后，我得出这么一个结论：我们应该把Activity或Fragment看作是一个不太智能的View，而不是把它们看作一个Presenter。后文我会给出原因。</p>
<p>综上，我想给大家介绍一个在Android平台上开发基于MVP的应用的一个 <strong>Mosby</strong>库。<br><strong>Mosby</strong></p>
<p>大家可以在<a href="https://github.com/sockeqwe/mosby" target="_blank" rel="external">Github</a>和Maven Central上找到Mosby库。Mosby分为几个子模块，大家可以根据自己的需要选取组件。我们来回顾一下最重要的一个模块。</p>
<h2 id="核心模块_(_Core_Module)">核心模块 ( Core Module)</h2><p>《老爸老妈浪漫史》中的建筑设计师Ted Mosby想建造一栋摩天大楼。而建造这样一栋宏伟的建筑必须打好坚实的地基。这对Android应用的开发来说是也是一样的道理。基本上，<strong>Core Module</strong> 分为两种类型：<strong>MosbyActivity</strong> 和<strong>MosbyFragment</strong>。这两者是所有其他activity或fragment子类的基类（相当于建筑的地基）。两者都使用我们大家所熟知的APT <strong>（Annotation Processing Tool）</strong>来减少一些样板式代码。<strong>MosbyActivity</strong> 和<strong>MosbyFragment</strong> 使用Butterknife进行view的注入，使用Icepick 将实例状态保存和存储到Bundle中，使用FragmentArgs注入Fragment参数。我们不需要再调用Butterknife.inject(this)等插入方法。这类代码已经包含在了MosbyActivity 和 MosbyFragment中。它是即时可用的。我们需要做的就是使用子类中相应的注解。核心模块与MVP没有关联，它只是写一个大型软件的基础。</p>
<h2 id="MVP模块(_MVP_Module_)">MVP模块( MVP Module )</h2><p>Mosby库中的MVP模块使用泛型来确保类型安全。所有view的基类是<strong>MvpView</strong>。从根本上说这只是一个空的interface 。Presenter的基类是<strong>MvpPresenter</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpView</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpPresenter</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">MvpView</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachView</span><span class="params">(V view)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachView</span><span class="params">(<span class="keyword">boolean</span> retainInstance)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文提到，我们把<strong>Activity</strong>和<strong>Fragment</strong>看做View。因此Mosby库的MVP模块提供了 属于<strong>MvpViews</strong> 的<strong>MvpActivity</strong>和<strong>MvpFragment</strong>作为<strong>Activity</strong>和<strong>Fragment</strong>的基类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpActivity&lt;P</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MvpPresenter&gt;</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MosbyActivity</span> <span class="title">implements</span> <span class="title">MvpView</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">P</span> presenter;</span><br><span class="line">	<span class="annotation">@Override</span>  <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState)&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		presenter = createPresenter();</span><br><span class="line">		presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">super</span>.onDestroy();</span><br><span class="line">		presenter.detachView(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">PcreatePresenter</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MvpFragment&lt;P</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MvpPresenter&gt;</span> <span class="title">MosbyFragment</span> <span class="title">implements</span> <span class="title">MvpView</span>&#123;</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">Ppresenter</span>;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> public void onViewCreated(<span class="type">View</span> view,<span class="annotation">@Nullable</span> <span class="type">Bundle</span> savedInstanceState)&#123;</span><br><span class="line">		<span class="keyword">super</span>.onViewCreated(view,savedInstanceState);</span><br><span class="line">		<span class="comment">// Create the presenter if needed</span></span><br><span class="line">		<span class="keyword">if</span>(presenter == <span class="literal">null</span>)&#123;</span><br><span class="line">			presenter = createPresenter();</span><br><span class="line">		&#125;</span><br><span class="line">		presenter.attachView(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> public void onDestroyView()&#123;</span><br><span class="line">		<span class="keyword">super</span>.onDestroyView();</span><br><span class="line">		presenter.detachView(getRetainInstance());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">PcreatePresenter</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="keyword">protected</span> void onDestroy()&#123;</span><br></pre></td></tr></table></figure>
<p>这一理念主要是一个<strong>MvpView</strong> (也就是Fragment or Activity)会关联一个MvpPresenter，并且管理<strong>MbpPresenter</strong>的声明周期。大家从上面的代码片段可以看到，Mosby使用Activity和Fragement生命周期来实现这一目的。通常presenter是绑定在该生命周期上的。所以初始化或者清理一些东西等操作（例如撤销异步运行任务）应该在 <strong>presenter.onAttach()</strong>和 presenter.onDetach()上进行。我们稍后会谈到presenter如何使用setRetainInstanceState(true) “避开”Fragment中的生命周期。我相信大家也注意到了， MvpPresenter是一个interface 。MVP模块提供一个 <strong>MvpBasePresenter</strong>，这个<strong>MvpBasePresenter</strong>只持有View（是一个Fragment或Activity）的弱引用，从而避免内存泄露。因此，当<strong>presenter</strong>想要调用view方法时，我们需要查看<strong>isViewAttached()</strong> 并使用<strong>getView()</strong>来获取引用，以检查view是否连接到了presenter。</p>
<h2 id="Loading-Content-Error_(LCE)">Loading-Content-Error (LCE)</h2><p>通常Fragment会一直重复做某一件事。它在后台加载数据，同时显示加载view（即ProgressBar），并在屏幕上显示加载的数据，或者当加载失败时显示view错误。如今，下拉刷新支持很容易实现，因为SwipeRefreshLayout是Android支持库的组成部分。为了避免重复执行这一工作流，Mosby库的<strong>MVP</strong>模块提供了<strong>MvpLceView</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MvpLceView</span>&lt;<span class="title">M</span>&gt; <span class="keyword">extends</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	   * 显示一个加载中的视图</span><br><span class="line">	   * loading view 必须有个id 为 R.id.loadingView的View</span><br><span class="line">	   * <span class="doctag">@param</span> pullToRefresh 如果是true,那么表示下拉刷新被触发了</span><br><span class="line">	   */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">(<span class="keyword">boolean</span> pullToRefresh)</span></span>;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	   * 显示 content view.</span><br><span class="line">	   * &lt;content view 的id必须是R.id.contentView</span><br><span class="line">	   */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showContent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	   * 显示错误信息</span><br><span class="line">	   * <span class="doctag">@param</span> e The Throwable that has caused this error</span><br><span class="line">	   * <span class="doctag">@param</span> pullToRefresh true, if the exception was thrown during pull-to-refresh, otherwise</span><br><span class="line">	   * false.</span><br><span class="line">	   */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showError</span><span class="params">(Throwable e,<span class="keyword">boolean</span> pullToRefresh)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	   * The data that should be displayed with &#123;<span class="doctag">@link</span> #showContent()&#125;</span><br><span class="line">	   */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(M data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对那种类型的view我们可以采用 <strong>MvpLceActivity  implements  MvpLceView 和 MvpLceFragment  implements  MvpLceView。</strong>两者均假设解析的xml布局包括了含有<strong>R.id.loadingView,R.id.contentView和R.id.errorView的view</strong>。</p>
<p>示例<br>接下来要举的例子<a href="https://github.com/sockeqwe/mosby/tree/master/sample" target="_blank" rel="external">Github</a>上也有中，我们使用CountriesAsyncLoader加载一系列的Country，并将其显示在Fragment的RecyclerView中。大家可以从这个链接 <a href="https://db.tt/ycrCwt1L" target="_blank" rel="external">https://db.tt/ycrCwt1L</a>下载。</p>
<p>首先我们要定义<strong>CountriesView</strong>这一view interface 。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountriesView</span> <span class="keyword">extends</span> <span class="title">MvpLceView</span>&lt;<span class="title">List</span>&lt;<span class="title">Country</span>&gt;&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要为View定义接口呢？<br>1.因为定义了这个接口之后我们可以更改view的实现。我们可以简单地把代码从一个继承自 Activity的实现转移到继承自 Fragment的实现。</p>
<p>2.模块性：我们可以移动独立的库项目中的整个业务逻辑层、Presenter以及View 接口，然后把这个包含了Presenter的库应用到各类app当中。下图中左侧是使用了嵌入在ViewPager中的Activity的<strong>kicker app</strong>，以及使用嵌入在ViewPager中的Fragment的<strong>meinVerein app</strong>，如图1-5。 两者采用的是同一个定义了View接口和Presenter且测试了单元的库。</p>
<p><img src="http://hannesdorfmann.com/images/mosby/mvp-reuse.png" alt=""></p>
<p>由于我们可以通过执行view接口来模拟view，所以我们可以很容易地编写单元测试。还有一个更简单的方法就是在presenter中引入java接口并使用模拟presenter对象来编写单元测试。<br>还有一个良性副作用就是，定义了view接口之后，我们不用直接从presenter再回调activity/fragment方法。我们这样区分开来是因为在执行presenter时我们在IDE自动完成上看到的方法只是关于view接口的方法。就我个人体会来说，我觉得这个方法非常有用，特别是团队一起工作的时候。需要注意的是，除了定义一个CountriesView接口之外，我们还可以采用<strong>MvpLceView<list<country>&gt;</list<country></strong> 。但是，定义一个专门的接口可以提高代码可读性，并且将来可以灵活地定义更多其他的与View相关的方法。</p>
<p>Next we define our views xml layout file with the required ids:</p>
<p>下一步我们需要按照指定的id来定义view xml 布局文件.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">FrameLayoutxmlns:android="http:</span>//<span class="attribute">schemas.android.com</span>/<span class="attribute">apk</span>/<span class="attribute">res</span>/<span class="attribute">android</span>"</span><br><span class="line"><span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line"><span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Loading View --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">ProgressBar</span></span><br><span class="line">	<span class="attribute">android:id</span>=<span class="value">"@+id/loadingView"</span></span><br><span class="line">	<span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">	<span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">	<span class="attribute">android:layout_gravity</span>=<span class="value">"center"</span></span><br><span class="line">	<span class="attribute">android:indeterminate</span>=<span class="value">"true"</span></span><br><span class="line">	/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Content View --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">android.support.v4.widget.SwipeRefreshLayout</span></span><br><span class="line">	<span class="attribute">android:id</span>=<span class="value">"@+id/contentView"</span></span><br><span class="line">	<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">	<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">	&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">		<span class="attribute">android:id</span>=<span class="value">"@+id/recyclerView"</span></span><br><span class="line">		<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">		<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">	/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="title">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Error view --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">		<span class="attribute">android:id</span>=<span class="value">"@+id/errorView"</span></span><br><span class="line">		<span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">		<span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">	/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>CountriesPresenter控制CountriesView并运行CountriesAsyncLoader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountriesPresenter</span> <span class="keyword">extends</span> <span class="title">MvpBasePresenter</span>&lt;<span class="title">CountriesView</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadCountries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> pullToRefresh)</span></span>&#123;</span><br><span class="line">		getView().showLoading(pullToRefresh);</span><br><span class="line">		</span><br><span class="line">		CountriesAsyncLoader countriesLoader = <span class="keyword">new</span> CountriesAsyncLoader(</span><br><span class="line">		<span class="keyword">new</span> CountriesAsyncLoader.CountriesLoaderListener()&#123;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;Country&gt; countries)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(isViewAttached())&#123;</span><br><span class="line">				getView().setData(countries);</span><br><span class="line">				getView().showContent();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(isViewAttached())&#123;</span><br><span class="line">				getView().showError(e,pullToRefresh);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">		countriesLoader.execute();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<strong>CountriesView</strong>接口 的<strong>CountriesFragment</strong> 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountriesFragment</span></span><br><span class="line"> <span class="keyword">extends</span> <span class="title">MvpLceFragment</span>&lt;<span class="title">SwipeRefreshLayout</span>,<span class="title">List</span>&lt;<span class="title">Country</span>&gt;,<span class="title">CountriesView</span>,<span class="title">CountriesPresenter</span>&gt;</span><br><span class="line"> <span class="keyword">implements</span> <span class="title">CountriesView</span>,<span class="title">SwipeRefreshLayout</span>.<span class="title">OnRefreshListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@InjectView</span>(R.id.recyclerView)RecyclerViewrecyclerView;</span><br><span class="line">	CountriesAdapteradapter;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view,@Nullable Bundle savedInstance)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onViewCreated(view,savedInstance);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Setup contentView == SwipeRefreshView</span></span><br><span class="line">		contentView.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup recycler view</span></span><br><span class="line">		adapter = <span class="keyword">new</span> CountriesAdapter(getActivity());</span><br><span class="line">		recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(getActivity()));</span><br><span class="line">		recyclerView.setAdapter(adapter);</span><br><span class="line">		loadData(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="keyword">boolean</span> pullToRefresh)</span></span>&#123;</span><br><span class="line">		presenter.loadCountries(pullToRefresh);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> CountriesPresenter <span class="title">createPresenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleCountriesPresenter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Just a shorthand that will be called in onCreateView()</span></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLayoutRes</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> R.layout.countries_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(List&lt;Country&gt; data)</span></span>&#123;</span><br><span class="line">		adapter.setCountries(data);</span><br><span class="line">		adapter.notifyDataSetChanged();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">		loadData(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码数量也并不是很多嘛，对吧？这是因为基类已经执行了从加载view到content view或error view的转换。我们可能第一眼看到那一列<strong>MvpLceFragment</strong>类属参数会觉得灰心。但是我要解释一下：第一种类属参数代表的是content view的类型；第二种是指以fragment显示的Model；第三种是View接口;最后一种是Presenter的类型。总结起来就是：<strong>MvpLceFragment<androidview, model,="" view接口,="" presenter=""></androidview,></strong>。</p>
<p>大家可能还注意到的一个点就是 <strong>getLayoutRes()</strong>，它是<strong>MosbyFragment</strong>引入的用于解析xml view布局的速记法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">	Return  inflater.inflate(getLayoutRes(),container,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们不用重写<strong>onCreateView()</strong>，只需重写<strong>getLayoutRes()</strong>。一般来说，onCreateView()只能创建view而<strong>onViewCreated()</strong>需要被重写，以便为RecyclerView初始化Adapter等项。因此，千万不要忘记调用super.OnViewCreated()；</p>
<h2 id="ViewState模块">ViewState模块</h2><p>看到这里大家应该大概了解了如何运用Mosby库。Mosby中的ViewState模块能帮助我们在Android开发中解决一些棘手的难题：处理屏幕旋转。</p>
<p>问：如果把正在运行country这个例子的app并显示了一列country的设备从横屏旋转到竖屏，会出现什么情况？</p>
<p>答：大家到这个视频链接<a href="https://youtu.be/9iSBGEIZmUw" target="_blank" rel="external">https://youtu.be/9iSBGEIZmUw</a>中看看，结果是一个新的 CountriesFragment会被实例化，app开始显示ProgressBar（并重新加载country列表）而不再在RecyclerView中显示country列表（屏幕旋转前的状态）</p>
<p>Mosby引入了<strong>ViewState</strong>来解决这个问题。原理就是，我们跟踪presenter从关联的View中调用的方法。比如，<strong>presenter</strong>调用的是view.showContent()，一旦showContent()被调用，view就会意识到其状态变更为<strong>“showing content”</strong>，从而view把这一信息存储到一个ViewState。如果view在方向改变过程中遭到破坏，那么ViewState 就会被存储到<strong>Activity.onSaveInstanceState(Bundle) 或 Fragment.onSaveInstanceState(Bundle)中，并在Activity.onCreate(Bundle) 或Fragment.onActivityCreated(Bundle)</strong>中修复。</p>
<p>由于不是每种数据都能存储在Bundle中，所以不同的数据类型采用不同的ViewState 实现：数据类型<strong>ArrayList<parcelable></parcelable></strong>采用<strong>ArrayListLceViewState</strong>；数据类型Parcelable 采用<strong>Parcelable DataLceViewState</strong>；数据类型<strong>Serializeable</strong>采用<strong>SerializeableLceViewState</strong>。如果使用的是一个可保持( Retaining )的Fragment，那么 ViewState在屏幕旋转时不会被破坏，所以也就不需要存储到Bundle中。因此，它可以存储任何类型的数据。在这种情况下，我们需要使用<strong>RetainingFragmentLceViewState</strong>。存储一个ViewState比较容易。由于我们的架构比较整洁，我们的View又有接口，ViewState 可以向presenter一样通过调用同样的接口方法来修复相关联的view。举个例子，MvpLceView一般有3种状态，即：显示<strong>showContent()，showLoading()和showError()</strong>，所以ViewState本身会调用相应的方法来修复view的状态。</p>
<p>那只是一些内部构件。如果大家想编写自定义的ViewState，了解以上内容就够了。ViewStates的使用非常简单。事实上，要把MvpLceFragment 迁移到MvpLceViewStateFragment ，我们只需要另外执行<strong>createViewState()</strong> 和 <strong>getData()</strong>。下面我们就在CountriesFragment中实践一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountriesFragment</span></span><br><span class="line"> <span class="keyword">extends</span> <span class="title">MvpLceViewStateFragment</span>&lt;<span class="title">SwipeRefreshLayout</span>,<span class="title">List</span>&lt;<span class="title">Country</span>&gt;,<span class="title">CountriesView</span>,<span class="title">CountriesPresenter</span>&gt;</span><br><span class="line"> <span class="keyword">implements</span> <span class="title">CountriesView</span>,<span class="title">SwipeRefreshLayout</span>.<span class="title">OnRefreshListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@InjectView</span>(R.id.recyclerView)RecyclerView recyclerView;</span><br><span class="line">	CountriesAdapter adapter;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="keyword">public</span> LceViewState&lt;List&lt;Country&gt;,CountriesView&gt; createViewState()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RetainingFragmentLceViewState&lt;List&lt;Country&gt;,CountriesView&gt;(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;Country&gt; <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> adapter == <span class="keyword">null</span>? <span class="keyword">null</span> : adapter.getCountries();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The code below is the same as before</span></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(Viewview,@Nullable Bundle savedInstance)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onViewCreated(view,savedInstance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup contentView == SwipeRefreshView</span></span><br><span class="line">	contentView.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup recycler view</span></span><br><span class="line">		adapter = <span class="keyword">new</span> CountriesAdapter(getActivity());</span><br><span class="line">		recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(getActivity()));</span><br><span class="line">		recyclerView.setAdapter(adapter);</span><br><span class="line">		loadData(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="keyword">boolean</span> pullToRefresh)</span></span>&#123;</span><br><span class="line">		presenter.loadCountries(pullToRefresh);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> CountriesPresenter <span class="title">createPresenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleCountriesPresenter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Just a shorthand that will be called in onCreateView()</span></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getLayoutRes</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> R.layout.countries_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(List&lt;Country&gt; data)</span></span>&#123;</span><br><span class="line">		adapter.setCountries(data);</span><br><span class="line">		adapter.notifyDataSetChanged();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>&#123;</span><br><span class="line">		loadData(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是全部过程啦。我们不必更改presenter或其他代码。<a href="https://youtu.be/9iSBGEIZmUw" target="_blank" rel="external">这里</a> 是一个关于我们的获得ViewState支持的CountriesFragment的视频。在这个视频中我们可以看到，view在方位转变之后仍然处于同样的“状态”，即，view横屏显示country列表，随后横屏显示country列表。View能横屏显示下拉刷新指示，变更为竖屏时也能显示。</p>
<h2 id="自定义ViewState">自定义ViewState</h2><p>ViewState确实是一个强大且灵活的概念。看到这里我相信大家都了解了LCE (Loading-Content-Error) ViewState的易用性。下面我们就一起来编写自己的View和ViewState吧。我们的View只显示两类不同的数据对象：A和B。结果应该像这个视频 <a href="https://youtu.be/9iSBGEIZmUw" target="_blank" rel="external">https://youtu.be/9iSBGEIZmUw</a> 中演示的这样：</p>
<p>大家心里肯定觉得，这也不怎么样啊！别介啊，我只是想演示一下创建自己的ViewState是一件多么容易的事。</p>
<p>View 接口和数据对象（model）如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">	String  name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String  name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String  <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">	String  foo;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String  foo)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.foo=foo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String  <span class="title">getFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> foo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyCustomView</span> <span class="keyword">extends</span> <span class="title">MvpView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">(A a)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">(B b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个简单的例子中我们没有加入业务逻辑层。因为我们假设在实际的app中如果有业务逻辑层的话会使整个生成A或B的操作变得复杂。<strong>Presenter</strong>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomPresenter</span> <span class="keyword">extends</span> <span class="title">MvpBasePresenter</span>&lt;<span class="title">MyCustomView</span>&gt;</span>&#123;</span><br><span class="line">	Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		A a = <span class="keyword">new</span> A(<span class="string">"My name is A "</span>+random.nextInt(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isViewAttached())&#123;</span><br><span class="line">			getView().showA(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		B b = <span class="keyword">new</span> B(<span class="string">"I am B "</span>+random.nextInt(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(isViewAttached())&#123;</span><br><span class="line">			getView().showB(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了实现了MyCustomView接口的<strong>MyCustomActivity</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCustomActivity</span> <span class="keyword">extends</span> <span class="title">MvpViewStateActivity</span>&lt;<span class="title">MyCustomPresenter</span>&gt;</span><br><span class="line"> <span class="keyword">implements</span> <span class="title">MyCustomView</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@InjectView</span>(R.id.textViewA) TextViewaView;</span><br><span class="line">	<span class="annotation">@InjectView</span>(R.id.textViewB) TextViewbView;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.my_custom_view);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> RestoreableViewState <span class="title">createViewState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyCustomViewState();<span class="comment">// Our ViewState implementation</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Will be called when no view state exist yet,</span></span><br><span class="line">	<span class="comment">// which is the case the first time MyCustomActivity starts</span></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> onNew <span class="title">ViewStateInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		presenter.doA();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> MyCustomPresenter <span class="title">createPresenter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyCustomPresenter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showA</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">		MyCustomViewState vs = ((MyCustomViewState)viewState);</span><br><span class="line">		vs.setShowingA(<span class="keyword">true</span>);</span><br><span class="line">		vs.setData(a);</span><br><span class="line">		aView.setText(a.getName());</span><br><span class="line">		aView.setVisibility(View.VISIBLE);</span><br><span class="line">		bView.setVisibility(View.GONE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showB</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">		MyCustomViewState vs=((MyCustomViewState)viewState);</span><br><span class="line">		vs.setShowingA(<span class="keyword">false</span>);</span><br><span class="line">		vs.setData(b);</span><br><span class="line">		bView.setText(b.getFoo());</span><br><span class="line">		aView.setVisibility(View.GONE);</span><br><span class="line">		bView.setVisibility(View.VISIBLE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@OnClick</span>(R.id.loadA)<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadAClicked</span><span class="params">()</span></span>&#123;</span><br><span class="line">		presenter.doA();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@OnClick</span>(R.id.loadB)<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadBClicked</span><span class="params">()</span></span>&#123;</span><br><span class="line">		presenter.doB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们没有LCE(Loading-Content-Error)，所以不把 <strong>MvpLceActivity</strong>作为基类。我们采用的是最普遍的支持 ViewState的<strong>MvpViewStateActivity</strong>作为基类。基本上我们的View只显示aView 或 bView。</p>
<p>在<strong>onNew ViewStateInstance()</strong>中，我们需要明确在第一个Activity运行时需要做什么，因为先前并不存在ViewState 例子用于修复。在showA(A a) 和 showB(B b)中，我们需要将显示A 或 B的信息存储到ViewState。到这一步，我们就差不多完成了，现在只差MyCustomViewState执行这一步啦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">MyCustomViewState</span> <span class="keyword">implements</span> <span class="title">RestoreableViewState</span>&lt;<span class="title">MyCustomView</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">final</span> String  KEY_STATE=<span class="string">"MyCustomViewState-flag"</span>;</span><br><span class="line">	<span class="keyword">private</span>  <span class="keyword">final</span> String  KEY_DATA=<span class="string">"MyCustomViewState-data"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> showingA=<span class="keyword">true</span>;<span class="comment">// if false, then show B</span></span><br><span class="line">	<span class="keyword">public</span> Parcelable  data;<span class="comment">// Can be A or B</span></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveInstanceState</span><span class="params">(Bundle out)</span></span>&#123;</span><br><span class="line">		out.putBoolean (KEY_STATE,showingA);</span><br><span class="line">		out.putParcelable (KEY_DATA,data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">restoreInstanceState</span><span class="params">(Bundle in)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(in==<span class="keyword">null</span>)&#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		showingA = in.getBoolean (KEY_STATE,<span class="keyword">true</span>);</span><br><span class="line">		data = in.getParcelable (KEY_DATA);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(MyCustomView view,<span class="keyword">boolean</span> retained)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(showingA)&#123;</span><br><span class="line">			view.showA((A)data);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			view.showB((B)data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	   * <span class="doctag">@param</span> a true if showing a, false if showing b</span><br><span class="line">	   */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShowingA</span><span class="params">(<span class="keyword">boolean</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.showingA=a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Parcelable data)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data=data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以看到，我们需要把<strong>ViewState</strong>保存到从<strong>Activity.onSaveInstanceState()</strong>调用的 <strong>saveInstanceState()</strong>中，并且在从Activity.onCreate()调用的<strong>restoreInstanceState()</strong>中修复viewstate的数据。apply()方法将会从Activity中调用以修复view state。我们像presenter一样通过调用同样的View interface  方法showA() 或 showB()来实现这一操作。</p>
<p>大家可以看到，我们需要把ViewState保存到从<strong>Activity.onSaveInstanceState()</strong>调用的 <strong>saveInstanceState()</strong>中，并且在从Activity.onCreate()调用的<strong>restoreInstanceState()</strong>中修复viewstate的数据。apply()方法将会从Activity中调用以修复view state。我们像presenter一样通过调用同样的View interface  方法showA() 或 showB()来实现这一操作。</p>
<p>这个外部的<strong>ViewState</strong>把view state修复的复杂性和职责从Activity代码中剥离，并入到这个单独的类中。而编写<strong>ViewState</strong>类的单元测试要比Activity类的单元测试容易得多。</p>
<h2 id="怎样处理后台线程？">怎样处理后台线程？</h2><p>通常，<strong>Presenter</strong>会管理后台线程。Presenter如何处理后台线程取决于它所关联的Activity或者Fragment ，具体分为两种情况：</p>
<ul>
<li>可保持的Fragment : 如果你调用了Fragment的setRetainInstanceState(true)那么这个Fragment在屏幕旋转时就不会被销毁。只有该Fragment的GUI会被销毁，并且在屏幕旋转时重新调用onCreateView创建视图。这就是说当屏幕旋转时Fragment所有的成员成员变量和Presenter不会发生变化。在这个示例中，我们将新的视图关联到Presenter中。因此，Presenter不需要去掉任何正在运行中的后台任务，因为Presenter已经关联了新的视图。例如:</li>
</ul>
<p>1.竖屏情况下启动应用<br>2.实例化Fragment时会调用onCreate()、onCreateView()、createPresenter(), 然后通过调用presenter的attachView()函数将View关联到Presenter中。</p>
<ol>
<li>下一步我们旋转手机屏幕，从竖屏切换到横屏；</li>
<li>此时onDestroyView() 会调用，而onDestroyView() 又会调用presenter的detachView(true)函数。我们注意到detachView有个参数为true,这是告诉presenter这个Fragment是可持有的Fragment（否则这个参数应该为false）。通过这个参数，presenter就知道它不需要取消正在运行的后台任务；</li>
<li>应用现在是横屏状态了，在旋转时onCreateView方法会被调用，但是createPresenter()函数不会被调用，因为我们会对presenter 进行不为空的判断，当presenter为空时才调用createPresenter()函数。而Fragment的setRetainInstanceState(true)会保持这个presenter对象，因此presenter此时不会被重新创建；</li>
<li>在调用了presenter的attachView()之后新创建的View会被重新关联到presenter中。</li>
<li>ViewState会被恢复，但是没有后台任务会被取消，因此也没有后台任务需要重新启动。</li>
</ol>
<ul>
<li>Activity和不保持的Fragment :在这个示例中工作流非常的简单。所有的东西都会被销毁，包括presenter。因此presenter对象应该取消所有正在运行的任务。例如 :<br>我们采用非保持fragment在竖屏情况下启动app。</li>
</ul>
<p>8.我们采用非保持fragment在竖屏情况下启动app。<br>9.Fragment被实例化之后，调用onCreate()， onCreateView()，和createPresenter()，然后通过调用<strong>presenter.attachView()</strong>将<strong>view（fragment）</strong>附着到presenter。<br>10.下一步我们旋转设备屏幕，从竖屏切换到横屏。<br>11.此时onDestroyView() 会调用，而<strong>onDestroyView()</strong> 又会调用<strong>presenter</strong>的<strong>detachView(true)</strong>函数。<strong>Presenter</strong>取消后台任务。</p>
<ol>
<li><strong>onSaveInstanceState(Bundle)</strong>被调用， <strong>ViewState</strong>被保存到Bundle中。</li>
<li><strong>App</strong>现在出于横屏状态。新的Fragment被实例化并调用onCreate()，onCreateView()和 <strong>createPresenter()</strong>来创建一个新的presenter例子，通过调用<strong>presenter.attachView()</strong>将新的view附着到新的presenter</li>
<li><strong>ViewState</strong>会从<strong>Bundle</strong>中恢复，且view的状态也会被恢复。如果ViewState是showLoading，那么<strong>presenter</strong>会重新启动后台线程来加载数据。</li>
<li>以下是获得ViewState支持的Activity的生命周期图解，如图1-6：<br><img src="http://hannesdorfmann.com/images/mosby/mvp-activity-lifecycle.png" alt=""></li>
</ol>
<p>以下是获得ViewState支持的Fragment的生命周期图解， 如图 1-7：<br><img src="http://hannesdorfmann.com/images/mosby/mvp-fragment-lifecycle.png" alt=""></p>
<h2 id="Retrofit模块">Retrofit模块</h2><p>Mosby提供了 <strong>LceRetrofitPresenter</strong> 和 <strong>LceCallback</strong>。为获得LCE方法showLoading(), showContent() 和 showError()支持的Retrofit编写presenter ，几行代码就能搞定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MembersPresenter</span> <span class="keyword">extends</span> <span class="title">LceRetrofitPresenter</span>&lt;<span class="title">MembersView</span>,<span class="title">List</span>&lt;<span class="title">User</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>  GithubApigithubApi;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MembersPresenter</span><span class="params">(GithubApi githubApi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.githubApi=githubApi;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadSquareMembers</span><span class="params">(<span class="keyword">boolean</span> pullToRefresh)</span></span>&#123;</span><br><span class="line">		githubApi.getMembers(<span class="string">"square"</span>,<span class="keyword">new</span> LceCallback(pullToRefresh));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dagger模块">Dagger模块</h2><p>   想在不依靠注入式的情况下写应用？Ted Mosby告诉你，这是行不通滴！Dagger是java依赖注入式框架最常用的方法，也是Android开发者们的心头好。Mosby支持Dagger1。Mosby通过一个叫做getObjectGraph()的方法提供Injector界面。通常，我们的应用模块非常广泛。要想轻松分享这一模块，我们需要把android.app.Application归入子类，使其执行Injector。之后所有的Activity和Fragment都可以通过调用getObjectGraph()来存取ObjectGraph，因为<strong>DaggerActivity and DaggerFragment</strong>也都是Injector。我们也可以通过重写Activity 或 Fragment中的 getObjcetGraph() ，从而调用plus(Module)以增加模块。我个人已经用到Dagger2了，它与Mosby也兼容。大家可以在Github上找到关于Dagger1 和 Dagger2的示例。点此这个链接<a href="https://db.tt/3fVqVdAz" target="_blank" rel="external">https://db.tt/3fVqVdAz</a>Dagger1示例 apk；点此这个链接<a href="https://db.tt/z85y4fSY" target="_blank" rel="external">https://db.tt/z85y4fSY</a>Dagger2 示例 apk。</p>
<h2 id="Rx模块">Rx模块</h2><p>   <strong>Observables</strong>赞爆了！现在稍微潮一点的小伙儿们都用RxJava了好吗！你猜结果怎么着？RxJava确实是太酷了！所以，Mosby给大家提供一个本质上是Subscriber的MvpLceRxPresenter，它能帮我们自动处理<strong>onNext()， onCompleted() 和 onError()并回调相应的LCE方法，比如showLoading(), shwoContent() </strong>和 showError()。它还将 RxAndroid 附带到observerOn() Android主要 UI 线程。你可能觉得，要是用了RxJava的话就不再需要Model View Presenter了。呃，那只是你的一家之言。在我看来，把View和Model清晰地区分开来非常重要。而且我也认为其中的某些好用的功能在没有MVP的情况下不容易执行。最后，大家要是还想回到过去那个Activity和Fragment包含了上千条又臭又长的代码行时代，那么我祝你在面条式代码的地狱里过得愉快。好了，废话不多说，我介绍的方法不属于面条式代码是因为Observerables引入了一个结构齐整的工作流，把Activity或Fragment做成一个BLOB的想法已经近在咫尺了。</p>
<h2 id="测试模块">测试模块</h2><p>大家可能注意到这里存在着一个测试模块。这个模块用于Mosby库的内部测试。但是，它也可以为我们自己的app所用。它使用Robolectric为我们的LCE Presenter， Activities 和 Fragments提供单元测试模板。它的基本功能是查看测试中的Presenter是否正确工作：通过观察presenter时候调用showLoading()，<br><strong>showContent()</strong> 和 <strong>showError()</strong>。我们还可以验证setData()中的数据。所以我们可以为Presenter和底层编写类似黑匣子的测试。Mosby的测试模块也提供了测试MvpLceFragment 或 <strong>MvpLceActivity</strong>的可能性。它相当于一种“精简版”的UI 测试。这些测试通过查看xml布局是否包含R.id.loadingView， R.id.contentView 和R.id.errorView之类的指定id、loadingView是否可视，在加载view时，是否是错误的view可视、content view能否处理由setData()提交的已加载数据等方面来检验Fragment或Activity是否正常工作，是否遇到crashing。它和Espresso类的UI测试并不相同。我觉得没有必要为LCE View单独写一个UI 测试。</p>
<p>以下是Ted Mosby库的一些测试小建议：</p>
<ol>
<li>编写传统的单元测试来测试业务逻辑层和model。</li>
<li>使用<strong>MvpLcePresenterTest</strong>来测试presenter。<br>3.使用<strong>MvpLceFragmentTest</strong> 和 <strong>MvpLceActivityTest</strong>来测试MvpLceFragment 和 Activity。<br>4.如果有必要，可以使用Espresso来编写UI测试。</li>
</ol>
<p>测试模块尚未完成。大家可以看到这个模块是测试版，因为Robolectric 3.0还没完成，而且Android gradle plugin也没用完全支持传统的单元测试。android gradle plugin </p>
<p>1.2应该会好得多。Robolectric 和 androids gradle plugin可以用了之后我会再写一篇关于Mosby，Dagger，Retrofit和RxJava单元测试的博客。</p>
<blockquote>
<ul>
<li>作者：Hannes Dorfmann</li>
<li>原文链接 : <a href="http://hannesdorfmann.com/android/mosby/" target="_blank" rel="external">http://hannesdorfmann.com/android/mosby/</a></li>
<li>文章出自 : <a href="https://github.com/bboyfeiyu/android-tech-frontier" target="_blank" rel="external">Android开发技术前线</a></li>
<li>译者 : <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a></li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我给这篇关于Android库的博客起的名字灵感来源于《老爸老妈浪漫史》中的建筑设计师Ted Mosby。这个Mosby库可以帮助大家在Android上通过Model-View-Presenter模式做出一个完善稳健、可重复使用的软件，还可以借助ViewState轻松实现屏幕翻转。<br>]]>
    
    </summary>
    
      <category term="Android架构" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Android%E6%9E%B6%E6%9E%84/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Android架构" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Android%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[当复仇者联盟遇上Dragger2、RxJava和Retrofit的巧妙结合]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/when-Thor-and-Hulk-meet-dagger2-rxjava-1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/when-Thor-and-Hulk-meet-dagger2-rxjava-1/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:03:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近，许多文章、框架和 android 社区中的讨论都出现关于测试和软件架构方面的内容，就像上次 <a href="http://es.droidcon.com/2015/speakers/" target="_blank" rel="external">Droidcon Spain</a> 上所说的，我们专注于做出健壮的程序而不是去开发特性功能。这些现象也意味着 Android 框架和当前 Android 社区的日渐成熟。<br><a id="more"></a><br>如果你是一名 Android 开发者，而到现在你还没听过 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a>、<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>、<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a> 这些名词的话你就错过了一些东西了，这个（文章）系列将会把一些关注点放在怎么用一种 <a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="external">清晰架构</a> 去综合使用这些框架。</p>
<p>我刚开始的想法是仅仅写一篇文章的，但是看到这些框架中有大量的内容所以我最终决定写一个最少 3 篇的系列文章。</p>
<p>一如既往，所有的代码都放在了 <a href="https://github.com/saulmm/Avengers" target="_blank" rel="external">Github</a>，所有的建议、错误提交和评论都欢迎，我可能没那么多时间去回答所有问题，先说声抱歉 ：）</p>
<p><img src="http://androcode.es/wp-content/uploads/2015/05/avengers_list-e1431571424213.png" alt="Avengers"></p>
<h2 id="依赖注入与_Dagger_2">依赖注入与 Dagger 2</h2><p>弄懂这个框架的工作机制花费了一些时间，所以我将会根据我所学习到的内容用更加清晰的方式写出来。</p>
<p><a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a>是基于 <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">依赖注入</a> 模式的。</p>
<p>看下下面的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thor is awesome. He has a hammer!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thor</span> <span class="keyword">extends</span> <span class="title">Avenger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AvengerWeapon myAmazingHammer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thor</span> <span class="params">(AvengerWeapon anAmazingHammer)</span> </span>&#123;</span><br><span class="line">        myAmazingHammer = anAmazingHammer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAmazingThorWork</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        myAmazingHammer.hitSomeone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>雷神（Thor）需要一个 <code>复仇者武器（AvengerWeapon）</code> 才能正确工作，依赖注入的基本思想是，如果雷神不是通过构造器创建他自己的 <code>复仇者武器</code> 而是在内部自己创建了出来那么他就不能得到很多的优势。如果雷神自己创建出雷锤将会增加耦合度。</p>
<p><code>复仇者武器（AvengerWeapon）</code> 可以是一个接口，根据我们的逻辑可以有不同的实现和注入方式。</p>
<p>在 Android 中，因为框架已经设计好了，我们并不总是能访问构造器，<code>Activity</code> 和 <code>Fragment</code>  就是这样的例子。</p>
<p>这些依赖注入器框架像 <a href="http://google.github.io/dagger/" target="_blank" rel="external">http://google.github.io/dagger/</a>、<a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a> 、<a href="https://github.com/google/guice" target="_blank" rel="external">Guice</a> 可以给我们带来便利。</p>
<p>使用 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 我们可以把之前的代码改写成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thor is awesome. He has a hammer!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thor</span> <span class="keyword">extends</span> <span class="title">Avenger</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Inject</span> AvengerWeapon myAmazingHammer;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAmazingThorWork</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            myAmazingHammer.hitSomeone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们没有直接访问雷神的构造方法，注入器使用了几个指令去创建了雷神的雷锤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class ThorHammer extends <span class="title">AvengerWeapon</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">AvengerWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        initGodHammer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Inject</code> 注解用于告诉 Dagger 2 构造器有用于创建雷神的雷锤。</p>
<h2 id="Dagger_2">Dagger 2</h2><p><a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 由 Google 开发和维护，是 <a href="https://corner.squareup.com/" target="_blank" rel="external">Square</a> 的 <a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a> 项目的分支。</p>
<p>首先必须配置注解处理器，<code>android-apt</code>  插件就是负责这个角色，允许使用注解处理器而不将其插入到最后的 .apk 中。处理器还配置由该处理器所产生的源代码。</p>
<p><code>build.gradle</code> （项目的根目录中）</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>build.gradle</code> （你的 android module 中）</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.neenbedankt.android-apt'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        apt <span class="string">'com.google.dagger:dagger-compiler:2.0'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件（Components）、模块（modules）和复仇者">组件（Components）、模块（modules）和复仇者</h2><p>模块负责提供依赖，组件负责注入它们（依赖）。</p>
<p>这是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AvengersApplication mAvengersApplication;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppModule</span><span class="params">(AvengersApplication avengersApplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mAvengersApplication = avengersApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> </span><br><span class="line">    <span class="function">AvengersApplication <span class="title">provideAvengersAppContext</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> mAvengersApplication; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> </span><br><span class="line">    <span class="function">Repository <span class="title">provideDataRepository</span> <span class="params">(RestRepository restRepository)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> restRepository; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是主模块，我们感兴趣的是它的依赖存在于程序的生命周期中，一个通用的上下文和一个取回信息的仓库。</p>
<p>很简单，对吧？</p>
<p>我们在 Dagger 2 中所说的 <code>@Provides</code>  注解，如果有需要则必须会创建其依赖。因此如果我们没有给一个特别的依赖指定一个提供者（provider），Dagger 2 将会去寻找有 <code>@Inject</code> 注解的构造方法。</p>
<p>组件使用模块去完成依赖注入，看看这个模块的组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span> <span class="annotation">@Component</span>(modules = AppModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AvengersApplication <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Repository <span class="title">dataRepository</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模块并不由任何的 activity 或者 fragment 去调用，而是通过更复杂的模块，以提供这些需要得到的依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AvengersApplication <span class="title">app</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Repository <span class="title">dataRepository</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>组件必须暴露它们的依赖给图（该模块提供的依赖关系），也即是这个模块提供的依赖关系必须对其它组件是可见的，其它的组件有把当前这个组件作为依赖，如果这些依赖关系是不可见的，Dagger 2 将不会注入这些要求的依赖。</p>
<p>下面是我们的依赖关系树：</p>
<p><img src="http://androcode.es/wp-content/uploads/2015/05/Dagger-graph.png" alt="tree of dependencies"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvengersModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Provides</span> <span class="annotation">@Activity</span></span><br><span class="line">    <span class="function">List&lt;Character&gt; <span class="title">provideAvengers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt; avengers = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Iron Man"</span>, R.drawable.thumb_iron_man, <span class="number">1009368</span>));</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Thor"</span>, R.drawable.thumb_thor, <span class="number">1009664</span>));</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Captain America"</span>, R.drawable.thumb_cap,<span class="number">1009220</span>));</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Black Widow"</span>, R.drawable.thumb_nat, <span class="number">1009189</span>));</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Hawkeye"</span>, R.drawable.thumb_hawkeye, <span class="number">1009338</span>));</span><br><span class="line"></span><br><span class="line">        avengers.add(<span class="keyword">new</span> Character(</span><br><span class="line">            <span class="string">"Hulk"</span>, R.drawable.thumb_hulk, <span class="number">1009351</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> avengers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模块将会用于一个特别的 activity 的依赖注入，实际上就是负责绘画的复仇者名单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Activity</span> </span><br><span class="line"><span class="annotation">@Component</span>(</span><br><span class="line">    dependencies = AppComponent.class, </span><br><span class="line">    modules = &#123;</span><br><span class="line">        AvengersModule.class, </span><br><span class="line">        ActivityModule.class</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AvengersComponent</span> <span class="keyword">extends</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span> <span class="params">(AvengersListActivity activity)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Character&gt; <span class="title">avengers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次，我们暴露出我们的依赖：<code>List&lt;Character&gt;</code> 给其它的组件，在这种情况下出现了一个新方法：<code>void inject (AvengersListActivity activity)</code> 。<strong>在此方法被调用时</strong>，这些依赖关系将可被消耗，将会被注入给 <code>AvengerListActivity</code> 。</p>
<h2 id="结合所有">结合所有</h2><p>我们的类 <code>AvengersApplication</code>，将负责提供应用到其他组件的组件，注意，仅仅提供组件而不会用于注入依赖。</p>
<p>再次提醒的是 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 是在编译时生成必要的元素，如果你没有构建项目你是找不到 <code>DaggerAppComponent</code> 类的。</p>
<p>Dagger 2 从你的组件中生成的类的格式：<code>Dagger$${YourComponent}.</code> 。</p>
<p><code>AvengersApplication.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvengersApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AppComponent mAppComponent;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        initializeInjector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mAppComponent = DaggerAppComponent.builder()</span><br><span class="line">            .appModule(<span class="keyword">new</span> AppModule(<span class="keyword">this</span>))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AppComponent <span class="title">getAppComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mAppComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>AvengersListActivity.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvengersListActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span><br><span class="line">    <span class="keyword">implements</span> <span class="title">AvengersView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@InjectView</span>(R.id.activity_avengers_recycler) </span><br><span class="line">    RecyclerView mAvengersRecycler;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@InjectView</span>(R.id.activity_avengers_toolbar) </span><br><span class="line">    Toolbar mAvengersToolbar;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span> </span><br><span class="line">    AvengersListPresenter mAvengersListPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_avengers_list);</span><br><span class="line">        ButterKnife.inject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        initializeToolbar();</span><br><span class="line">        initializeRecyclerView();</span><br><span class="line">        initializeDependencyInjector();</span><br><span class="line">        initializePresenter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeDependencyInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AvengersApplication avengersApplication = </span><br><span class="line">            (AvengersApplication) getApplication();</span><br><span class="line"></span><br><span class="line">        DaggerAvengersComponent.builder()</span><br><span class="line">            .avengersModule(<span class="keyword">new</span> AvengersModule())</span><br><span class="line">            .activityModule(<span class="keyword">new</span> ActivityModule(<span class="keyword">this</span>))</span><br><span class="line">        .appComponent(avengersApplication.getAppComponent())</span><br><span class="line">            .build().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>当 <code>initializeDependencyInjector()</code> 中执行到 <code>.inject(this)</code> 中时 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 就会开始工作并提供必要的依赖关系，请记住 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 在注入时是严格执行的，我要说的意思是组件必须是 <strong>完全相同</strong> 的组件类，此组件类负责调用 <code>inject()</code> 方法。</p>
<p><code>AvengersComponent.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AvengersComponent</span> <span class="keyword">extends</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span> <span class="params">(AvengersListActivity activity)</span></span>;</span><br><span class="line">    <span class="function">List&lt;Character&gt; <span class="title">avengers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>否则，依赖关系将不会被解决。在如下情况，presenter 与由 Dagger 2 提供的复仇者一起初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvengersListPresenter</span> <span class="keyword">implements</span> <span class="title">Presenter</span>, <span class="title">RecyclerClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Character&gt; mAvengersList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> AvengersView mAvengersView;</span><br><span class="line">    <span class="keyword">private</span> Intent mIntent;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span> <span class="function"><span class="keyword">public</span> <span class="title">AvengersListPresenter</span> <span class="params">(List&lt;Character&gt; avengers, Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mAvengersList = avengers;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 将会解决这个 presenter，因为其有 <code>@Inject</code> 注解。该构造方法的参数由 Dagger 2 解决，因为它知道怎么去构建它，这得益于这个模块中的 <code>@Provides</code> 方法。</p>
<h2 id="总结">总结</h2><p>像 <a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2</a> 这样，使用好了依赖注入器，其力量是无可争辩的，想象下根据该框架提供的 API 级别你可以有不同的策略，其可能性是无止境的。</p>
<h2 id="资源">资源</h2><ul>
<li><p><strong>Chiu-Ki Chan</strong> - <a href="http://blog.sqisland.com/2015/04/dagger-2-espresso-2-mockito.html" target="_blank" rel="external">Dagger 2 + Espresso + Mockito</a></p>
</li>
<li><p><strong>Fernando Cejas</strong> - <a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="external">Tasting Dagger 2 on Android</a></p>
</li>
<li><p><strong>Google Developers</strong> - <a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">Dagger 2, A new type of dependency injection</a></p>
</li>
<li><p><strong>Mike Gouline</strong> - <a href="http://blog.gouline.net/2015/05/04/dagger-2-even-sharper-less-square/" target="_blank" rel="external">Dagger 2, Even sharper, less square</a></p>
</li>
</ul>
<blockquote>
<ul>
<li>原文链接 : <a href="http://saulmm.github.io/when-Thor-and-Hulk-meet-dagger2-rxjava-1/" target="_blank" rel="external">When the Avengers meet Dagger2, RxJava and Retrofit in a clean way</a></li>
<li>原文作者 : <a href="http://saulmm.github.io/" target="_blank" rel="external">Saúl M</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/zhengxiaopeng" target="_blank" rel="external">zhengxiaopeng</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，许多文章、框架和 android 社区中的讨论都出现关于测试和软件架构方面的内容，就像上次 <a href="http://es.droidcon.com/2015/speakers/">Droidcon Spain</a> 上所说的，我们专注于做出健壮的程序而不是去开发特性功能。这些现象也意味着 Android 框架和当前 Android 社区的日渐成熟。<br>]]>
    
    </summary>
    
      <category term="RxJava/RxAndroid" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自动化 Android 开发]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/automating-android-development/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/automating-android-development/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>我最近已经在 <a href="http://es.droidcon.com/2015/" target="_blank" rel="external">DroidCon Spain</a> 和 <a href="http://it.droidcon.com/2015/" target="_blank" rel="external">DroidCon Italy</a> 讨论过关于如何自动化传统的Android工作流。<br>令我惊讶的是，仍然还有很多组织缺少执行持续集成（CI）的策略。这是一个巨大的灾难！<br>我决定用文字表达我的思想，就是如何高效的实现持续集成（CI）。<br><a id="more"></a><br>作为一个软件攻城狮，你的目标应该是尽可能多的自动化许多工作流程。<br>计算机比人更高效，它们不需要吃饭睡觉，它们的任务表现没有错误，并且它们使你的生活更轻松。<br>请记住：<em>做的越多是为了了做的更少</em></p>
<p>持续集成（CI）尽管是一个包含许多不同要点的综合领域，并且你需要把它们整合在一起。<br>比如，你需要讨论 Jira，你需要关心测试和分支，你需要脚本和构建。</p>
<p>这里有一大块我想在这个帖子中介绍的。他们的每一点都值得展开介绍，但这不是这篇文章的目的。其目的是展示给你每个基础知识，以及如何组合他们。</p>
<ol>
<li>定义一个分支策略。</li>
<li>使用敏捷方法</li>
<li>Gradle和构建脚本</li>
<li>测试</li>
<li>使用CI服务器。</li>
</ol>
<h3 id="分支策略">分支策略</h3><p>分支是重要的。当你正在构建一个新的产品，你想建立一个协议如何工作。<br>人们怎么应该提交自己的特性？我们如何发布？我们如何保证不正在破坏什么东西？<br>要回答这些问题，你需要采用分支策略。</p>
<p>我正在使用一个经过轻微修改的由 <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">Vincent Driessen</a> 提出的分支策略。<br>让我们考虑我们应用程序的三种状态：<strong>alpha</strong>, <strong>beta</strong> 和 <strong>release</strong>.</p>
<ul>
<li><strong>Alpha</strong> 的状态是你的系统正在开发。</li>
<li><strong>Beta</strong> 当你测试的功能已被批准和合并。</li>
<li><strong>Release</strong> 是当系统可交付的状态。</li>
</ul>
<blockquote>
<p>(一些人喜欢叫 alpha 为 “develop” ，并且 beta 为 “stage”. 我认为希腊字母表的字母总是更cool的).</p>
</blockquote>
<p>下面的图片是一个项目的第一个状态。你有一个初始的提交到了master分支。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*CWNjrbmm5jQ0uvp-L53EYg.png" alt="image"></p>
<p>我们的系统才刚刚开始。只有第一个提交在master分支，其他分支还是空的。<br>追着工作时间的进行。你需要从初始状态进入到develop过程。这将是你的1.0.1版本。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*JLekFIGh6ciEvj52w3hddA.png" alt="image"></p>
<blockquote>
<p>在这个点上，alpha的确与master相同</p>
</blockquote>
<p>现在，你会在功能特性上开始工作。对于每一个特性，你会创建一个分支。<br>使用正确的命名是很重要的，有几种方法可以做到这一点。如果您使用的是一个问题跟踪系统像 <a href="https://www.atlassian.com/software/jira" target="_blank" rel="external">Jira</a>，你可能会用一个与功能相关联的标签名（比如 FEATURE-123）。<br>当我提交特性时，我会包括分支名在提交信息里，并添加一个完整的描述。</p>
<pre><code>*[FEATURE-<span class="number">123</span>] Created <span class="operator">a</span> <span class="built_in">new</span> screen that performs <span class="operator">an</span> action.*
</code></pre><p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*wKF9mdhTLC8MFdy02WJ1EQ.png" alt="image"></p>
<p>注意，在每个分支的项目里都有自己的版本号。您可以使用 <a href="http://git-scm.com/book/en/v2/Git-Basics-Tagging" target="_blank" rel="external">git tags</a> 来执行版本号的控制</p>
<p>当一个功能已经完成，一个 pull request 就开放了，所以你的组织的其他成员就可以批准它。这是为了确保你提供高质量软件的一个关键部分。在 <a href="http://www.sixt.de/mobileapps/" target="_blank" rel="external">Sixt</a>，另一成员被分配到你的代码审查，这个人会通读你全部的代码。<br>我们保证我们的代码是符合我们的<a href="https://speakerdeck.com/kikoso/android-coding-guidelines" target="_blank" rel="external">coding conventions</a>和我们对过程中严格的要求，典型的如在XML文件中有一个额外的空格。我们评论的命名（“函数名我不清楚”），检查我们的设计是完美的（“你的文本视图的颜色 #DCDCDC 但设计是 #DEDEDE”）有一个功能测试去检查该特性是覆盖了在问题跟踪里编写的验收标准的。<br>我们甚至进行一些哲学讨论，比如关于null和void或empty变量的意义。这听起来令人讨厌，但它是有趣的。如果是充满热情的做了这一切，到时候你就知道你的代码达到了产品需要的提交质量。</p>
<h3 id="敏捷和迭代">敏捷和迭代</h3><p>你可能会在执行<a href="http://en.wikipedia.org/wiki/Scrum_%28software_development%29" target="_blank" rel="external">SCRUM</a>, <a href="http://en.wikipedia.org/wiki/Kanban_%28development%29" target="_blank" rel="external">Kanban</a>或另外的敏捷方法。通常你会进行在几个星期的冲刺工作。我们认为是一个好主意，把冲刺分到两周：第一周是用来开发特性，而第二周将稳定在第一阶段创造的特性。在第二个冲刺中，我们将修复发现的漏洞，实现完美的布局或提高重构我们的代码。这项工作是在 <strong>beta/stage</strong> 分支完成的。<br>如下图所示</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*7lynNxY8iQpFHCee_Rkjjg.png" alt="image"></p>
<blockquote>
<p>这些黄点属于bug修复和稳定性阶段</p>
</blockquote>
<p>如果你遵循我们的约定，敏捷结束时你将会有一个可交付的成果。这将是一个准备发表在谷歌商店的可交付文件。此时此刻，我们的应用程序的最后版本已经合并到了master。<br>另一个非常重要的课题是如何创建一个热修复补丁。我们的模型试图通过使用代码检查和修复bug和产品稳定的第二周来阻止他们发生，但错误确实已经发生。这是发生在生产时，这种模式要求错误直接被修正在 <strong>master</strong> 分支。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*sdL8HDfMgoNuhnLKu7Soew.png" alt="image"></p>
<p>你有没有意识到这个模型的标志？是的，就是那！该热修复补丁是不存在在我们的 <strong>alpha/beta</strong> 的分支。经过修复和稳定期后（第二周），我们的 <strong>alpha</strong> 分支是旧状态，错误仍然是存在的。我们需要立即合并到各分支来保证正确，从而确保每一个修复是存在所有的分支的。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Rijzdkk4SA4T9T3koBAXCg.png" alt="image"></p>
<p>很难理解？可能是读起来比实施来的难。<br>如果你没有一个分支策略，只是试图使用这个模型来开发一个特性。你会发现很容易工作，而且你甚至会开始定制！</p>
<h3 id="Gradle_和脚本化">Gradle 和脚本化</h3><p>现在您已经阅读分支模型，我们准备继续讨论接下来的步骤。Gradle是一个工具,将帮助我们自动完成很多事情。你可能熟悉Gradle(或其它家族成员,Maven和Ant)。Gradle是一个项目的自动化工具，当我们正在建设我们的应用程序时，可以使用执行功能和定义属性。它介绍了一种基于Groovy的领域语言，它能做到的基本上只受限于我们的想象力。</p>
<p>我以前写的一个 <a href="http://codetalk.de/?p=112" target="_blank" rel="external">post</a> 和一些技巧来使用工具。他们中的一些将非常有用，包括对于你的应用，但之后也有一些我已经应用的，我想在这里介绍。</p>
<h4 id="构建配置（BuildConfig）的力量">构建配置（BuildConfig）的力量</h4><p>当我们编译Android应用程序时，<em>BuildConfig</em> 是一个自动生成的文件。这个文件，默认情况下，看起来如下：</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*wkoXjbSYaYymUhZrO8-jRw.png" alt="image"></p>
<p>BuildConfig 包含一个字段，叫 <strong>DEBUG</strong>，指示应用程序是否已经编译在调试模式。这个文件是高度可定制的，当我们工作在不同的构造类型时，这是非常便利的。</p>
<p>应用程序通常使用服务工具追踪其行为 <a href="http://www.google.com/analytics/ce/mws/" target="_blank" rel="external">Google Analytics</a>, <a href="https://try.crashlytics.com/" target="_blank" rel="external">Crashlytics</a> 或其他平台。当我们正在开发应用时，我们可能不想影响这些指标（想象一个用户界面的测试，自动发布的每一天，跟踪您的登录屏幕？）。我们也会根据我们的构建有不同的域名（例如development.domain.com, staging.domain.com…），我们要使用自动的。但我们怎么可以做的干净利落？容易！在Gradle的buildTypes域，我们可以添加任何我们希望的新域。这些域将通过<em>BuildConfig</em> 在以后可用（这意味着，我们可以使用 BuildType.FIELD 来读取它们）。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Z_YYrTPF7FTShHAt5tqW3g.png" alt="image"></p>
<p>在 <a href="http://codetalk.de/?p=112" target="_blank" rel="external">this post</a> 我展示了如何使用不同的图标和如何改变包的名称。利用这个我们可以安装我们应用程序的不同版本。这能够非常方便的同时看到我们的 beta, alpha 和 release 版本。</p>
<h3 id="保持测试">保持测试</h3><p>测试本身，和整个过程都有它自己的中间环节。当我们谈论测试就是我们在谈论模拟的组件，关于UI测试和集成测试，关于仪器，和所有对于Android可用的不同框架。</p>
<p>测试是非常重要的，因为它可以防止开发者破坏现有的东西。没有测试，当我们开发一个新的功能B时，我们可以很容易地干扰一个旧的特性A。当一个新的特征被提交，是很难手动测试整个系统的，但自动的做这些就更容易控制一个系统的稳定性。</p>
<p>这里有了许多不同的测试可以在移动设备上实施：只是列举几个，我们可以考虑，集成测试，功能测试，性能测试和用户界面测试。每一种都有不同的功能，它们一般是定期触发以确保新功能没有破坏或干扰系统。</p>
<p>为了展示一个基本的例子，如何将测试在 Jenkins 集成（以及他们如何实现生成出错时停止的功能）<br>我们将看到一个做UI测试的小例子 <a href="https://code.google.com/p/android-test-kit/wiki/Espresso" target="_blank" rel="external">Espresso</a> 每次都是在 Jenkins 构建测试我们的Android应用程序。</p>
<h3 id="一个应用程序的示例">一个应用程序的示例</h3><p>我创建了一个小示例应用程序并上传到 <a href="https://github.com/kikoso/Android-Testing-Espresso" target="_blank" rel="external">GitHub</a>，所以你可以来这里看看。也有一些分支使用命名约定和 pull requests，直到现在你可以看到审查的一切解释。该应用程序是相当基本的：它有一个TextView屏幕。还有三个已在文件执行的UI测试单元<br><a href="https://github.com/kikoso/Android-Testing-Espresso/blob/master/src/androidTest/java/com/dropsport/espressoreadyproject/tests/MainActivityInstrumentationTest.java" target="_blank" rel="external">MainActivityInstrumentationTest</a>:</p>
<ol>
<li>检查在屏幕上存在一个TextView。</li>
<li>检查TextView包含文本“Hello World!”</li>
<li>检查TextView包含文本“What a label!”</li>
</ol>
<p>最后的两个试验是互斥的（这意味着，无论是一个或另一个是成功的，但不能两者同时成立）。我们通过以下命令对应用进行测试：</p>
<pre><code>./gradlew clean connected<span class="variable">Check</span>.
</code></pre><p>如果你检出了代码，你可以自己试试注释功能 <em>testFalseLabel</em>。这将使测试失败。</p>
<h3 id="把一切都集成在_Jenkins">把一切都集成在 Jenkins</h3><p>现在，我们已经检查了一些事情，让我们看看他们如何适配 Jenkins。如果你没有安装它，你可以从网站下载 <a href="https://jenkins-ci.org/" target="_blank" rel="external">last version</a>。</p>
<p>我们没有提到一些东西，但这里也有分支策略。<br>有许多不同的方法，它们都具有各自的优点和缺点：</p>
<ol>
<li>你可以在分支构建前触发测试。</li>
<li>你可以晚上或每日构建，不要阻止构建，但如果失败仍然要发出通知。</li>
</ol>
<p>在本教程中我选择了第一种方法，也是为了显示 Jenkins 的一大特征：jobs 之间的依赖关系。让我们创造三个 jobs：<strong>Job Beta</strong>, <strong>Job Alpha</strong> and <strong>Job Tests</strong>。</p>
<ol>
<li><strong>Job Alpha</strong> 将构建 alpha 分支 (通过 ./gradlew clean assembleAlpha)</li>
<li><strong>Job Beta</strong> 将做同样的工作在 beta 分支上（通过 ./gradlew clean assemblebeta）。这是每一次有分支合并到 beta 分支上就会执行的</li>
<li><strong>Job Tests</strong> 每次有分支合并到 alpha 分支时都将触发。如果它成功了，它会引发 <strong>Job Alpha</strong>。</li>
</ol>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*OPzV-aZLBGxdPYWPIip8Bg.png" alt="image"></p>
<p>Jenkins 是一个基于大量的插件的平台。许多公司正在为他们的产品不断地发布插件，他们将集成在 Jenkins，我们可以很容易地与其他平台连接。<br>让我们看看在 Jenkins 的一些选项</p>
<h4 id="依赖">依赖</h4><p>使用依赖 Jenkins 可以互连项目。也许我们要连接测试 jobs 和基于试验结果来控制启动。或许我们在实际构建应用之前，部分逻辑首先存在需要编译的lib库里。</p>
<h4 id="通知">通知</h4><p>Jenkins 可以通知一个人或一个工作组或构建错误。通知一般是电子邮件，但也有插件可以通过IM系统发送消息，如 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Skype+Plugin" target="_blank" rel="external">Skype</a> 或者 <a href="https://wiki.jenkins-ci.org/display/JENKINS/SMS+Notification" target="_blank" rel="external">SMS</a>（最新版当你有重要的测试失败时可以很方便的通知）。</p>
<h4 id="交付">交付</h4><p>你可能知道，在这一点上 <a href="http://hockeyapp.net/" target="_blank" rel="external">HockeyApp</a> 或另一个 <a href="http://alternativeto.net/software/hockeyapp/" target="_blank" rel="external">delivery platforms</a>。他们基本上可以存储二进制文件，创建组，并当应用程序被上传时通知他们。想象看测试者自动在他/她的设备上接收每次他们被创造的文件，和产品所有者被通知有新的beta版的情景。这里有一个Jenkins 插件 <a href="https://wiki.jenkins-ci.org/display/JENKINS/HockeyApp+Plugin" target="_blank" rel="external">HockeyApp plugin</a> 能够上传二进制文件到 Hockey（甚至通知成员，或作为你最近提交的 release notes 使用）。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*P6-P4hBkKfAG7Ls0bzXeEQ.png" alt="image"></p>
<p>我还是喜欢保持手动发布产品的步骤，这可能是由于在出版过程中不经过人工控制的一种担心。但是，确实有一个 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Google+Play+Android+Publisher+Plugin" target="_blank" rel="external">plugin</a> 用来直接发步到 Google Play。</p>
<h3 id="结论">结论</h3><p>在 <em>building</em>, <em>testing</em>, <em>delivering</em> 和 <em>publishing</em> 实现自动化，主要是在一个团队工作中选择正确的决策。当这个决定是明确的，我们才可以继续去技术上实现。</p>
<p>有一件事情是肯定的：错误会由于以往人们的行动而大幅度减少，并结合强大的测试覆盖率，我们的软件质量将大大提高。这里我借用同事的座右铭 <a href="https://developers.google.com/experts/people/cyril-mottier" target="_blank" rel="external">Cyril Mottier</a>：</p>
<blockquote>
<p>致精而大</p>
</blockquote>
<p>这是你职业生涯中的一个重要时刻！当你想在工作中保证 <strong>质量</strong> 而努力，而不是 <strong>数量</strong> 的多少。我了解这件事，第一步是尽你所能的实现自动化。事实上，我可以用以前的口号改述为另一句话，我将在我的日常生活里：</p>
<blockquote>
<p>自动化的更多，所以你被动化的更少</p>
</blockquote>
<p>祝：快乐编程！</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/fit/c/63/63/1*AV6Ju95BJPkkIXg1x8Ni1w.jpeg" alt="image" title="Enrique López Mañas"></p>
<blockquote>
<ul>
<li>原文链接：<a href="https://medium.com/google-developer-experts/automating-android-development-6daca3a98396" target="_blank" rel="external">Automating Android development</a></li>
<li>原文作者：<a href="https://medium.com/google-developer-experts/automating-android-development-6daca3a98396" target="_blank" rel="external">Enrique López Mañas</a></li>
<li>译者：<a href="https://github.com/tmc9031" target="_blank" rel="external">tmc9031</a></li>
<li>校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a></li>
<li>状态：完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我最近已经在 <a href="http://es.droidcon.com/2015/">DroidCon Spain</a> 和 <a href="http://it.droidcon.com/2015/">DroidCon Italy</a> 讨论过关于如何自动化传统的Android工作流。<br>令我惊讶的是，仍然还有很多组织缺少执行持续集成（CI）的策略。这是一个巨大的灾难！<br>我决定用文字表达我的思想，就是如何高效的实现持续集成（CI）。<br>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 自动截屏工具]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/automating-android-screenshots/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/29/automating-android-screenshots/</id>
    <published>2015-05-28T16:00:00.000Z</published>
    <updated>2015-07-11T09:01:51.000Z</updated>
    <content type="html"><![CDATA[<p>随着mac版本AndroidTool的发布，获取android应用截屏变得非常简单。与此同时，感谢开发商！这对于我们开发者来说真是太好了！<br><a id="more"></a><br>对于简单应用来说，AndroidTool是足够满足截屏的功能需求了，然而，我需要在在我正在开发的一款app上完成一个完全自动化的截图过程，并且将截图发布到应用市场。我认为这将不简单，所以，我尽量避免复杂的实现过程，而是想办法如何更好的结合AndroidTool来完成这个功能。</p>
<p>然而当我昨天阅读了<a href="https://medium.com/@enriquelopezmanas" target="_blank" rel="external">Enrique López Mañas yesterday</a>的<a href="https://medium.com/google-developer-experts/automating-android-development-6daca3a98396" target="_blank" rel="external">Automating Android development</a>文章，我意识到，他在博客中讨论的话题我已经完成了4/5。唯一我还没有做的就是测试。我不喜欢测试，然而，那篇文章激励着我去尝试写测试代码。。 所以，我今天早上尝试了一下。经过几个小时编写测试代码，我意外的找到了自动化截图的解决方案。</p>
<p>在这片文章中，我将会谈论关于如何通过ui 测试来完成自动截图和提交这些截图到应用商店。</p>
<h2 id="UI_Automator查看器">UI Automator查看器</h2><p>‘uiautomatorviewer’是一个非常强大的工具来查看views，当发现极好的布局时，我通常会使用‘uiautomatorviewer’来查看，如果你运行这个工具将会获得下图所示。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/2000/1*2GVDSxydFfqY4WvXBBVQ1Q.png" alt=""></p>
<p>通过这个工具你可以看到UI对象，在这里，我可以检测TextView的id，这个技巧在稍后会变得非常有用。。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/2000/1*9yNBO3PwetoOv7EWEChsag.png" alt=""></p>
<h2 id="UI_Automator">UI Automator</h2><p>Google在<a href="https://developer.android.com/tools/testing-support-library/index.html" target="_blank" rel="external">Android Testing Support Library</a>里面同时也提供了一个叫做‘UI Automator’ 的库，它允许开发者自动化获取用户交互过程。</p>
<p>使用UI Automator时，你需要在你的项目中添加依赖，具体配置信息需要填写在<code>build.gradle</code>里面。</p>
<p>正如<a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html#run" target="_blank" rel="external">文档</a>中所说。你需要指定<a href="https://developer.android.com/reference/android/support/test/runner/AndroidJUnitRunner.html" target="_blank" rel="external">AndroidJUnitRunner</a>作为你默认的测试工具。</p>
<p>UI Automator 里面频繁使用的类有：UiDevice, UiSelector, UiObject, and UiScrollable.</p>
<p>我们将会在androidTestScreenshot文件夹下创建一个简单的测试类，并且这个类继承InstrumentationTestCase。</p>
<p>这个过程很直接：</p>
<p>首先，监听设备点击“Home”键时，执行UiDevice 的方法pressHome()。在每一个测试里面，我们做这样重复性的工作：</p>
<p>从最开始的地方打开app。我个人发现一个简答的方法去获取截屏。你可以使用UiDevice的pressBack()方法为其他测试。</p>
<p>获取想要的UI交互可以使用UiSelector, UiScrollable, and UiObject。</p>
<p>使用SystemClock.sleep方法，为异步任务的执行腾出一些时间（异步任务的执行可能在截屏之后），以此来避免发生截屏获取的为空异常和UiObject not found异常。</p>
<p>最后我们截屏并且将获取的截屏保存在指定的位置。</p>
<p>到目前为止，你可能已经了解了如何使用uiautomatorviewer来帮助我们获取许多我们想要的UI元素，然而，我使用UiSelector().resourceId，因为我们可以通过我们在layout里面使用的id来完成截屏，这样不是更加简单了吗？你也可以有其他选择，比如使用 className, text, etc… 来完成这一过程。</p>
<h2 id="Product_Flavor">Product Flavor</h2><p>我不知道为什么UiAutomator下的minSdkVersion是18，因为我需要minSdk至少是14，我需要使用这个额外的方法。如果这里有任何其他方法可以避免我自己去实现截屏的，请让我知道。</p>
<p>Android使用androidTest来实现主要的测试工作，也为了实现不同产品的写测试需要，我们需要写我们的测试在androidTestFlavorName文件夹。这就是为什么我们在androidTestScreenshot路径下创建SimpleUiTest 类的原因。</p>
<p>万事具备，现在，运行<code>gradle connectedAndroidTestScreenshotDebug</code>。在这个测试完成后你将会获得屏幕截图。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/@swanhtet1992/automating-android-screenshots-5b7574c0621d" target="_blank" rel="external">Automating Android Screenshots</a></li>
<li>原文作者 : <a href="https://medium.com/@swanhtet1992" target="_blank" rel="external">Swan Htet Aung</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/sundroid" target="_blank" rel="external">sundroid</a> </li>
<li>校对者: <a href="https://github.com/yinna317" target="_blank" rel="external">yinna317</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>随着mac版本AndroidTool的发布，获取android应用截屏变得非常简单。与此同时，感谢开发商！这对于我们开发者来说真是太好了！<br>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 进行单元测试难在哪-part3]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/how-to-make-our-android-apps-unit-testable-pt-1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/how-to-make-our-android-apps-unit-testable-pt-1/</id>
    <published>2015-05-23T16:00:00.000Z</published>
    <updated>2015-07-11T08:56:46.000Z</updated>
    <content type="html"><![CDATA[<p>在 Android 应用中进行单元测试很困难，有时候甚至是不可能的。在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-9/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part1.md" target="_blank" rel="external">之前的两篇博文</a>中，我已经向大家解释了在 Android 中进行单元测试如此困难的原因。而<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-10/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part2.md" target="_blank" rel="external">上一篇博文</a>我们通过分析得到的结论是：正是 Google 官方所提倡的应用架构方式使得在 Android 中进行单元测试变成一场灾难。因为在官方提倡的架构方式中，Google 似乎希望我们将业务逻辑都放在应用的组件类中（例如：Activity，Fragment，Service，等等……）。而这种开发方式也是我们一直以来使用的开发模板。<br><a id="more"></a><br>在这篇博文中，我列举出几种架构 Android 应用的方法，使用这些方法进行开发能让单元测试变得轻松些。但正如我在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-8/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-%E5%BA%8F.md" target="_blank" rel="external">序</a>中所说，我最推崇的办法始终是<a href="https://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external"> Square 在他们的应用中抛弃 Fragment </a>所用的通用方法。因为这个方法是由 Square 中的 Android 开发工程师想出来的，所以我会在接下来的博文中将这个办法叫作“Square 大法”。</p>
<p>Square 大法的核心思想是：把应用组件类中的业务逻辑全部移除（例如：Activity，Fragment，Service，等等……），并且把业务逻辑转移到业务对象，而这些业务对象都是被依赖注入的纯 Java 对象，以及与 Android 无关的接口在此的 Android 特定实现。如果我们在开发应用的时候使用 Square 大法，那进行单元测试就简单多了。在这篇博文中，我会解释 Square 大法是如何帮助我们重构 UI 无关的应用组件（例如我们在之前的博文中讨论的 SessionCalendarService），并让对它进行单元测试变得容易许多。</p>
<h2 id="用_Square_大法重构_UI_无关的应用组件">用 Square 大法重构 UI 无关的应用组件</h2><p>用 Square 大法重构类似于 Service，ContentProvider，BroadcastReceiver这样的 UI 无关的应用组件相对来说比较容易。我再说一次我们要做的事情吧：把在这些类中的业务逻辑移除，并把它们放到业务对象中。</p>
<p>由于“业务逻辑”是很容易有歧义的词语，我来解释下我使用“业务逻辑”这个词时，它所代表的含义吧。当我提到“业务逻辑”，它的含义和维基百科上的解释是一致的：程序中根据现实世界中的规则用于决定数据将如何被创建，展示，储存和修改的那部分代码。那么现在我们就可以就“业务逻辑”这个词的含义达成共识了，那就来看看 Square 大法到底是啥吧。</p>
<p>我们先来看看怎么用 Square 大法实现我在之前的博文中介绍的 SessionCalendarService 吧，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Background &#123;<span class="doctag">@link</span> android.app.Service&#125; that adds or removes session Calendar events through</span><br><span class="line"> * the &#123;<span class="doctag">@link</span> CalendarContract&#125; API available in Android 4.0 or above.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCalendarService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = makeLogTag(SessionCalendarService.class);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionCalendarService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TAG);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        Log.d(TAG, <span class="string">"Received intent: "</span> + action);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> ContentResolver resolver = getContentResolver();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ACTION_ADD_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">            isAddEvent = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_REMOVE_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">            isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_UPDATE_ALL_SESSIONS_CALENDAR.equals(action) &amp;&amp;</span><br><span class="line">                PrefUtils.shouldSyncCalendar(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getContentResolver().applyBatch(CalendarContract.AUTHORITY,</span><br><span class="line">                        processAllSessionsCalendar(resolver, getCalendarId(intent)));</span><br><span class="line">                sendBroadcast(<span class="keyword">new</span> Intent(</span><br><span class="line">                        SessionCalendarService.ACTION_UPDATE_ALL_SESSIONS_CALENDAR_COMPLETED));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                LOGE(TAG, <span class="string">"Error adding all sessions to Google Calendar"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OperationApplicationException e) &#123;</span><br><span class="line">                LOGE(TAG, <span class="string">"Error adding all sessions to Google Calendar"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_CLEAR_ALL_SESSIONS_CALENDAR.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getContentResolver().applyBatch(CalendarContract.AUTHORITY,</span><br><span class="line">                        processClearAllSessions(resolver, getCalendarId(intent)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                LOGE(TAG, <span class="string">"Error clearing all sessions from Google Calendar"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (OperationApplicationException e) &#123;</span><br><span class="line">                LOGE(TAG, <span class="string">"Error clearing all sessions from Google Calendar"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> Uri uri = intent.getData();</span><br><span class="line">        <span class="keyword">final</span> Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (uri == <span class="keyword">null</span> || extras == <span class="keyword">null</span> || !PrefUtils.shouldSyncCalendar(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resolver.applyBatch(CalendarContract.AUTHORITY,</span><br><span class="line">                    processSessionCalendar(resolver, getCalendarId(intent), isAddEvent, uri,</span><br><span class="line">                            extras.getLong(EXTRA_SESSION_START),</span><br><span class="line">                            extras.getLong(EXTRA_SESSION_END),</span><br><span class="line">                            extras.getString(EXTRA_SESSION_TITLE),</span><br><span class="line">                            extras.getString(EXTRA_SESSION_ROOM)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error adding session to Google Calendar"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationApplicationException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error adding session to Google Calendar"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，SessionCalendarService 调用了将要在后面定义的 helper 方法。一旦我们将这些 helper 方法和类的字段声明也考虑进来，Service 类的代码就有400多行。要 hold 住这么庞大的类内发生的业务逻辑可不是什么简单的活，而且就像我们在上一篇博文中看到的那样，要在 SessionCalendarService 中进行单元测试简直是天方夜谭。</p>
<p>那现在来看看用 Square 大法实现它代码会是怎样的。我再强调一次：Square 大法需要我们将 Android 类内的业务逻辑迁移到一个业务对象中。在这里，SessionCalendarService 所对应的业务对象则是 SessionCalendarUpdater，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCalendarUpdater</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> SessionCalendarDatabase mSessionCalendarDatabase;</span><br><span class="line">    <span class="keyword">private</span> SessionCalendarUserPreferences mSessionCalendarUserPreferences;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionCalendarUpdater</span><span class="params">(SessionCalendarDatabase sessionCalendarDatabase,</span><br><span class="line">                                  SessionCalendarUserPreferences sessionCalendarUserPreferences)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        mSessionCalendarDatabase = sessionCalendarDatabase;</span><br><span class="line">        mSessionCalendarUserPreferences = sessionCalendarUserPreferences;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCalendar</span><span class="params">(CalendarUpdateRequest calendarUpdateRequest)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">boolean</span> isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        String action = calendarUpdateRequest.getAction();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> calendarId = calendarUpdateRequest.getCalendarId();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ACTION_ADD_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">            isAddEvent = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_REMOVE_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">            isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_UPDATE_ALL_SESSIONS_CALENDAR.equals(action)</span><br><span class="line">                &amp;&amp; mSessionCalendarUserPreferences.shouldSyncCalendar()) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                mSessionCalendarDatabase.updateAllSessions(calendarId);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException | OperationApplicationException e) &#123;</span><br><span class="line"> </span><br><span class="line">                LOGE(TAG, <span class="string">"Error adding all sessions to Google Calendar"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_CLEAR_ALL_SESSIONS_CALENDAR.equals(action)) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                mSessionCalendarDatabase.clearAllSessions(calendarId);</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException | OperationApplicationException e) &#123;</span><br><span class="line"> </span><br><span class="line">                LOGE(TAG, <span class="string">"Error clearing all sessions from Google Calendar"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!shouldUpdateCalendarSession(calendarUpdateRequest, mSessionCalendarUserPreferences)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            CalendarSession calendarSessionToUpdate = calendarUpdateRequest.getCalendarSessionToUpdate();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (isAddEvent) &#123;</span><br><span class="line"> </span><br><span class="line">                mSessionCalendarDatabase.addCalendarSession(calendarId, calendarSessionToUpdate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">                mSessionCalendarDatabase.removeCalendarSession(calendarId, calendarSessionToUpdate);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException | OperationApplicationException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error adding session to Google Calendar"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldUpdateCalendarSession</span><span class="params">(CalendarUpdateRequest calendarUpdateRequest, </span><br><span class="line">                                                SessionCalendarUserPreferences sessionCalendarUserPreferences)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> calendarUpdateRequest.getCalendarSessionToUpdate() == <span class="keyword">null</span> || !sessionCalendarUserPreferences.shouldSyncCalendar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想要强调其中的一些要点：首先，需要注意，我们完全不需要用到任何新的关键字，因为业务对象的依赖都被注入了，它根本不会使用新的关键字，而这正是让类可单元测试的关键。其次，你会注意到类没有确切地依赖于 Android SDK，因为业务对象的依赖都是 Android 无关接口的 Android 特定实现，因此它不需要依赖于 Android SDK。</p>
<p>那么这些依赖是怎么添加到　SessionCalendarUpdater　类中的呢？是通过　SessionCalendarService　类注入进去的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Background &#123;<span class="doctag">@link</span> android.app.Service&#125; that adds or removes session Calendar events through</span><br><span class="line"> * the &#123;<span class="doctag">@link</span> CalendarContract&#125; API available in Android 4.0 or above.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCalendarService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = makeLogTag(SessionCalendarService.class);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SessionCalendarService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TAG);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        Log.d(TAG, <span class="string">"Received intent: "</span> + action);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> ContentResolver resolver = getContentResolver();</span><br><span class="line"> </span><br><span class="line">        Broadcaster broadcaster = <span class="keyword">new</span> AndroidBroadcaster(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        SessionCalendarDatabase sessionCalendarDatabase = <span class="keyword">new</span> AndroidSessionCalendarDatabase(resolver,</span><br><span class="line">                                                                                             broadcaster);</span><br><span class="line"> </span><br><span class="line">        SharedPreferences defaultSharedPreferences = PreferenceManager.getDefaultSharedPreferences(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        SessionCalendarUserPreferences sessionCalendarUserPreferences = <span class="keyword">new</span> AndroidSessionCalendarUserPreferences(defaultSharedPreferences);</span><br><span class="line"> </span><br><span class="line">        SessionCalendarUpdater sessionCalendarUpdater</span><br><span class="line">                                    = <span class="keyword">new</span> SessionCalendarUpdater(sessionCalendarDatabase,</span><br><span class="line">                                                                 sessionCalendarUserPreferences);</span><br><span class="line"> </span><br><span class="line">        AccountNameRepository accountNameRepository = <span class="keyword">new</span> AndroidAccountNameRepository(intent, <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">        String accountName = accountNameRepository.getAccountName();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">long</span> calendarId = sessionCalendarDatabase.getCalendarId(accountName);</span><br><span class="line">        CalendarSession calendarSessionToUpdate = CalendarSession.fromIntent(intent);</span><br><span class="line"> </span><br><span class="line">        CalendarUpdateRequest calendarUpdateRequest = <span class="keyword">new</span> CalendarUpdateRequest(action, calendarId, calendarSessionToUpdate);</span><br><span class="line"> </span><br><span class="line">        sessionCalendarUpdater.updateCalendar(calendarUpdateRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，修改后的 SessionCalendarService 到处都是新的关键字，但这些关键字在类中并不会引起什么问题。如果我们花几秒时间略读一下要点就会明白这一点：SessionCalendarService 类中已经没有任何业务逻辑，因此 SessionCalendarService 类不再需要进行单元测试。只要我们确定在 SessionCalendarService 调用的是  SessionCalendarUpdater 类中的 updateCalendar() 方法，在 SessionCalendarService 唯一可能出现的就是编译时错误。我们完全不需要为此实现测试单元，因为这是编译器的工作，与我们无关。</p>
<p>由于我在前两篇博文中提到的相关原因，将我们的 Service 类拆分成这样会使对业务逻辑进行单元测试变得非常简单，例如我们对 SessionCalendarUpdater 类进行单元测试的代码可以写成下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionCalendarUpdaterTests</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldClearAllSessions</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException, OperationApplicationException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        SessionCalendarDatabase sessionCalendarDatabase = mock(SessionCalendarDatabase.class);</span><br><span class="line"> </span><br><span class="line">        SessionCalendarUserPreferences sessionCalendarUserPreferences = mock(SessionCalendarUserPreferences.class);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        SessionCalendarUpdater sessionCalendarUpdater = <span class="keyword">new</span> SessionCalendarUpdater(sessionCalendarDatabase,</span><br><span class="line">                                                                                   sessionCalendarUserPreferences);</span><br><span class="line"> </span><br><span class="line">        CalendarUpdateRequest calendarUpdateRequest = <span class="keyword">new</span> CalendarUpdateRequest(SessionCalendarUpdater.ACTION_CLEAR_ALL_SESSIONS_CALENDAR,</span><br><span class="line">                                                                                <span class="number">0</span>,</span><br><span class="line">                                                                                <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        sessionCalendarUpdater.updateCalendar(calendarUpdateRequest);</span><br><span class="line"> </span><br><span class="line">        verify(sessionCalendarDatabase).clearAllSessions(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结论">结论</h2><p>为了能够进行单元测试，我认为修改后的代码变得更易读和更易维护了。可以肯定的是，我们还有许多办法能让代码变得更好，但在让代码能够进行单元测试的过程中，我想让修改后的代码尽可能与修改前风格相似，所以我没有进行其他修改。在下一篇博文中，我将会教大家如何使用 Square 大法重构应用的 UI 组件（例如：Fragment 和 Activity）。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://philosophicalhacker.com/2015/05/01/how-to-make-our-android-apps-unit-testable-pt-1/" target="_blank" rel="external">HOW TO MAKE OUR ANDROID APPS UNIT TESTABLE (PT. 1)</a></li>
<li>原文作者 : <a href="http://philosophicalhacker.com/" target="_blank" rel="external">Matthew Dupree</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a> </li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在 Android 应用中进行单元测试很困难，有时候甚至是不可能的。在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-9/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part1.md">之前的两篇博文</a>中，我已经向大家解释了在 Android 中进行单元测试如此困难的原因。而<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-10/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part2.md">上一篇博文</a>我们通过分析得到的结论是：正是 Google 官方所提倡的应用架构方式使得在 Android 中进行单元测试变成一场灾难。因为在官方提倡的架构方式中，Google 似乎希望我们将业务逻辑都放在应用的组件类中（例如：Activity，Fragment，Service，等等……）。而这种开发方式也是我们一直以来使用的开发模板。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="单元测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Code Review最佳实践]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/code-review-best-practices/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/code-review-best-practices/</id>
    <published>2015-05-23T16:00:00.000Z</published>
    <updated>2015-07-11T08:58:41.000Z</updated>
    <content type="html"><![CDATA[<p>在Wiredrive上，我们做了很多的Code Review。在此之前我从来没有做过，这对于我来说是一个全新的体验，下面来总结一下在Code Review中做的事情以及说说谈论Code Review的最好方式。<br><a id="more"></a><br>简单的说，Code Review是开发者之间讨论修改代码来解决问题的过程。很多文章谈论了Code Review的诸多好处，包括知识共享，代码的质量，开发者的成长，却很少讨论审查什么、如何审查。</p>
<h3 id="审查的内容">审查的内容</h3><h4 id="体系结构和代码设计">体系结构和代码设计</h4><ul>
<li><p><a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external">单一职责原则：</a>一个类有且只能一个职责。我通常使用这个原则去衡量，如果我们必须使用“和”来描述一个方法做的事情，这可能在抽象层上出了问题。</p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="external">开闭原则</a>如果是面向对象的语言，对象对可扩展开放、对修改关闭。如果我们需要添加另外的内容会怎样？</p>
</li>
<li><p>代码复用：根据<a href="http://c2.com/cgi/wiki?ThreeStrikesAndYouRefactor" target="_blank" rel="external">“三振法”</a>,如果代码被复制一次，虽然如喜欢这种方式，但通常没什么问题。但如果再一次被复制，就应该通过提取公共的部分来重构它。</p>
</li>
<li><p><a href="http://robertheaton.com/2014/06/20/code-review-without-your-eyes/" target="_blank" rel="external">换位考虑</a>，如果换位考虑，这行代码是否有问题？用这种模式是否可以发现代码中的问题。</p>
</li>
<li><p>用更好的代码： 如果在一块混乱的代码做修改，添加几行代码也许更容易，但我建议更进一步，用比原来更好的代码。</p>
</li>
<li><p>潜在的bugs：是否会引起的其他错误？循环是否以我们期望的方式终止？</p>
</li>
<li><p>错误处理：错误确定被优雅的修改？会导致其他错误？如果这样，修改是否有用？</p>
</li>
<li><p>效率： 如果代码中包含算法，这种算法是否是高效？ 例如，在字典中使用迭代，遍历一个期望的值，这是一种低效的方式。</p>
</li>
</ul>
<h4 id="代码风格">代码风格</h4><ul>
<li><p>方法名： 在计算机科学中，命名是一个难题。一个函数被命名为==get_message_queue_name==，但做的却是完全不同的事情，比如从输入内容中清除html，那么这是一个不准确的命名，并且可能会误导。</p>
</li>
<li><p>值名：对于数据结构，==foo== or ==bar== 可能是无用的名字。相比==exception==， ==e==同样是无用的。如果需要(根据语言)尽可能详细，在重新查看代码时，那些见名知意的命名是更容易理解的。</p>
</li>
<li><p>函数长度： 对于一个函数的长度，我的经验值是小于20行，如果一个函数在50行以上，最好把它分成更小的函数块。</p>
</li>
</ul>
<ul>
<li><p>类的长度：我认为类的长度应该小于300行，最好在100内。把较长的类分离成独立的类，这样更容易理解类的功能。</p>
</li>
<li><p>文件的长度： 对于Python，一个文件最多1000行代码。任何高于此的文件应该把它分离成更小更内聚,看一下是否违背的“单一职责” 原则。</p>
</li>
<li><p>文档：对于复杂的函数来说，参数个数可能较多，在文档中需要指出每个参数的用处，除了那些显而易见的。</p>
</li>
<li><p>注释代码： 移除任何注释代码行。</p>
</li>
<li>函数参数个数：不要太多， 一般不要超过3个。。</li>
<li>可读性： 代码是否容易理解？在查看代码时要不断的停下来分析它？</li>
</ul>
<h4 id="测试">测试</h4><ul>
<li>测试的范围：我喜欢测试新功能。测试是否全面？是否涵盖了故障的情况【比如：网络，信号等，译者注】？是否容易使用？是否稳定？大多的测试？性能的快慢？</li>
<li>合乎规范的测试：当复查测试时，确保我们用适当的方式。换句话说，当我们在一个较低水平测试却要求期望的功能？Gary Bernhardt建议95％的单元测试，5％的集成测试。特别是在Django项目中，在较高的测试水平上，很容易发现意外bug，创建一个详细的测试用例，认真仔细也是很重要的。</li>
</ul>
<h4 id="审查代码">审查代码</h4><p>在提交代码之前，我经常用git添加改变的文件/文件夹,然后通过git diff 来查看做了哪些修改。通常，我会关注如下几点：</p>
<ul>
<li>是否有注释？</li>
<li>变量名是否见名知意？</li>
<li>…等上面提到的</li>
</ul>
<p>和著名的橡皮鸭调试法（Rubber Duck Debugging）一样，每次提交前整体把自己的代码过一遍非常有帮助，尤其是看看有没有犯低级错误。</p>
<h4 id="如何进行Code_Review">如何进行Code Review</h4><p>当Code Review时，会遇到不少问题，我也学会了如何处理，下面是一些方法：</p>
<ul>
<li>提问： 这个函数是如何生效的？如果需求变更，应该做什么改变？怎么更容易维护？</li>
<li>表扬/奖励良好的做法：Code Review重要的一点是奖励开发者的成长和努力。得到别人的肯定是一件很不错的事情，我尽可能多的给人积极的评论。</li>
<li>当面讨论代替评论。 大部分情况下小组内的同事是坐在一起的，当面的 code review是非常有效的。</li>
<li>说明理由 ：是否还有跟好的方式，证明为什么这样做是好的。</li>
</ul>
<h4 id="心态上">心态上</h4><ul>
<li>作为一个Developer , 不仅要Deliver working code, 还要Deliver maintable code.</li>
<li>必要时进行重构，随着项目的迭代，在计划新增功能的同时，开发要主动计划重构的工作项。</li>
<li>开放的心态，虚心接受大家的Review Comments。</li>
</ul>
<h4 id="参考">参考</h4><p>一些关于clean code的书籍，如下：</p>
<ul>
<li><a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882" target="_blank" rel="external">Clean Code</a></li>
<li><a href="http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672" target="_blank" rel="external">Refactoring</a></li>
<li><a href="https://www.youtube.com/watch?v=8bZh5LMaSmE&amp;index=1&amp;list=LLlt4ZSW8NUcXLWiB3NMnK_w" target="_blank" rel="external">All the Small Things by Sandi Metz</a></li>
<li><a href="https://www.youtube.com/watch?v=aAb7hSCtvGw&amp;list=LLlt4ZSW8NUcXLWiB3NMnK_w&amp;index=48" target="_blank" rel="external">How to Design a Good API and Why it Matters</a></li>
<li><a href="https://news.ycombinator.com/item?id=9517892" target="_blank" rel="external">Discussion on Hacker News</a></li>
</ul>
<h2 id="译者注">译者注</h2><h5 id="一-_参考了_http://jimhuang-cn/?p=59">一. 参考了 <a href="http://jimhuang.cn/?p=59" target="_blank" rel="external">http://jimhuang.cn/?p=59</a></h5><h5 id="二-_国内阿里的陈皓写的关于codereview的文章，也很有见底，推荐大家看看">二. 国内阿里的<a href="http://coolshell.cn/articles/author/haoel" target="_blank" rel="external">陈皓</a>写的关于codereview的文章，也很有见底，推荐大家看看</h5><h6 id="1-Code_Review中的几个提示">1.<a href="http://coolshell.cn/articles/1302.html" target="_blank" rel="external">Code Review中的几个提示</a></h6><ul>
<li>先Review设计实现思路，然后Review设计模式，接着Review成形的骨干代码，最后Review完成的代码，如果程序复杂的话，需要拆成几个单元或模块分别Review</li>
<li>Code Review不要太正式，而且要短</li>
<li>学会享受Code Reivew</li>
</ul>
<h6 id="2-从Code_Review_谈如何做技术">2.<a href="http://coolshell.cn/articles/11432.html/comment-page-1#comments" target="_blank" rel="external">从Code Review 谈如何做技术</a></h6><h5 id="三-_Code_Review_工具">三. Code Review 工具</h5><p><a href="https://github.com/reviewboard/reviewboard" target="_blank" rel="external">Review Board</a></p>
<h5 id="四-">四.</h5><p>在Code Review时，要在 <strong>意识</strong> <strong>方法</strong> <strong>心态</strong> <strong>习惯</strong> 这几个方面上下功夫，坚持code review，相信我们会在各方面有很大的提升。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://kevinlondon.com/2015/05/05/code-review-best-practices.html" target="_blank" rel="external">Code Review Best Practices</a></li>
<li>原文作者 : <a href="http://kevinlondon.com/about/" target="_blank" rel="external">Kevin London</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/ayyb1988" target="_blank" rel="external">ayyb1988</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Wiredrive上，我们做了很多的Code Review。在此之前我从来没有做过，这对于我来说是一个全新的体验，下面来总结一下在Code Review中做的事情以及说说谈论Code Review的最好方式。<br>]]>
    
    </summary>
    
      <category term="CodeReview" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/CodeReview/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[听FackBook工程师讲*Custom ViewGroups*]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/custom-viewgroups/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/custom-viewgroups/</id>
    <published>2015-05-23T16:00:00.000Z</published>
    <updated>2015-07-11T08:58:05.000Z</updated>
    <content type="html"><![CDATA[<p>Android提供了几个ViewGroups如LinearLayout, RelativeLayout, FrameLayout来固定child Views的位置。在这些普通的ViewGroups中有多种使用选择。<br>例如：LinearLayout几乎支持HTML Flexbox的所有特性(除了包装)。在view之间你可以选择是否显示分割线(dividers),并且基于最大的child测量所有的children。RelativeLayout是一种限制性的解决方案。这些layouts都已经足够好了，但是当你的UI非常复杂的时候它们还能很好的解决么？<br><a id="more"></a><br><img src="https://camo.githubusercontent.com/a6a9af42f7ea610c28e42e954eb20ab3a2129b7c/68747470733a2f2f73726972616d72616d616e692e66696c65732e776f726470726573732e636f6d2f323031352f30352f637573746f6d2d766965772d67726f75702e706e673f773d3135393426683d323034" alt=""></p>
<blockquote>
<p>ViewGroup with a ProfilePhoto, Title, Subtitle and Menu button.</p>
</blockquote>
<p>上面的这种布局在Facebook app中是非常常见的。有头像、其它的view垂直摆在它的右侧、还有一个可选操作的view在最右边。这个布局可以通过使用LinearLayout嵌套或者一个RelativeLayout这样的普通ViewGroup实现。我们看一下当分别使用这两种布局的情况下在measure时会发生什么。</p>
<p>使用LinearLayout完成布局的示例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="wrap_content"&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;ProfilePhoto</span><br><span class="line">        android:layout_width="40dp"</span><br><span class="line">        android:layout_height="40dp"/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width="0dp"</span><br><span class="line">        android:layout_height="wrap_content"</span><br><span class="line">        android:layout_weight="1"</span><br><span class="line">        android:orientation="vertical"&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;Title</span><br><span class="line">            android:layout_width="match_parent"</span><br><span class="line">            android:layout_height="wrap_content"/&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;Subtitle</span><br><span class="line">            android:layout_width="match_parent"</span><br><span class="line">            android:layout_height="wrap_content"/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;Menu</span><br><span class="line">        android:layout_width="20dp"</span><br><span class="line">        android:layout_height="20dp"/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在Nexus 5设备上measure发生时的情况如下</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; LinearLayout [horizontal]       [<span class="string">w:</span> <span class="number">1080</span>  exactly,       <span class="string">h:</span> <span class="number">1557</span>  exactly    ]</span><br><span class="line">    &gt; ProfilePhoto                [<span class="string">w:</span> <span class="number">120</span>   exactly,       <span class="string">h:</span> <span class="number">120</span>   exactly    ]</span><br><span class="line">    &gt; LinearLayout [vertical]     [<span class="string">w:</span> <span class="number">0</span>     unspecified,   <span class="string">h:</span> <span class="number">0</span>     unspecified]</span><br><span class="line">        &gt; Title                   [<span class="string">w:</span> <span class="number">0</span>     unspecified,   <span class="string">h:</span> <span class="number">0</span>     unspecified]</span><br><span class="line">        &gt; Subtitle                [<span class="string">w:</span> <span class="number">0</span>     unspecified,   <span class="string">h:</span> <span class="number">0</span>     unspecified]</span><br><span class="line">        &gt; Title                   [<span class="string">w:</span> <span class="number">222</span>   exactly,       <span class="string">h:</span> <span class="number">57</span>    exactly    ]</span><br><span class="line">        &gt; Subtitle                [<span class="string">w:</span> <span class="number">222</span>   exactly,       <span class="string">h:</span> <span class="number">57</span>    exactly    ]</span><br><span class="line">    &gt; Menu                        [<span class="string">w:</span> <span class="number">60</span>    exactly,       <span class="string">h:</span> <span class="number">60</span>    exactly    ]</span><br><span class="line">    &gt; LinearLayout [vertical]     [<span class="string">w:</span> <span class="number">900</span>   exactly,       <span class="string">h:</span> <span class="number">1557</span>  at_most    ]</span><br><span class="line">        &gt; Title                   [<span class="string">w:</span> <span class="number">900</span>   exactly,       <span class="string">h:</span> <span class="number">1557</span>  at_most    ]</span><br><span class="line">        &gt; Subtitle                [<span class="string">w:</span> <span class="number">900</span>   exactly,       <span class="string">h:</span> <span class="number">1500</span>  at_most    ]</span><br></pre></td></tr></table></figure>
<p>ProfilePhoto和Menu只被测量了一次，因为它们有明确的宽高值。垂直的LinearLayout被测量了两次。第一次的时候，父LinearLayout要求以UNSPECIFIED spec的方式来测量。导致了垂直的LinearLayout也以这种方式测量它的子view.此时它在它们返回值的基础上以EXACTLY spec的方式测量它的子view，但是它还没有结束。一旦在测量ProfilePhoto和Menu之后，父布局知道可用于垂直的LinearLayout的尺寸大小。以AT_MOST height对Title 和 Subtitle测量之后导致了第二次传值。显然，每一个TextView (Title and Subtitle)被测量3次。第二次传值创建或者废弃Layouts，这些操作是昂贵的。如果想ViewGroup发挥更好的性能，首要的工作就是免去对TextViews的测量传值工作。</p>
<p>使用RelativeLayout效果会不会好一些?</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout</span><br><span class="line">    android:layout_width="match_parent"</span><br><span class="line">    android:layout_height="wrap_content"&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;ProfilePhoto</span><br><span class="line">        android:layout_width="40dp"</span><br><span class="line">        android:layout_height="40dp"</span><br><span class="line">        android:layout_alignParentTop="true"</span><br><span class="line">        android:layout_alignParentLeft="true"/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;Menu</span><br><span class="line">        android:layout_width="20dp"</span><br><span class="line">        android:layout_height="20dp"</span><br><span class="line">        android:layout_alignParentTop="true"</span><br><span class="line">        android:layout_alignParentRight="true"/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;Title</span><br><span class="line">        android:layout_width="wrap_content"</span><br><span class="line">        android:layout_height="wrap_content"</span><br><span class="line">        android:layout_toRightOf="@id/profile_photo"</span><br><span class="line">        android:layout_toLeftOf="@id/menu"/&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;Subtitle</span><br><span class="line">        android:layout_width="wrap_content"</span><br><span class="line">        android:layout_height="wrap_content"</span><br><span class="line">        android:layout_below="@id/title"</span><br><span class="line">        android:layout_toRightOf="@id/profile_photo"</span><br><span class="line">        android:layout_toLeftOf="@id/menu"/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>测量情况如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; RelativeLayout                  [<span class="string">w:</span> <span class="number">1080</span>  exactly,   <span class="string">h:</span> <span class="number">1557</span>  exactly]</span><br><span class="line">    &gt; Menu                        [<span class="string">w:</span> <span class="number">60</span>    exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; ProfilePhoto                [<span class="string">w:</span> <span class="number">120</span>   exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; Title                       [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; Subtitle                    [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; Title                       [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; Subtitle                    [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1500</span>  at_most]</span><br><span class="line">    &gt; Menu                        [<span class="string">w:</span> <span class="number">60</span>    exactly,   <span class="string">h:</span> <span class="number">60</span>    exactly]</span><br><span class="line">    &gt; ProfilePhoto                [<span class="string">w:</span> <span class="number">120</span>   exactly,   <span class="string">h:</span> <span class="number">120</span>   exactly]</span><br></pre></td></tr></table></figure>
<p>正如先前提到的，RelativeLayout是通过solving constraints(分解约束。译者认为就是一层一层的测量)进行测量，上面的布局中ProfilePhoto和Menu没有依赖其它的参照物(siblings)，因此它们先被测量(with an AT_MOST height).这时Title(2个约束)和Subtitle(3个约束)才会被测量。此时所有view明确了自己想要的尺寸大小。RelativeLayout使用这些信息第二次传值给Title, Subtitle, Menu和ProfilePhoto。再重复一遍，每个view被测量了两次，因此这种方案稍佳。如果你和上面的LinearLayout例子相比较一下，最后用于测量所有leaf Views所使用的MeasureSpec是相同的-因此最后的输出结果是一样的。</p>
<p>怎么样才能免去对子view的测量传值呢？自定义一个ViewGroup是不是会有帮助？让我们分析一下这个布局。Title 和 Subtitle 总是在ProfilePhoto的左侧在Menu按钮的右侧。如果我们手工解决这个问题，需要计算出ProfilePhoto和Menu按钮的尺寸，并且使用剩下的尺寸再来计算Title 和 Subtitle。这时对每个view只进行一次测量传值。我们叫这种布局为ProfilePhotoLayout。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfilePhotoLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ProfilePhoto mProfilePhoto;</span><br><span class="line">    <span class="keyword">private</span> Menu mMenu;</span><br><span class="line">    <span class="keyword">private</span> Title mTitle;</span><br><span class="line">    <span class="keyword">private</span> Subtitle mSubtitle;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. Setup initial constraints.</span></span><br><span class="line">        <span class="keyword">int</span> widthConstraints = getPaddingLeft() + getPaddingRight();</span><br><span class="line">        <span class="keyword">int</span> heightContraints = getPaddingTop() + getPaddingBottom();</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. Measure the ProfilePhoto</span></span><br><span class="line">        measureChildWithMargins(</span><br><span class="line">            mProfilePhoto,</span><br><span class="line">            widthMeasureSpec,</span><br><span class="line">            widthConstraints,</span><br><span class="line">            heightMeasureSpec,</span><br><span class="line">            heightConstraints);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3. Update the contraints.</span></span><br><span class="line">        widthConstraints += mProfilePhoto.getMeasuredWidth();</span><br><span class="line">        width += mProfilePhoto.getMeasuredWidth();</span><br><span class="line">        height = Math.max(mProfilePhoto.getMeasuredHeight(), height);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. Measure the Menu.</span></span><br><span class="line">        measureChildWithMargins(</span><br><span class="line">            mMenu,</span><br><span class="line">            widthMeasureSpec,</span><br><span class="line">            widthConstraints,</span><br><span class="line">            heightMeasureSpec,</span><br><span class="line">            heightConstraints);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 5. Update the constraints.</span></span><br><span class="line">        widthConstraints += mMenu.getMeasuredWidth();</span><br><span class="line">        width += mMenu.getMeasuredWidth();</span><br><span class="line">        height = Math.max(mMenu.getMeasuredHeight(), height);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 6. Prepare the vertical MeasureSpec.</span></span><br><span class="line">        <span class="keyword">int</span> verticalWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">            MeasureSpec.getSize(widthMeasureSpec) - widthConstraints,</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> verticalHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">            MeasureSpec.getSize(heightMeasureSpec) - heightConstraints,</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 7. Measure the Title.</span></span><br><span class="line">        measureChildWithMargins(</span><br><span class="line">            mTitle,</span><br><span class="line">            verticalWidthMeasureSpec,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            verticalHeightMeasureSpec,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 8. Measure the Subtitle.</span></span><br><span class="line">        measureChildWithMargins(</span><br><span class="line">            mSubtitle,</span><br><span class="line">            verticalWidthMeasureSpec,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            verticalHeightMeasureSpec,</span><br><span class="line">            mTitle.getMeasuredHeight());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 9. Update the sizes.</span></span><br><span class="line">        width += Math.max(mTitle.getMeasuredWidth(), mSubtitle.getMeasuredWidth());</span><br><span class="line">        height = Math.max(mTitle.getMeasuredHeight() + mSubtitle.getMeasuredHeight(), height);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 10. Set the dimension for this ViewGroup.</span></span><br><span class="line">        setMeasuredDimension(</span><br><span class="line">            resolveSize(width, widthMeasureSpec),</span><br><span class="line">            resolveSize(height, heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(</span><br><span class="line">        View child,</span><br><span class="line">        <span class="keyword">int</span> parentWidthMeasureSpec,</span><br><span class="line">        <span class="keyword">int</span> widthUsed,</span><br><span class="line">        <span class="keyword">int</span> parentHeightMeasureSpec,</span><br><span class="line">        <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">        MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(</span><br><span class="line">            parentWidthMeasureSpec,</span><br><span class="line">            widthUsed + lp.leftMargin + lp.rightMargin,</span><br><span class="line">            lp.width);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(</span><br><span class="line">            parentHeightMeasureSpec,</span><br><span class="line">            heightUsed + lp.topMargin + lp.bottomMargin,</span><br><span class="line">            lp.height);</span><br><span class="line"> </span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分析一下代码。我们从已知的约束条件开始 — 所有边的内边距，另外还需要考虑的约束是使用固定值的控件的高和宽。Android提供了一个帮助方法-measureChildWithMargins()用于测量ViewGroup内的子view.然而它总是添加padding作为约束条件的一部分。因此我们复写这个方法自己来管理这些约束条件。从测量ProfilePhoto开始，测量完成后更新一下constraints。对menu按钮的测量亦是如此。<br>现在还剩下Title和Subtitle的宽度没有测量。Android还提供了另外一个帮助方法-makeMeasureSpec()，用于构造MeasureSpec,传入相应的size和mode返回一个MeasureSpec。接下来我们传入Title 和 Subtitle可用的width 和 height及相应的MeasureSpecs来测量Title 和 Subtitle。最后更新一下ViewGroup的尺寸。在这一步可以明确每个view都只被测量一次。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; ProfilePhotoLayout              [<span class="string">w:</span> <span class="number">1080</span>  exactly,   <span class="string">h:</span> <span class="number">1557</span>  exactly]</span><br><span class="line">    &gt; ProfilePhoto                [<span class="string">w:</span> <span class="number">120</span>   exactly,   <span class="string">h:</span> <span class="number">120</span>   exactly]</span><br><span class="line">    &gt; Menu                        [<span class="string">w:</span> <span class="number">60</span>    exactly,   <span class="string">h:</span> <span class="number">60</span>    exactly]</span><br><span class="line">    &gt; Title                       [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1557</span>  at_most]</span><br><span class="line">    &gt; Subtitle                    [<span class="string">w:</span> <span class="number">900</span>   exactly,   <span class="string">h:</span> <span class="number">1500</span>  at_most]</span><br></pre></td></tr></table></figure>
<p>性能上是不是提升了？Facebook app中你看见的大多数布局都使用了这种布局，并且经证明确实提高了性能。我把没有提到的onLayout()方法留给读者作为练习。</p>
<p>你喜欢解决这种Android UI 工程问题么? Facebook在这方面缺少专业的人才。</p>
<p><a href="https://www.facebook.com/careers/department?req=a0I1200000G49VNEAZ&amp;dept=engineering&amp;q=UI%20Engineer" target="_blank" rel="external">点击申请</a></p>
<blockquote>
<ul>
<li>原文链接 : <a href="https://sriramramani.wordpress.com/2015/05/06/custom-viewgroups/" target="_blank" rel="external">Custom ViewGroups</a></li>
<li>原文作者 : <a href="https://sriramramani.wordpress.com/" target="_blank" rel="external">Sriram Ramani</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/objectlife" target="_blank" rel="external">objectlife</a> </li>
<li>校对者: <a href="https://github.com/xianjiajun" target="_blank" rel="external">xianjiajun</a>  </li>
<li>状态 : 完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android提供了几个ViewGroups如LinearLayout, RelativeLayout, FrameLayout来固定child Views的位置。在这些普通的ViewGroups中有多种使用选择。<br>例如：LinearLayout几乎支持HTML Flexbox的所有特性(除了包装)。在view之间你可以选择是否显示分割线(dividers),并且基于最大的child测量所有的children。RelativeLayout是一种限制性的解决方案。这些layouts都已经足够好了，但是当你的UI非常复杂的时候它们还能很好的解决么？<br>]]>
    
    </summary>
    
      <category term="基础" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解Dagger2]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/tasting-dagger-2-on-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/24/tasting-dagger-2-on-android/</id>
    <published>2015-05-23T16:00:00.000Z</published>
    <updated>2015-07-11T08:55:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么使用依赖注入">为什么使用依赖注入</h2><p>首先我们需要知道，人们在很长的一段时间里都是利用控制反转原则规定：应用程序的流程取决于在程序运行时对象图的建立。通过抽象定义的对象交互可以实现这样的动态流程。而使用依赖注入技术或者服务定位器便可以完成运行时绑定。<br><a id="more"></a><br>使用依赖注入可以带来以下好处：</p>
<ul>
<li>依赖的注入和配置独立于组件之外。</li>
<li>因为对象是在一个独立、不耦合的地方初始化，所以当注入抽象方法的时候，我们只需要修改对象的实现方法，而不用大改代码库。</li>
<li>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</li>
</ul>
<p>可以看到，能够管理创建实例的范围是一件非常棒的事情。按我的观点，你app中的所有对象或者协作者都不应该知道有关实例创建和生命周期的任何事情，这些都应该由我们的依赖注入框架管理的。</p>
<p><img src="http://fernandocejas.com/wp-content/uploads/2015/04/dependency_inversion1.png" alt="p1"></p>
<h1 id="什么是JSR-330？">什么是JSR-330？</h1><p>为了最大程度的提高代码的复用性、测试性和维护性，java的依赖注入为注入类中的使用定义了一整套注解（和接口）标准。Dagger1和Dagger2（还有Guice）都是基于这套标准，给程序带来了稳定性和标准的依赖注入方法。</p>
<h1 id="Dagger1">Dagger1</h1><p>这个版本不是这篇文章的重点，所以我只是简略地说一下。不管怎样，Dagger1还是做了很多的贡献，可以说是如今Android上最流行的依赖注入框架。它是由Square公司受到Guice启发创建的。</p>
<p>基本特点：</p>
<ul>
<li>多个注入点：依赖，通过injected</li>
<li>多种绑定方法：依赖，通过provided</li>
<li>多个modules：实现某种功能的绑定集合</li>
<li>多个对象图： 实现一个范围的modules集合</li>
</ul>
<p>Dagger1是在编译的时候实行绑定，不过也用到了反射机制。但这个反射不是用来实例化对象的，而是用于图的构成。Dagger会在运行的时候去检测是否一切都正常工作，所以使用的时候会付出一些代价：偶尔会无效和调试困难。</p>
<h1 id="Dagger2">Dagger2</h1><p>Dagger2是Dagger1的分支，由谷歌公司接手开发，目前的版本是2.0。Dagger2是受到<a href="https://github.com/google/auto" target="_blank" rel="external">AutoValue项目</a>的启发。<br>刚开始，Dagger2解决问题的基本思想是：利用生成和写的代码混合达到看似所有的产生和提供依赖的代码都是手写的样子。</p>
<p>如果我们将Dagger2和1比较，他们两个在很多方面都非常相似，但也有很重要的区别，如下：</p>
<ul>
<li>再也没有使用反射：图的验证、配置和预先设置都在编译的时候执行。</li>
<li>容易调试和可跟踪：完全具体地调用提供和创建的堆栈</li>
<li>更好的性能：谷歌声称他们提高了13%的处理性能</li>
<li>代码混淆：使用派遣方法，就如同自己写的代码一样</li>
</ul>
<p>当然所有这些很棒的特点都需要付出一个代价，那就是缺乏灵活性，例如：Dagger2没用反射所以没有动态机制。</p>
<h1 id="深入研究">深入研究</h1><p>想要了解Dagger2，就必须要知道依赖注入的基础和这其中的每一个概念：</p>
<ul>
<li><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>
</li>
<li><p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>
</li>
<li><p>@Provide: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>
</li>
<li><p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>
</li>
<li><p>@Scope: Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。后面会演示一个例子，这是一个非常强大的特点，因为就如前面说的一样，没必要让每个对象都去了解如何管理他们的实例。在scope的例子中，我们用自定义的@PerActivity注解一个类，所以这个对象存活时间就和activity的一样。简单来说就是我们可以定义所有范围的粒度(@PerFragment, @PerUser, 等等)。</p>
</li>
<li><p>Qualifier: 当类的类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示。例如：在Android中，我们会需要不同类型的context，所以我们就可以定义qualifier注解“@ForApplication”和“@ForActivity”，这样当注入一个context的时候，我们就可以告诉Dagger我们想要哪种类型的context。</p>
</li>
</ul>
<h1 id="不废话上代码">不废话上代码</h1><p>前面已经讲了很多理论了，所以接下来让我们看看如何使用Dagger2。首先还是要在我们的build.gradle文件中如下配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.neenbedankt.android-apt'</span></span><br><span class="line"> </span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">  apt <span class="string">'com.google.dagger:dagger-compiler:2.0'</span></span><br><span class="line">  compile <span class="string">'com.google.dagger:dagger:2.0'</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，我们添加了编译和运行库，还有必不可少的apt插件，没有这插件，dagger可能不会正常工作，特别是在Android studio中。</p>
<h1 id="例子">例子</h1><p>几个月前，我写了一篇关于如何在Android上实现bob叔叔的清晰架构的文章，强烈建议大家去看一下，看完之后，你将会对我们现在做的事情有更好的理解。言归正传，在我以前的方案中，构造和提供大多数对象的依赖的时候，会遇到问题，具体如下（见评注）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">initializePresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All this dependency initialization could have been avoided by using a</span></span><br><span class="line">  <span class="comment">// dependency injection framework. But in this case this is used this way for</span></span><br><span class="line">  <span class="comment">// LEARNING EXAMPLE PURPOSE.</span></span><br><span class="line">  ThreadExecutor threadExecutor = JobExecutor.getInstance();</span><br><span class="line">  PostExecutionThread postExecutionThread = UIThread.getInstance();</span><br><span class="line"></span><br><span class="line">  JsonSerializer userCacheSerializer = <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">  UserCache userCache = UserCacheImpl.getInstance(getActivity(), userCacheSerializer,</span><br><span class="line">      FileManager.getInstance(), threadExecutor);</span><br><span class="line">  UserDataStoreFactory userDataStoreFactory =</span><br><span class="line">      <span class="keyword">new</span> UserDataStoreFactory(<span class="keyword">this</span>.getContext(), userCache);</span><br><span class="line">  UserEntityDataMapper userEntityDataMapper = <span class="keyword">new</span> UserEntityDataMapper();</span><br><span class="line">  UserRepository userRepository = UserDataRepository.getInstance(userDataStoreFactory,</span><br><span class="line">      userEntityDataMapper);</span><br><span class="line"></span><br><span class="line">  GetUserDetailsUseCase getUserDetailsUseCase = <span class="keyword">new</span> GetUserDetailsUseCaseImpl(userRepository,</span><br><span class="line">      threadExecutor, postExecutionThread);</span><br><span class="line">  UserModelDataMapper userModelDataMapper = <span class="keyword">new</span> UserModelDataMapper();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.userDetailsPresenter =</span><br><span class="line">      <span class="keyword">new</span> UserDetailsPresenter(<span class="keyword">this</span>, getUserDetailsUseCase, userModelDataMapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，解决这个问题的办法是使用依赖注入框架。我们要避免像上面这样引用代码：这个类不能涉及对象的创建和依赖的提供。<br>那我们该怎么做呢，当然是使用Dagger2，我们先看看结构图：<br><img src="http://fernandocejas.com/wp-content/uploads/2015/04/composed_dagger_graph1.png" alt="pic2"></p>
<p>接下来我们会分解这张图，并解释各个部分还有代码。</p>
<p>Application Component: 生命周期跟Application一样的组件。可注入到AndroidApplication和BaseActivity中类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Singleton</span> <span class="comment">// Constraints this component to one-per-application or unscoped bindings.</span></span><br><span class="line"><span class="annotation">@Component</span>(modules = ApplicationModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(BaseActivity baseActivity)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Exposed to sub-graphs.</span></span><br><span class="line">  <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ThreadExecutor <span class="title">threadExecutor</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">PostExecutionThread <span class="title">postExecutionThread</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">UserRepository <span class="title">userRepository</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我为这个组件使用了@Singleton注解，使其保证唯一性。也许你会问为什么我要将context和其他成员暴露出去。这正是Dagger中components工作的重要性质：如果你不想把modules的类型暴露出来，那么你就只能显示地使用它们。在这个例子中，我把这些元素暴露给子图，如果你把他们删掉，编译的时候就会报错。</p>
<p>Application Module: module的作用是提供在应用的生命周期中存活的对象。这也是为什么@Provide注解的方法要用@Singleton限定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AndroidApplication application;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ApplicationModule</span><span class="params">(AndroidApplication application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.application = application;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">Context <span class="title">provideApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.application;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">Navigator <span class="title">provideNavigator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Navigator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">ThreadExecutor <span class="title">provideThreadExecutor</span><span class="params">(JobExecutor jobExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">PostExecutionThread <span class="title">providePostExecutionThread</span><span class="params">(UIThread uiThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uiThread;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">UserCache <span class="title">provideUserCache</span><span class="params">(UserCacheImpl userCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@Singleton</span> <span class="function">UserRepository <span class="title">provideUserRepository</span><span class="params">(UserDataRepository userDataRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDataRepository;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity Component: 生命周期跟Activity一样的组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@PerActivity</span></span><br><span class="line"><span class="annotation">@Component</span>(dependencies = ApplicationComponent.class, modules = ActivityModule.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Exposed to sub-graphs.</span></span><br><span class="line">  <span class="function">Activity <span class="title">activity</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@PerActivity是一个自定义的范围注解，作用是允许对象被记录在正确的组件中，当然这些对象的生命周期应该遵循activity的生命周期。这是一个很好的练习，我建议你们都做一下，有以下好处：</p>
<ul>
<li>注入对象到构造方法需要的activity。</li>
<li>在一个per-activity基础上的单例使用。</li>
<li>只能在activity中使用使得全局的对象图保持清晰。</li>
</ul>
<p>看下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Scope</span></span><br><span class="line"><span class="annotation">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> PerActivity &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Activity Module: 在对象图中，这个module把activity暴露给相关联的类。比如在fragment中使用activity的context。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityModule</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Activity activity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ActivityModule</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.activity = activity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@PerActivity</span> <span class="function">Activity <span class="title">activity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.activity;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>User Component: 继承于ActivityComponent的组件，并用@PerActivity注解。我通常会在注入用户相关的fragment中使用。因为ActivityModule把activity暴露给图了，所以在任何需要一个activity的context的时候，Dagger都可以提供注入，没必要再在子modules中定义了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@PerActivity</span></span><br><span class="line"><span class="annotation">@Component</span>(dependencies = ApplicationComponent.class, modules = &#123;ActivityModule.class, UserModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserComponent</span> <span class="keyword">extends</span> <span class="title">ActivityComponent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(UserListFragment userListFragment)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(UserDetailsFragment userDetailsFragment)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>User Module: 提供跟用户相关的实例。基于我们的例子，它可以提供用户用例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModule</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@PerActivity</span> <span class="function">GetUserListUseCase <span class="title">provideGetUserListUseCase</span><span class="params">(GetUserListUseCaseImpl getUserListUseCase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserListUseCase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Provides</span> <span class="annotation">@PerActivity</span> <span class="function">GetUserDetailsUseCase <span class="title">provideGetUserDetailsUseCase</span><span class="params">(GetUserDetailsUseCaseImpl getUserDetailsUseCase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserDetailsUseCase;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="整合到一起">整合到一起</h1><p>现在我们已经实现了依赖注入图，但是我该如何注入？我们需要知道，Dagger给了我们一堆选择用来注入依赖：</p>
<ol>
<li>构造方法注入：在类的构造方法前面注释@Inject</li>
<li>成员变量注入：在类的成员变量（非私有）前面注释@Inject</li>
<li>函数方法注入：在函数前面注释@Inject</li>
</ol>
<p>这个顺序是Dagger建议使用的，因为在运行的过程中，总会有一些奇怪的问题甚至是空指针，这也意味着你的依赖在对象创建的时候可能还没有初始化完成。这在Android的activity或者fragment中使用成员变量注入会经常遇到，因为我们没有在它们的构造方法中使用。</p>
<p>回到我们的例子中，看一下我们是如何在BaseActivity中注入一个成员变量。在这个例子中，我们注入了一个叫Navigator的类，它是我们应用中负责管理导航的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Inject</span> Navigator navigator;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">this</span>.getApplicationComponent().inject(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ApplicationComponent <span class="title">getApplicationComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((AndroidApplication)getApplication()).getApplicationComponent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ActivityModule <span class="title">getActivityModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityModule(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Navigator类是成员变量注入的，由ApplicationModule里面@Provide注解显示提供的。最终我们初始化component然后调用inject()方法注入成员变量。我们通过在Activity的onCreate()方法中调用getApplicationComponent()，完成这些操作。getApplicationComponent()方法放在这儿是为了复用性，它的主要作用是为了获取实例化的ApplicationComponent对象。</p>
<p>在Fragment的presenter中我们也做了同样的事情，这儿的获取方法有一点不一样，因为问我们使用的是per-activity范围限定的component。所以我们注入到UserDetailsFragment中的UserComponent其实是驻留在UserDetailsActivity中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UserComponent userComponent;</span><br></pre></td></tr></table></figure>
<p>我们必须在activity的onCreate()方法中用下面的方式初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeInjector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.userComponent = DaggerUserComponent.builder()</span><br><span class="line">      .applicationComponent(getApplicationComponent())</span><br><span class="line">      .activityModule(getActivityModule())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dagger会处理我们的注解，为components生成实现并重命名加上“Dagger”前缀。因为这个是一个组合的component，所以在构建的时候，我们必须把所有的依赖的传进去（components和modules）。现在我们的component已经准备好了，接着为了可以满足fragment的依赖需求，我们写一个获取方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> UserComponent <span class="title">getComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> userComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在可以利用get方法获取创建的component，然后调用inject()方法将Fragment作为参数传进去，这样就完成了绑定UserDetailsFragment依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">  <span class="keyword">this</span>.getComponent.inject(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">想要查看完整的例子，可以去我的github</a>.这里面有一些地方重构了的，我可以告诉你一个重要的思想（来自官方的例子）是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HasComponent</span>&lt;<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">getComponent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，客户端（例如fragment）可以获取并且使用component（来自activity）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;C&gt; <span class="function">C <span class="title">getComponent</span><span class="params">(Class&lt;C&gt; componentType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> componentType.cast(((HasComponent&lt;C&gt;)getActivity()).getComponent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这儿使用了强制转换，不论这个客户端不能获取到能用的component，但是至少很快就会失败。如果你有任何想法能够更好地解决这个问题，请告诉我。</p>
<h1 id="Dagger2生成的代码">Dagger2生成的代码</h1><p>在了解Dagger的主要特征之后，我们再来看看内部构造。为了举例说明，我们还是用Navigator类，看看它是如何创建和注入的。首先我们看一下我们的DaggerApplicationComponent。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerApplicationComponent</span> <span class="keyword">implements</span> <span class="title">ApplicationComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Provider&lt;Navigator&gt; provideNavigatorProvider;</span><br><span class="line">  <span class="keyword">private</span> MembersInjector&lt;BaseActivity&gt; baseActivityMembersInjector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerApplicationComponent</span><span class="params">(Builder builder)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.provideNavigatorProvider = ScopedProvider.create(ApplicationModule_ProvideNavigatorFactory.create(builder.applicationModule));</span><br><span class="line">    <span class="keyword">this</span>.baseActivityMembersInjector = BaseActivity_MembersInjector.create((MembersInjector) MembersInjectors.noOp(), provideNavigatorProvider);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(BaseActivity baseActivity)</span> </span>&#123;  </span><br><span class="line">    baseActivityMembersInjector.injectMembers(baseActivity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationModule applicationModule;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationComponent <span class="title">build</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (applicationModule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"applicationModule must be set"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerApplicationComponent(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">applicationModule</span><span class="params">(ApplicationModule applicationModule)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (applicationModule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"applicationModule"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.applicationModule = applicationModule;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两个重点需要注意。第一个：由于我们要将依赖注入到activity中，所以会得到一个注入这个比成员的注入器（由Dagger生成的BaseActivity_MembersInjector）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">BaseActivity</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MembersInjector&lt;Activity&gt; supertypeInjector;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;Navigator&gt; navigatorProvider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseActivity_MembersInjector</span><span class="params">(MembersInjector&lt;Activity&gt; supertypeInjector, Provider&lt;Navigator&gt; navigatorProvider)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> supertypeInjector != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.supertypeInjector = supertypeInjector;</span><br><span class="line">    <span class="keyword">assert</span> navigatorProvider != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.navigatorProvider = navigatorProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(BaseActivity instance)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    supertypeInjector.injectMembers(instance);</span><br><span class="line">    instance.navigator = navigatorProvider.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;BaseActivity&gt; <span class="title">create</span><span class="params">(MembersInjector&lt;Activity&gt; supertypeInjector, Provider&lt;Navigator&gt; navigatorProvider)</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BaseActivity_MembersInjector(supertypeInjector, navigatorProvider);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个注入器一般都会为所有activity的注入成员提供依赖，只要我们一调用inject()方法，就可以获取需要的字段和依赖。</p>
<p>第二个重点：关于我们的DaggerApplicationComponent类，我们有一个Provider，它不仅仅是一个提供实例的接口，它还是被ScopedProvider构造出来的，可以记录创建实例的范围。</p>
<p>Dagger还会为我们的Navigator类生成一个名叫ApplicationModule_ProvideNavigatorFactory的工厂，这个工厂可以传递上面提到的范围参数然后得到这个范围内的类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Generated</span>(<span class="string">"dagger.internal.codegen.ComponentProcessor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationModule_ProvideNavigatorFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Navigator</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationModule module;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ApplicationModule_ProvideNavigatorFactory</span><span class="params">(ApplicationModule module)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">assert</span> module != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.module = module;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Navigator <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Navigator provided = module.provideNavigator();</span><br><span class="line">    <span class="keyword">if</span> (provided == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> provided;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Navigator&gt; <span class="title">create</span><span class="params">(ApplicationModule module)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApplicationModule_ProvideNavigatorFactory(module);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类非常简单，它代表我们的ApplicationModule（包含@Provide方法）创建了Navigator类。</p>
<p>总之，上面的代码看起来就像是手敲出来的，而且非常好理解，便于调试。其余还有很多可以去探索，你们可以通过调试去看看Dagger如何完成依赖绑定的。<br><img src="http://fernandocejas.com/wp-content/uploads/2015/04/debugging_dagger.png" alt="pic3"></p>
<h1 id="源码:">源码:</h1><p>例子: <a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="external">https://github.com/android10/Android-CleanArchitecture</a></p>
<h1 id="相关文章:">相关文章:</h1><p><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">Architecting Android…The clean way?</a><br><a href="https://www.youtube.com/watch?v=oK_XtfXPkqw" target="_blank" rel="external">Dagger 2, A New Type of Dependency Injection.</a><br><a href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014" target="_blank" rel="external">Dependency Injection with Dagger 2.</a><br><a href="https://publicobject.com/2014/11/15/dagger-2-has-components/" target="_blank" rel="external">Dagger 2 has Components.</a><br><a href="http://google.github.io/dagger/" target="_blank" rel="external">Dagger 2 Official Documentation.</a></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="external">Tasting Dagger 2 on Android</a></li>
<li>原文作者 : <a href="http://fernandocejas.com/" target="_blank" rel="external">Fernando Cejas</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/xianjiajun" target="_blank" rel="external">xianjiajun</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="为什么使用依赖注入">为什么使用依赖注入</h2><p>首先我们需要知道，人们在很长的一段时间里都是利用控制反转原则规定：应用程序的流程取决于在程序运行时对象图的建立。通过抽象定义的对象交互可以实现这样的动态流程。而使用依赖注入技术或者服务定位器便可以完成运行时绑定。<br>]]>
    
    </summary>
    
      <category term="依赖注入" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解RxJava(2)-操作符]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-2/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:45:11.000Z</updated>
    <content type="html"><![CDATA[<p>在第一篇blog中，我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定义的操作符。<br><a id="more"></a><br>首先先看一个例子：</p>
<h2 id="准备工作">准备工作</h2><p>假设我有这样一个方法：<br> 这个方法根据输入的字符串返回一个网站的url列表（啊哈，搜索引擎）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Observable&lt;List&gt; <span class="title">query</span><span class="params">(String text)</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在我希望构建一个健壮系统，它可以查询字符串并且显示结果。根据上一篇blog的内容，我们可能会写出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .subscribe(urls -&gt; &#123;  </span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;  </span><br><span class="line">            System.out.println(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这种代码当然是不能容忍的，因为上面的代码使我们丧失了变化数据流的能力。一旦我们想要更改每一个URL，只能在Subscriber中来做。我们竟然没有使用如此酷的map()操作符！！！</p>
<p>当然，我可以使用map操作符，map的输入是urls列表，处理的时候还是要for each遍历，一样很蛋疼。</p>
<p>万幸，还有Observable.from()方法，它接收一个集合作为输入，然后每次输出一个元素给subscriber：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(<span class="string">"url1"</span>, <span class="string">"url2"</span>, <span class="string">"url3"</span>)  </span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>我们来把这个方法使用到刚才的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .subscribe(urls -&gt; &#123;  </span><br><span class="line">        Observable.from(urls)  </span><br><span class="line">            .subscribe(url -&gt; System.out.println(url));  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>虽然去掉了for each循环，但是代码依然看起来很乱。多个嵌套的subscription不仅看起来很丑，难以修改，更严重的是它会破坏某些我们现在还没有讲到的RxJava的特性。</p>
<h2 id="改进">改进</h2><p>救星来了,他就是flatMap()。<br> Observable.flatMap()接收一个Observable的输出作为输入，同时输出另外一个Observable。直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;List, Observable&gt;() &#123;  </span><br><span class="line">        <span class="annotation">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable <span class="title">call</span><span class="params">(List urls)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> Observable.from(urls);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>这里我贴出了整个的函数代码，以方便你了解发生了什么，使用lambda可以大大简化代码长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>flatMap()是不是看起来很奇怪？为什么它要返回另外一个Observable呢？理解flatMap的关键点在于，flatMap输出的新的Observable正是我们在Subscriber想要接收的。现在Subscriber不再收到List，而是收到一些列单个的字符串，就像Observable.from()的输出一样。</p>
<p>这部分也是我当初学RxJava的时候最难理解的部分，一旦我突然领悟了，RxJava的很多疑问也就一并解决了。</p>
<h2 id="还可以更好">还可以更好</h2><p>flatMap()实在不能更赞了，它可以返回任何它想返回的Observable对象。<br> 比如下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网站的标题，如果404了就返回null  </span></span><br><span class="line"><span class="function">Observable <span class="title">getTitle</span><span class="params">(String URL)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接着前面的例子，现在我不想打印URL了，而是要打印收到的每个网站的标题。问题来了，我的方法每次只能传入一个URL，并且返回值不是一个String，而是一个输出String的Observabl对象。使用flatMap()可以简单的解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&gt;() &#123;  </span><br><span class="line">        <span class="annotation">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable <span class="title">call</span><span class="params">(String url)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> getTitle(url);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>使用lambda:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .flatMap(url -&gt; getTitle(url))  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>是不是感觉很不可思议？我竟然能将多个独立的返回Observable对象的方法组合在一起！帅呆了！<br> 不止这些，我还将两个API的调用组合到一个链式调用中了。我们可以将任意多个API调用链接起来。大家应该都应该知道同步所有的API调用，然后将所有API调用的回调结果组合成需要展示的数据是一件多么蛋疼的事情。这里我们成功的避免了callback hell（多层嵌套的回调，导致代码难以阅读维护）。现在所有的逻辑都包装成了这种简单的响应式调用。</p>
<h2 id="丰富的操作符">丰富的操作符</h2><p>目前为止，我们已经接触了两个操作符，RxJava中还有更多的操作符，那么我们如何使用其他的操作符来改进我们的代码呢？<br> getTitle()返回null如果url不存在。我们不想输出”null”，那么我们可以从返回的title列表中过滤掉null值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .flatMap(url -&gt; getTitle(url))  </span><br><span class="line">    .filter(title -&gt; title != <span class="keyword">null</span>)  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>filter()输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</p>
<p>如果我们只想要最多5个结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .flatMap(url -&gt; getTitle(url))  </span><br><span class="line">    .filter(title -&gt; title != <span class="keyword">null</span>)  </span><br><span class="line">    .take(<span class="number">5</span>)  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>take()输出最多指定数量的结果。</p>
<p>如果我们想在打印之前，把每个标题保存到磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)  </span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))  </span><br><span class="line">    .flatMap(url -&gt; getTitle(url))  </span><br><span class="line">    .filter(title -&gt; title != <span class="keyword">null</span>)  </span><br><span class="line">    .take(<span class="number">5</span>)  </span><br><span class="line">    .doOnNext(title -&gt; saveTitle(title))  </span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>doOnNext()允许我们在每次输出一个元素之前做一些额外的事情，比如这里的保存标题。</p>
<p>看到这里操作数据流是多么简单了么。你可以添加任意多的操作，并且不会搞乱你的代码。</p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。</p>
<p>你甚至可以编写自定义的操作符！这篇blog不打算将自定义操作符，如果你想的话，清自行Google吧。</p>
<h2 id="感觉如何？">感觉如何？</h2><p>好吧，你是一个怀疑主义者，并且还很难被说服，那为什么你要关心这些操作符呢？</p>
<p>因为操作符可以让你对数据流做任何操作。</p>
<p>将一系列的操作符链接起来就可以完成复杂的逻辑。代码被分解成一系列可以组合的片段。这就是响应式函数编程的魅力。用的越多，就会越多的改变你的编程思维。</p>
<p>另外，RxJava也使我们处理数据的方式变得更简单。在最后一个例子里，我们调用了两个API，对API返回的数据进行了处理，然后保存到磁盘。但是我们的Subscriber并不知道这些，它只是认为自己在接收一个Observable对象。良好的封装性也带来了编码的便利！</p>
<p>在第三部分中，我将介绍RxJava的另外一些很酷的特性，比如错误处理和并发，这些特性并不会直接用来处理数据。</p>
<p>原文链接:<a href="http://blog.danlew.net/2014/09/22/grokking-rxjava-part-2/" target="_blank" rel="external">深入理解RxJava-操作符</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在第一篇blog中，我介绍了RxJava的一些基础知识，同时也介绍了map()操作符。当然如果你并没有意愿去使用RxJava我一点都不诧异，毕竟才接触了这么点。看完这篇blog，我相信你肯定想立即在你的项目中使用RxJava了，这篇blog将介绍许多RxJava中的操作符，RxJava的强大性就来自于它所定义的操作符。<br>]]>
    
    </summary>
    
      <category term="RxJava/RxAndroid" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/"/>
    
      <category term="Reactive Extension(RX)" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Reactive-Extension-RX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 进行单元测试难在哪-part2]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/why-android-unit-testing-is-so-hard-pt-2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/why-android-unit-testing-is-so-hard-pt-2/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:48:36.000Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我用干货告诉大家：即使是 Google 大牛写出来的代码也无法进行测试。确切地说，我真正告诉大家的是：根本没办法在 SessionDetailActivity 的 onStop() 方法里进行单元测试，而且详细地解释了个中因果：由于无法改变预测试状态，我们无法在 onStop() 方法里完成断言；在 onStop() 方法中进行测试时，获得测试后状态也是无法完成的。在上篇博文的结尾处，我跟大家说：正是 Android SDK 的某些特性，以及 Google 官方推荐的代码模板使得单元测试处于如此尴尬的境地，而且我承诺会在这篇博文中详尽地解释各种因由，那现在就让我来兑现我的诺言吧。<br><a id="more"></a><br>在我开始论述之前，我再说一次：正是标准的 Android 应用架构使测试 Android 应用变得如此困难，这句话是本系列博文的核心论点。这篇博文的意义在于：我们尝试提出理由证明重构 Android 应用的必要性，使得这些 Android 应用不需要明确地依赖于 Android SDK，与此同时，我们也尝试着提出一种健壮的应用架构，以增强 Android 应用的测试性，你会在这篇博文里了解到相关的概述。因此，我接下来将尝试去证明这篇博文的核心论点。</p>
<p>众所周知，开发 Android 应用有一种标准的架构，在示例代码和开源代码里很常见到应用的业务逻辑被放在 Android 应用的组件类，Activity，Service，Fragment 里执行。而我接下来就要遵循这种架构进行开发。而这篇博文要论述的就是：如果我们遵循这种标准架构进行开发，极有可能写下无法测试的代码，我在上一篇博文里也论证了这样的问题并不是偶然，正是标准的 Android 应用架构让测试变得支离破碎，单元测试几乎不能进行。</p>
<h2 id="传统的_Android_应用架构让单元测试变得不可能">传统的 Android 应用架构让单元测试变得不可能</h2><p>为了开始论证为什么标准开发架构让应用组件变得无法测试，大家不妨和我一起简要地复习下上篇博文的一些结论。单元测试包含三个步骤：准备，测试，断言。为了完成准备步骤，需要改变测试代码的预测试状态，此外，为了完成单元测试的断言步骤，我们需要获得程序的测试后状态。</p>
<p>复习了这些知识点后，可以开始进入正题了哈。在某些情况下，依赖注入是实现能够改变预测试状态代码的唯一办法，而且这些代码的测试后状态也是可访问的。我写了一个与 Android 完全无关的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathNerd</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> mCalcCache;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> mCalculator;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MathNerd</span><span class="params">(CalculationCache calcCache, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        mCalcCache = calcCache;</span><br><span class="line">        mCalculator = calculator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIntenseCalculation</span><span class="params">(Calculation calculation, IntenseCalculationCompletedListener listener)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!mCalcCache.contains(calculation)) &#123;</span><br><span class="line">            </span><br><span class="line">            mCalculator.doIntenseCalculationInBackground(listener);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            Answer answer = mCalcCache.getAnswerFor(calculation);</span><br><span class="line">            listener.onCalculationCompleted(answer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，依赖注入确实是对 doIntenseCalculation() 进行单元测试的唯一办法，因为 doIntenseCalculation() 方法根本没有返回值。除此以外，MathNerd 类里也没有判断测试后状态有效性的属性。但通过依赖注入，我们可以通过 mCalcCache 获得单元测试中的测试后状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Arrange</span></span><br><span class="line">    CalculationCache calcCache = <span class="keyword">new</span> CalculationCache();</span><br><span class="line">    </span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    </span><br><span class="line">    MathNerd mathNerd = <span class="keyword">new</span> MathNerd(calcCache, calculator);</span><br><span class="line">    </span><br><span class="line">    Calculation calcualation = <span class="keyword">new</span> Calculation(<span class="string">"e^2000"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Act</span></span><br><span class="line">    mathNerd.doIntenseCalculationInBackground(calculation, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//some smelly Thread.sleep() code...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Assert</span></span><br><span class="line">    calcCache.contains(calculation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们这样做，很遗憾，恐怕是没办法为 MathNerd 类实现一个测试单元了。我们将会实现一个整合测试，用于检查 MathNerd 实际行为以及类是否根据 doIntenseCalculationInBackground() 方法处理后的值更新 CalcCache。</p>
<p>此外，依赖注入实际上也是验证测试单元测试后状态的唯一办法。我们通过注入验证方法在正确的位置被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCacheUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//Arrange</span></span><br><span class="line">    CalculationCache calcCache = mock(CalculationCache.class);</span><br><span class="line"> </span><br><span class="line">    when(calcCache.contains()).thenReturn(<span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">    Calculator calculator = mock(Calculator.class);</span><br><span class="line"> </span><br><span class="line">    MathNerd mathNerd = <span class="keyword">new</span> MathNerd(calcCache, calculator);</span><br><span class="line"> </span><br><span class="line">    Calculation calculation = <span class="keyword">new</span> Calculation(<span class="string">"e^2000"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Act</span></span><br><span class="line">    mathNerd.doIntenseCalculationInBackground(calculation, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Assert should use calculator to perform calcluation because cache was empty</span></span><br><span class="line">    verify(calculator).doIntenseCalculationInBackground(any());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Android 应用的相关类中进行单元测试涉及的许多测试实例都需要一个东西：依赖注入。但问题来了：核心 Android 类持有我们无法注入的依赖。例如我上次提到的通过 SessionDetailActivity 启动的 SessionCalendarService 就是一个很好的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    Log.d(TAG, <span class="string">"Received intent: "</span> + action);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = getContentResolver();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (ACTION_ADD_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">        isAddEvent = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_REMOVE_SESSION_CALENDAR.equals(action)) &#123;</span><br><span class="line">        isAddEvent = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_UPDATE_ALL_SESSIONS_CALENDAR.equals(action) &amp;&amp;</span><br><span class="line">            PrefUtils.shouldSyncCalendar(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getContentResolver().applyBatch(CalendarContract.AUTHORITY,</span><br><span class="line">                    processAllSessionsCalendar(resolver, getCalendarId(intent)));</span><br><span class="line">            sendBroadcast(<span class="keyword">new</span> Intent(</span><br><span class="line">                    SessionCalendarService.ACTION_UPDATE_ALL_SESSIONS_CALENDAR_COMPLETED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error adding all sessions to Google Calendar"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationApplicationException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error adding all sessions to Google Calendar"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_CLEAR_ALL_SESSIONS_CALENDAR.equals(action)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getContentResolver().applyBatch(CalendarContract.AUTHORITY,</span><br><span class="line">                    processClearAllSessions(resolver, getCalendarId(intent)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error clearing all sessions from Google Calendar"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OperationApplicationException e) &#123;</span><br><span class="line">            LOGE(TAG, <span class="string">"Error clearing all sessions from Google Calendar"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SessionCalendarService 的依赖是 ContentResolver，而且 ContentResolver 就是一个无法注入的依赖，所以如果我们并没有办法在 onHandleIntent() 方法里进行注入。而 onHandleIntent() 方法没有返回值，SessionCalendarService 类里也没有能让我们检查测试后状态的可访问的属性。为了验证测试后状态，我们可以通过查询 ContentProvider 检查请求数据是否被插入，但我们不会这样的方式为 SessionCalendarService 实现测试单元。相反，我们用的方法是实现一个整合测试，同时测试 SessionCalendarService 以及受 ContentProvider 操控的日历会议数据。</p>
<p>所以如果你把业务逻辑放在 Android 类里，而这个类的依赖又无法被注入，那这部分代码铁定没办法进行单元测试了。类似的无法被注入的依赖还有呢，例如：Activity 和 Fragment 的 FragmentManager。因此，至今为止 Google 官方一直鼓励我们使用的标准 Android 应用架构模式，教导我们在开发应用的时候要把业务逻辑放在应用的组件类里，信誓旦旦地说这是为我们好，而我们今天才知道真相竟然是：正是这样的架构让我们写下无法测试的代码。</p>
<h2 id="标准开发模式让单元测试变得困难重重">标准开发模式让单元测试变得困难重重</h2><p>某些情况下，标准的开发模式使代码的单元测试变得十分困难。如果我们回到上一篇博文提到的 SessionDetailActivity 里的 onStop() 方法，可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="keyword">if</span> (mInitStarred != mStarred) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UIUtils.getCurrentTime(<span class="keyword">this</span>) &lt; mSessionStart) &#123;</span><br><span class="line">            <span class="comment">// Update Calendar event through the Calendar API on Android 4.0 or new versions.</span></span><br><span class="line">            Intent intent = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line">                <span class="comment">// Set up intent to add session to Calendar, if it doesn't exist already.</span></span><br><span class="line">                intent = <span class="keyword">new</span> Intent(SessionCalendarService.ACTION_ADD_SESSION_CALENDAR,</span><br><span class="line">                        mSessionUri);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_START,</span><br><span class="line">                        mSessionStart);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_END,</span><br><span class="line">                        mSessionEnd);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_ROOM, mRoomName);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_TITLE, mTitleString);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Set up intent to remove session from Calendar, if exists.</span></span><br><span class="line">                intent = <span class="keyword">new</span> Intent(SessionCalendarService.ACTION_REMOVE_SESSION_CALENDAR,</span><br><span class="line">                        mSessionUri);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_START,</span><br><span class="line">                        mSessionStart);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_END,</span><br><span class="line">                        mSessionEnd);</span><br><span class="line">                intent.putExtra(SessionCalendarService.EXTRA_SESSION_TITLE, mTitleString);</span><br><span class="line">            &#125;</span><br><span class="line">            intent.setClass(<span class="keyword">this</span>, SessionCalendarService.class);</span><br><span class="line">            startService(intent);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mStarred) &#123;</span><br><span class="line">                setupNotification();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像你看到的那样，onStop() 方法里压根没有能让我们知道 SessionCalendarService 是否通过正确的参数启动的可访问属性，此外，onStop() 方法是一个受保护的方法，使其返回值是无法修改的。因此，我们访问测试后状态的唯一办法就是检查注入到 onStop() 方法内的注入的状态。</p>
<p>这样一来，我们就会注意到 onStop() 方法中用于启动 SessionCalendarService 的代码并不属于某一个类。换句话说，onStop() 方法中注入的依赖根本不存在用于检查 SessionCalendarService 是否在正确的情况下通过正确的参数启动的测试单元测试后状态的属性。为了提出能让 onStop() 方法变为可测试的的第三种办法，那我们需要一些这样的东西：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStop<span class="params">()</span> &#123;</span><br><span class="line">    super.onStop<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(mInitStarred != mStarred)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(UIUtils.getCurrentTime<span class="params">(this)</span> &lt; mSessionStart)</span> &#123;</span><br><span class="line">            <span class="comment">// Update Calendar event through the Calendar API on Android 4.0 or new versions.</span></span><br><span class="line">            Intent intent = null;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(mStarred)</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Service launcher sets up intent to add session to Calendar</span></span><br><span class="line">                mServiceLauncher.launchSessionCalendarService<span class="params">(SessionCalendarService.ACTION_ADD_SESSION_CALENDAR, mSessionUri, </span><br><span class="line">                                                            mSessionStart, mSessionEnd, mRoomName, mTitleString)</span>;</span><br><span class="line">                                                            </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Set up intent to remove session from Calendar, if exists.</span></span><br><span class="line">                mServiceLauncher.launchSessionCalendarService<span class="params">(SessionCalendarService.ACTION_REMOVE_SESSION_CALENDAR, mSessionUri,</span><br><span class="line">                                                            mSessionStart, mSessionEnd, mTitleString)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(mStarred)</span> &#123;</span><br><span class="line">                setupNotification<span class="params">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这不是重构 onStop() 方法最简洁的方式，但如果我们按照标准开发方法把业务逻辑写在 Activity 里，并让写下的代码可以进行单元测试，类似的处理就变得必要了。现在不妨想想这种重构方式有多么违反常理：我们没有简单地调用 startService() 方法（startService() 是 Context 的一个方法，我们甚至可以说调用的是 SessionDetailActivity 的方法），而是通过依赖于 Context 的 ServiceLauncher 对象去启动该服务。SesionDetailActivity 作为 Context 的子类也将使用一个持有 Context 的对象去启动 SessionCalendarService。</p>
<p>不幸的是，即使我们像上面说的那样重构了 onStop() 方法，我们仍然不能保证能为 onStop() 方法实现测试单元。问题在于：ServiceLauncher 没有被注入，使得我们不能对 ServiceLauncher 进行注入，使我们能验证在测试过程中调用了正确的方法。</p>
<p>要对 ServiceLauncher进行注入，除了刚刚提到的以外，还会因为 ServiceLauncher 自身依赖于 Context 变得复杂，因为 Context 是一个非打包对象。因此，你并不能简单地通过将其传入用于启动  SessionDetailActivity 的 Intent 注入 ServiceLauncher。所以为了注入 ServiceLauncher，你需要开动你的小脑筋，或者使用类似于 Dagger¹ 的注入库。现在你应该也会发现，为了让我们的代码可以进行单元测试，我们确实需要完成许多复杂、繁琐的工作，而且，正如我即将在下篇博文中的论述，就算我们为了进行依赖注入而使用 Dagger 这样的库，在 Activity 内进行单元测试仍然是令人备受煎熬的。</p>
<p>为了让 onStop() 方法能进行单元测试，标准开发方式强迫我们使用反常理的重构方法，并要求我们在“根据以 Intent 为基础的依赖注入机制想出更好的重构方法”或“使用第三方的依赖注入库”。而标准开发方式为写下可测试代码带来的困难，就像在鼓励我们写下无法进行测试的代码，正是这种困难让我认为：标准开发方式阻碍我们写下可测试代码。</p>
<h2 id="结论">结论</h2><p>在整个系列博文中，我一直在提出这样的观点：通过反思为什么在 Android 中进行单元测试如此困难，将帮助我们发现重构应用架构的各种好处，使我们的应用不必明确地依赖于 Android SDK。这篇博文论述到这里，我相信大家有足够理由相信完全摆脱 Android SDK 或许是个好提议了。</p>
<p>我刚刚把业务逻辑放在应用的组件类中，并向大家证明了对其进行单元测试有多么困难，甚至我们可以说对其进行单元测试这是不可能的。在下一篇博文中，我将建议大家将业务逻辑委托给使用了正确的依赖注入姿势的类。如果我们觉得定义这些类很麻烦的话，退而求其次，也能让这些类的依赖成为与 Android 无关的接口。与增强程序测试性的第一步相比，这一步是至关重要的，而完成第二步使我们无需 Android 特有的测试工具（例如：Roboletric，Instrumented Tests）就能写下更高效的测试单元。</p>
<p><strong>注</strong></p>
<ol>
<li>毫无疑问，你在传入 ServiceLauncher 时应该使他变为一个序列化对象。但这并不是一个特别健壮的解决办法，因为只有在你不在乎序列化带来的性能影响时才能使用这个办法。</li>
</ol>
<blockquote>
<ul>
<li>原文链接 : <a href="http://philosophicalhacker.com/2015/04/24/why-android-unit-testing-is-so-hard-pt-2/" target="_blank" rel="external">Why Android Unit Testing is so hard</a></li>
<li>原文作者 : <a href="http://philosophicalhacker.com/" target="_blank" rel="external">Matthew Dupree</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我用干货告诉大家：即使是 Google 大牛写出来的代码也无法进行测试。确切地说，我真正告诉大家的是：根本没办法在 SessionDetailActivity 的 onStop() 方法里进行单元测试，而且详细地解释了个中因果：由于无法改变预测试状态，我们无法在 onStop() 方法里完成断言；在 onStop() 方法中进行测试时，获得测试后状态也是无法完成的。在上篇博文的结尾处，我跟大家说：正是 Android SDK 的某些特性，以及 Google 官方推荐的代码模板使得单元测试处于如此尴尬的境地，而且我承诺会在这篇博文中详尽地解释各种因由，那现在就让我来兑现我的诺言吧。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="单元测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解RxJava(1)-基础篇]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-1/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:46:29.000Z</updated>
    <content type="html"><![CDATA[<p>RxJava正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br> 这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。<br><a id="more"></a></p>
<h2 id="基础">基础</h2><p>RxJava最核心的两个东西是Observables（被观察者，事件源）和 Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西 （触摸事件，web接口调用返回的数据。。。）</p>
<p>一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onNext()或者Subscriber.onError()结束。</p>
<p>Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。</p>
<h2 id="Hello_World">Hello World</h2><p>创建一个Observable对象很简单，直接调用Observable.create即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable myObservable = Observable.create(</span><br><span class="line">    <span class="keyword">new</span> Observable.OnSubscribe() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; sub)</span> </span>&#123;</span><br><span class="line">        sub.onNext(<span class="string">"Hello, world!"</span>);</span><br><span class="line">        sub.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这里定义的Observable对象仅仅发出一个Hello World字符串，然后就结束了。接着我们创建一个Subscriber来处理Observable对象发出的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Subscriber mySubscriber = <span class="keyword">new</span> Subscriber() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"> 这里subscriber仅仅就是打印observable发出的字符串。通过subscribe函数就可以将我们定义的myObservable对象和mySubscriber对象关联起来，这样就完成了subscriber对observable的订阅。</span><br><span class="line">`myObservable.subscribe(mySubscriber);`  </span><br><span class="line"> 一旦mySubscriber订阅了myObservable，myObservable就是调用mySubscriber对象的onNext和onComplete方法，mySubscriber就会打印出Hello World！</span><br><span class="line"></span><br><span class="line">## 更简洁的代码</span><br><span class="line"></span><br><span class="line">是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</span><br><span class="line"></span><br><span class="line">首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如 Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的代码可以简化为一行</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Observable myObservable = Observable.just(<span class="string">"Hello, world!"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来看看如何简化Subscriber，上面的例子中，我们其实并不关心OnComplete和OnError，我们只需要在onNext的时候做一些处理，这时候就可以使用Action1类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action1 onNextAction = <span class="keyword">new</span> Action1() &#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>subscribe方法有一个重载版本，接受三个Action1类型的参数，分别对应OnNext，OnComplete， OnError函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(onNextAction, onErrorAction, onCompleteAction);</span><br></pre></td></tr></table></figure>
<p> 这里我们并不关心onError和onComplete，所以只需要第一个参数就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// Outputs “Hello, world!”</span></span><br></pre></td></tr></table></figure>
<p> 上面的代码最终可以写成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">	.subscribe(<span class="keyword">new</span> Action1() &#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>使用java8的lambda可以使代码更简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">   .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>Android开发中，强烈推荐使用retrolambda这个gradle插件，这样你就可以在你的代码中使用lambda了。</p>
<h2 id="变换">变换</h2><p>让我们做一些更有趣的事情吧！<br> 比如我想在hello world中加上我的签名，你可能会想到去修改Observable对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world! -Dan"</span>)</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>如果你能够改变Observable对象，这当然是可以的，但是如果你不能修改Observable对象呢？比如Observable对象是第三方库提供的？比如我的Observable对象被多个Subscriber订阅，但是我只想在对某个订阅者做修改呢？<br> 那么在Subscriber中对事件进行修改怎么样呢？比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s + <span class="string">" -Dan"</span>));</span><br></pre></td></tr></table></figure>
<p>这种方式仍然不能让人满意，因为我希望我的Subscribers越轻量越好，因为我有可能会在mainThread中运行subscriber。另外， 根据响应式函数编程的概念，Subscribers更应该做的事情是“响应”，响应Observable发出的事件，而不是去修改。如果我能在某些中间步 骤中对“Hello World！”进行变换是不是很酷？</p>
<h2 id="操作符（Operators）">操作符（Operators）</h2><p>操作符就是为了解决对Observable对象的变换的问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件。RxJava提供了很多很有用的操作符。<br> 比如map操作符，就是用来把把一个事件转换为另一个事件的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">	.map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> s + <span class="string">" -Dan"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>使用lambda可以简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .map(s -&gt; s + <span class="string">" -Dan"</span>)</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>是不是很酷？map()操作符就是用于变换Observable对象的，map操作符返回一个Observable对象，这样就可以实现链式调用，在一个Observable对象上多次使用map操作符，最终将最简洁的数据传递给Subscriber对象。</p>
<h2 id="map操作符进阶">map操作符进阶</h2><p>map操作符更有趣的一点是它不必返回Observable对象返回的类型，你可以使用map操作符返回一个发出新的数据类型的observable对象。<br> 比如上面的例子中，subscriber并不关心返回的字符串，而是想要字符串的hash值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">	    <span class="annotation">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	       <span class="keyword">return</span> s.hashCode();</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(i -&gt; System.out.println(Integer.toString(i)));</span><br></pre></td></tr></table></figure>
<p>很有趣吧？我们初始的Observable返回的是字符串，最终的Subscriber收到的却是Integer，当然使用lambda可以进一步简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">   .map(s -&gt; s.hashCode())</span><br><span class="line">   .subscribe(i -&gt; System.out.println(Integer.toString(i)));</span><br></pre></td></tr></table></figure>
<p>前面说过，Subscriber做的事情越少越好，我们再增加一个map操作符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .map(s -&gt; s.hashCode())</span><br><span class="line">    .map(i -&gt; Integer.toString(i))</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<h2 id="不服？">不服？</h2><p>是不是觉得我们的例子太简单，不足以说服你？你需要明白下面的两点:</p>
<p>1.Observable和Subscriber可以做任何事情<br> Observable可以是一个数据库查询，Subscriber用来显示查询结果；Observable可以是屏幕上的点击事件，Subscriber用来响应点击事件；Observable可以是一个网络请求，Subscriber用来显示请求结果。</p>
<p>2.Observable和Subscriber是独立于中间的变换过程的。<br> 在Observable和Subscriber中间可以增减任何数量的map。整个系统是高度可组合的，操作数据是一个很简单的过程。</p>
<p>原文链接 : <a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="external">深入理解RxJava-基础篇</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>RxJava正在Android开发者中变的越来越流行。唯一的问题就是上手不容易，尤其是大部分人之前都是使用命令式编程语言。但是一旦你弄明白了，你就会发现RxJava真是太棒了。<br> 这里仅仅是帮助你了解RxJava，整个系列共有四篇文章，希望你看完这四篇文章之后能够了解RxJava背后的思想，并且喜欢上RxJava。<br>]]>
    
    </summary>
    
      <category term="RxJava/RxAndroid" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/"/>
    
      <category term="Reactive Extension(RX)" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Reactive-Extension-RX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Espresso 测试框架介绍]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/an-introduction-to-espresso/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/an-introduction-to-espresso/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:40:19.000Z</updated>
    <content type="html"><![CDATA[<p>Espresso 是一个提供了简单 API 的用于 android app UI 测试的测试框架。最新的 2.0 版本发布后已经可以在 Android Support Repository 中下载了，那么在项目中集成它就方便多了。<br><a id="more"></a><br>但在我们看 Espresso 的 API 之前，让我们来细看下它与其它测试框架的不同：</p>
<ul>
<li>你首先会注意到的是，他写出来的代码很像英文，可想而知它是很容易学习的</li>
<li>API 相当的小，当然也会对扩展开放的</li>
<li>Espresso 的测试跑起来那是相当的快（没有等待、睡眠）</li>
<li>Gradle 和 Android Studio 的支持</li>
</ul>
<h2 id="在你的项目中添加_Espresso">在你的项目中添加 Espresso</h2><p>1、首先保证你的 Android Support Repository 已经成功安装<br><img src="https://camo.githubusercontent.com/9dd5f96cf5742551f304606abf64c68a3c59ff99/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f73646b2d6d616e61676572312e706e673f773d35353026683d333033" alt="Android Support Repository"></p>
<p>2、在你程序的 build.gradle 文件中添加依赖</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">   androidTestCompile <span class="string">'com.android.support.test:testing-support-lib:0.1'</span></span><br><span class="line">   androidTestCompile <span class="string">'com.android.support.test.espresso:espresso-core:2.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、最后，在默认配置中指定 test instrumentation runner</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> </span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些基本上就是在你的项目中集成 Espresso 测试框架了（给你的项目一杯浓咖啡提提神~）！</p>
<h2 id="Espresso_的主要组件">Espresso 的主要组件</h2><p>Espresso 由 3 个主要的组件构成。</p>
<p>这些组件是：</p>
<ul>
<li>ViewMatchers - 在当前的 view 层级中定位一个 view</li>
<li>ViewActions - 跟你的 view 交互</li>
<li>ViewAssertions - 给你的 view 设置断言</li>
</ul>
<p>更简单的可以用下面的短语来表述它们：</p>
<ul>
<li>ViewMatchers – “ <code>找</code> 某些东西“</li>
<li>ViewActions – “ <code>做</code> 某些事情“</li>
<li>ViewAssertions – “ <code>检查</code> 某些东西“</li>
</ul>
<p>举个例子，当你需要 <code>检查</code> 某些东西（像在屏幕中显示一些文字），你就会知道你需要一个 ViewAssertions 来做这些工作。</p>
<p>Below is an example of a test in Espresso, and where the main components find their place.</p>
<p>下面是使用 Espresso 的例子，你会看到那些主要的组件将会在哪里出现使用。</p>
<p><img src="https://camo.githubusercontent.com/31ed007bd41bee4646ad1b28388acd32632ad128/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f6573706573736f5f6d61696e5f636f6d706f6e656e74732e706e67" alt="main components"></p>
<h2 id="一个使用_onView()_的简单测试">一个使用 onView() 的简单测试</h2><p>假设我们有一个 app，需要用户输入它的名字。</p>
<p>输入名字之后，用户按下了“下一步”按钮然后就会跳转到另一个显示问候信息的 activity。</p>
<p><img src="https://camo.githubusercontent.com/d441e968f5c167fa198089bccec828317b143ec6/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f73696d706c655f746573745f6f6e766965772e706e673f773d353935" alt="scenario"></p>
<p>如果我们按这个方案来写一个测试的话，它看上去将会这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// locate the view with id "user_name" and type the text "John"</span></span><br><span class="line">onView(withId(R.id.user_name)).perform(typeText(<span class="string">"John"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// locate the view with id "next" and click on it</span></span><br><span class="line">onView(withId(R.id.next)).perform(click());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// locate the view with id "greeting_message" and check its text is equal with "Hello John!"</span></span><br><span class="line">onView(withId(R.id.greeting_message)).check(matches(withText(<span class="string">"Hello John!"</span>)));</span><br></pre></td></tr></table></figure>
<p>注意到我们并没有特别指定与其交互的 view 的信息（eg： EditText、Button），我们只是简单的说明了我们要找一个指定 id 的 view。</p>
<p>同样，当点击“下一步”按钮时然后检测文本时，我们也没有写代码来告诉 Espresso 我们有跳转到其它的 activity。</p>
<p>现在，如果要跑起这个测试用例，我们需要把这写代码写到一个类中，然后对于在 Gradle 中这个类应该保存的位置：yourApp<code>/src/androidTest/java</code>。</p>
<p>这个就是测试类的样子和它的主要特征：</p>
<p><img src="https://camo.githubusercontent.com/5c14915750ff91ea8a11988a43f4f409249af3b8/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f636c6173732e706e67" alt="SimpleNameTest"></p>
<h2 id="一个使用_onData_的简单测试">一个使用 onData 的简单测试</h2><p>每当你有一个 ListView、GridView、Spinner 或者其它基于 Adapter 的view时，你都必须使用 <code>onData()</code> 来把 item 和 list 的数据联系起来。</p>
<p><strong>onData()</strong> 是给你的 adapter 提供数据的。这是什么意思呢，接下来你就会知道了。</p>
<p>在一个假想的程序中我们需要在一个 <strong>Spinner</strong> 中选择一个国家，一旦选定，这个国家的名字就会在 Spinner 的旁边显示出来。</p>
<p><img src="https://camo.githubusercontent.com/3a44ad1542591759e537767e0de38092fdf8b07f/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f6f6e646174615f73696d706c652e706e673f773d353935" alt="Registration"></p>
<p>下面的测试就是检查显示出的国家是否与我们选择的相符合，代码长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// locate the view with id "country_spinner" and click on it</span></span><br><span class="line">onView(withId(R.id.country_spinner)).perform(click());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// match an item that is a String and is equal with whatever value the COUNTRY constant is initialized, then click on it.</span></span><br><span class="line">onData(allOf(is(instanceOf(String.class)), is(COUNTRY))).perform(click());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// locate the view with id "selected_country" and check its text is equal with COUNTRY</span></span><br><span class="line">onView(withId(R.id.selected_country)).check(matches(withText(<span class="string">"selected: "</span> + COUNTRY)));</span><br></pre></td></tr></table></figure>
<p>上文中你看到的这个 Spinner 的适配数据是一个字符串的简单数组，所以对于我们要找的 item 来说我们也要指定 String 的数据类型。如果不是一个 String 而是一些自定义的对象呢，我们应该指定这些自定义的对象。</p>
<p>思考下下面这个显示一个 books 的 list 集合数据的例子：</p>
<p><img src="https://camo.githubusercontent.com/90a05ed775edbd7ab9c76bc5bb72c57a37fa1f7b/68747470733a2f2f616e64726f696472657365617263682e66696c65732e776f726470726573732e636f6d2f323031352f30332f626f6f6b732d61646170746572312e706e673f773d35393526683d333838" alt="AdapterView"></p>
<p>把 item 的数据改为 Book 后，来看看查询:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onData(allOf(is(instanceOf(Book.class)), withBookTitle(BOOK_TITLE))).perform(click());</span><br></pre></td></tr></table></figure>
<h2 id="数据交互">数据交互</h2><p>Espresso 有一些很有用的方法可以用来处理数据间的交互。</p>
<p><strong>atPosition()</strong> - 在下述的这些情况中会很有用，与相应元素交互的对象是不相关的，或 items 的顺序是特定的所以你知道每个 item 在哪个位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onData(...).atPosition(<span class="number">2</span>).perform(click());</span><br></pre></td></tr></table></figure>
<p><strong>inRoot()</strong> - 在没有默认窗口的情况下使用 inRoot()。这个场景可以应用在测试需自动完成时。这个 list 出现在自动输入填写完成的 view 是属于应用窗口之上的窗口视图。</p>
<p>这种情况下你必须指定你要查找的数据，而这数据并不在主程序窗口中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onView(withText(<span class="string">"AutoCompleteText"</span>))</span><br><span class="line">        .inRoot(withDecorView(not(is(getActivity().getWindow().getDecorView()))))</span><br><span class="line">        .check(matches(isDisplayed()));</span><br></pre></td></tr></table></figure>
<p><strong>onChildView()</strong>  - 这个数据交互可以进一步地精取出在一个 list 中的指定的（item） view。</p>
<p>你有一个集合列表，每一行的 item 上都有一个删除按钮。你想点击指定 item 上的删除按钮：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onData(withBookTitle(<span class="string">"My Book"</span>))</span><br><span class="line">      .onChildView(withId(R.id.book_delete)).perform(click());</span><br></pre></td></tr></table></figure>
<p><strong>inAdapterView()</strong> - 可以选择指定一个 adapter view 去操作，默认情况下 Espresso 可以操作任何 adapter view。</p>
<p>你可能会发现这个在处理 <code>ViewPagers</code> 和 <code>Fragments</code> 时很有用，或者，你想要与当前显示的 AdapterView 交互时，你的 activity 中有多个 adapter view 时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onData(withBookTitle(<span class="string">"My Book"</span>))</span><br><span class="line">      .inAdapterView(allOf(isAssignableFrom(AdapterView.class), isDisplayed()))</span><br><span class="line">      .perform(click());</span><br></pre></td></tr></table></figure>
<h2 id="Espresso_和_RecyclerView">Espresso 和 RecyclerView</h2><p><a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html" target="_blank" rel="external">RecyclerView</a> 是一个像 ListView、GridVIew 那样呈现数据集合的 UI 组件，实际上它的目的是要替换掉这两个组件。从测试的角度上来看我们感兴趣的有是 RecyclerView 不是一个 AdapterView，这意味着你不能使用 onData() 去跟你的 list items 交互。</p>
<p>Fortunately, there is a class called RecyclerViewActions that exposes a small API to operate on a RecyclerView. RecyclerViewActions is part of a separate lib called espresso-contrib, that also should be added to build.gradle:</p>
<p>幸运的是，有一个叫 <a href="https://developer.android.com/reference/android/support/test/espresso/contrib/RecyclerViewActions.html" target="_blank" rel="external">RecyclerViewActions</a> 的类提供了简单的 API 给我们操作 RecyclerView。RecyclerViewActions 是 <strong>espresso-contrib</strong>库的一部分，这个库的依赖可以在 build.gradle 中添加：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    androidTestCompile(<span class="string">'com.android.support.test.espresso:espresso-contrib:2.0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为你的项目已经包括 recyclerview 依赖, 所以不妨也加上支持库的，一些依赖关系可能出现的冲突。在这种情况下可以在 espresso-contrib 中 exclude 他们：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    androidTestCompile(<span class="string">'com.android.support.test.espresso:espresso-contrib:2.0'</span>) &#123;</span><br><span class="line">        exclude group: <span class="string">'com.android.support'</span>, module: <span class="string">'appcompat'</span></span><br><span class="line">        exclude group: <span class="string">'com.android.support'</span>, module: <span class="string">'support-v4'</span></span><br><span class="line">        exclude module: <span class="string">'recyclerview-v7'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是示例怎么（在RecyclerView）点击指定位置的 item：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onView(withId(R.id.recyclerView))</span><br><span class="line">      .perform(RecyclerViewActions.actionOnItemAtPosition(<span class="number">0</span>, click()));</span><br></pre></td></tr></table></figure>
<p>或者怎么点击指定 item 上的 view：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onView(withId(R.id.recyclerView))</span><br><span class="line">      .perform(RecyclerViewActions.actionOnItem(</span><br><span class="line">                hasDescendant(withText(BOOK_TITLE)), click()));</span><br></pre></td></tr></table></figure>
<p>更多 Espresso 的例子请戳：<a href="https://github.com/vgrec/EspressoExamples" target="_blank" rel="external">https://github.com/vgrec/EspressoExamples</a></p>
<blockquote>
<ul>
<li>原文链接 : <a href="https://androidresearch.wordpress.com/2015/04/04/an-introduction-to-espresso/" target="_blank" rel="external">Introduction to Android Espresso</a></li>
<li>原文作者 : <a href="https://androidresearch.wordpress.com/author/androidresearch/" target="_blank" rel="external">Veaceslav Grec</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/zhengxiaopeng" target="_blank" rel="external">zhengxiaopeng</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Espresso 是一个提供了简单 API 的用于 android app UI 测试的测试框架。最新的 2.0 版本发布后已经可以在 Android Support Repository 中下载了，那么在项目中集成它就方便多了。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 如何直播RTMP流]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/stream-rtmp-live-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/stream-rtmp-live-android/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:43:58.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://camo.githubusercontent.com/c1f73924d00c1ac155aa4975c7ce20561923a0ec/687474703a2f2f7777772e74727569746f6e2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30332f416e64726f69642d52544d502d506c617965722e706e67" alt="rtmp"><br>在android上，视频/音频流直播是极少有人关注的一部分。每当我们讨论流媒体，RTMP<a href="http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol" target="_blank" rel="external">(Real Time Messaging Protocol)</a>是不可或缺的。RTMP是一个基本的视频/音频直播流协议，但是不幸的是Android标准的<a href="http://developer.android.com/reference/android/widget/VideoView.html" target="_blank" rel="external">VideoView</a>不支持RTMP的播放。因此，如果想在android上播放RTMP直播流，你必须使用支持RTMP协议的库。在本教程中我们将讨论如何通过使用安卓的 [Vitamio]（<a href="https://www.vitamio.org/en/）" target="_blank" rel="external">https://www.vitamio.org/en/）</a> 库播放由 RTMP 协议传输的流媒体。<br><a id="more"></a></p>
<h2 id="Android_Vitamio_库">Android Vitamio 库</h2><p>Vitamio是一个android和ios上基于<a href="https://www.ffmpeg.org/" target="_blank" rel="external">FFmpeg</a>的开源项目。Vitamio为我们提供了一个清洁、简单、全面、真实的硬件加速解码器和渲染器API，Vitamio是一个支持多种音视频格式 如 FLV, TS/TP, WMV, DivX, Xvid等多种标准格式的非常强大的库。所不同的是，它也支持类似.mkv和.srt嵌入和外挂字幕播放。但是它带有一个许可证，因此在使用它之前请先获得<a href="https://www.vitamio.org/en/License/" target="_blank" rel="external">认证</a>。在这个android RTMP例子中，我们不仅讨论RTMP直播流，而且也会讨论m3u8流（HLS），RTSP流和 MMS (Microsoft Media Stream)。首先让在我们的项目中引用Vitamio库。</p>
<h4 id="在Android_Studio中引用Vitamio库的步骤如下：">在Android Studio中引用Vitamio库的步骤如下：</h4><ol>
<li>下载Vitamio bundle <a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="external">https://github.com/yixia/VitamioBundle</a></li>
<li>解压并且在Android Studio上File-&gt;Import Module</li>
<li>指定到VitamioBundle路径，选择vitamio文件夹 点击完成</li>
<li>在build.gradle(Module: app)依赖部分添加依赖项目(‘:vitamio’)</li>
<li>打开build.gradle (Module: vitamio) - 改变最小sdk版本为7</li>
<li>不要忘记在manifest.xml中添加internet权限</li>
<li>完成！</li>
</ol>
<h4 id="Android_RTMP流">Android RTMP流</h4><p>在讲述如何使用之前，让我们先了解下RTMP。Real Time Messaging Protocol (RTMP)是一个Adobe Systems所拥有的一个协议。该协议是Adobe公司拥有的开发音视频流的flash player。后来该协议的部分被公开，供公众使用。更多请查看<a href="http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol" target="_blank" rel="external">这里</a>.这个协议大多用于IPTV和实时视频点播流，但它也用于其他领用。</p>
<p>在android上，标准的VideoView不支持RTMP播放。但WebView可以播放RTMP流。这解决了播放RTMP流的问题，但是我认为web apps 不能提供一个很好的界面和体验。因此这这个android RTMP例子中我们将运用第三方库-Vitamio 直播RTMP流的流媒体。在工程中引用Vitamio之后，请在你的layout文件添加Vitamio的VideoView：</p>
<p>activity_main.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">io.vov.vitamio.widget.VideoView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/vitamio_videoView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">       <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外请编写你的activity如下：</p>
<p>MainActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.truiton.rtmpplayer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.ActionBarActivity;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> io.vov.vitamio.LibsChecker;</span><br><span class="line"><span class="keyword">import</span> io.vov.vitamio.MediaPlayer;</span><br><span class="line"><span class="keyword">import</span> io.vov.vitamio.widget.MediaController;</span><br><span class="line"><span class="keyword">import</span> io.vov.vitamio.widget.VideoView;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//private HashMap&lt;String, String&gt; options;</span></span><br><span class="line">    <span class="keyword">private</span> VideoView mVideoView;</span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (!LibsChecker.checkVitamioLibs(<span class="keyword">this</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mVideoView = (VideoView) findViewById(R.id.vitamio_videoView);</span><br><span class="line">        path = <span class="string">"rtmp://rrbalancer.broadcast.tneg.de:1935/pw/ruk/ruk"</span>;</span><br><span class="line">        <span class="comment">/*options = new HashMap&lt;&gt;();</span><br><span class="line">        options.put("rtmp_playpath", "");</span><br><span class="line">        options.put("rtmp_swfurl", "");</span><br><span class="line">        options.put("rtmp_live", "1");</span><br><span class="line">        options.put("rtmp_pageurl", "");*/</span></span><br><span class="line">        mVideoView.setVideoPath(path);</span><br><span class="line">        <span class="comment">//mVideoView.setVideoURI(Uri.parse(path), options);</span></span><br><span class="line">        mVideoView.setMediaController(<span class="keyword">new</span> MediaController(<span class="keyword">this</span>));</span><br><span class="line">        mVideoView.requestFocus();</span><br><span class="line"> </span><br><span class="line">        mVideoView.setOnPreparedListener(<span class="keyword">new</span> MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mediaPlayer)</span> </span>&#123;</span><br><span class="line">                mediaPlayer.setPlaybackSpeed(<span class="number">1.0f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上面代码很清晰明了，但需要指出的是请修改你播放RTMP流的路径。在android上，有时可能使用带报头路径来播放RTMP流。幸运的是，Vitamio RTMP播放器也支持这种方式。因此，所有类型的RTMP流可以使用Vitamio库。上面的例子会是这个样子：<br><img src="https://camo.githubusercontent.com/ec37327770e1720344f1bafa96a5db51bf602ebb/687474703a2f2f7777772e74727569746f6e2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30332f416e64726f69642d52544d502d53747265616d2d4c6976652e706e67" alt="Rtmpplayer"></p>
<h4 id="Android_RTSP流媒体">Android RTSP流媒体</h4><p>实时流协议(RTSP)通过多媒体服务器传输内容，例如YouTube使用RTSP流发布内容。关于RTSP流比较容易的部分是，它可以通过android标准的VideoView来完成，想了解更多，请参考我的<a href="http://www.truiton.com/2013/08/android-videoview-example-with-youtube-playback/" target="_blank" rel="external">VideoView例子</a>。</p>
<p>但是如果你使用Vitamio库，可以更好的播放RTSP流。事实上Vitamio也支持RTSP流的回播。和上面过程是一样的，包括Vitamio的VideoView在布局文件，并使用路径变量指定的RTSP url</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mVideoView = (VideoView) findViewById(R.id.vitamio_videoView);</span><br><span class="line">path = <span class="string">"rtsp://wowzaec2demo.streamlock.net/vod/mp4:BigBuckBunny_115k.mov"</span>;</span><br><span class="line">mVideoView.setVideoPath(path);</span><br><span class="line">mVideoView.setMediaController(<span class="keyword">new</span> MediaController(<span class="keyword">this</span>));</span><br><span class="line">mVideoView.requestFocus();</span><br><span class="line"></span><br><span class="line">mVideoView.setOnPreparedListener(<span class="keyword">new</span> MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mediaPlayer)</span> </span>&#123;</span><br><span class="line">        mediaPlayer.setPlaybackSpeed(<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Android_m3u8_流媒体">Android m3u8 流媒体</h4><p>“如何在android上播放m3u8视频”是android开发者最常见的问题之一。通过Http 协议进行视频流直播最简单的办法就是使用标准的 VideoView. 但只能在android3.0以上的设备上播放m3u8流。因为在Android 3.0引入HTTP/ HTTPS直播和HTTP/ HTTPS渐进式流媒体协议，在android3.1完全支持HTTPS。</p>
<p>如果你希望在早期的版本上实现支持android m3u8流的HTTP实时流媒体 (HLS)。应该考虑使用Vitamio库，这个库支持在android API7以上播放m3u8。使用方式，同样的在布局文件中使用Vitamio的VideoView，并指定的HTTP实时流媒体URL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mVideoView = (VideoView) findViewById(R.id.vitamio_videoView);</span><br><span class="line">path = <span class="string">"http://93.184.221.133/00573D/236/236-0.m3u8"</span>;</span><br><span class="line">mVideoView.setVideoPath(path);</span><br><span class="line">mVideoView.setMediaController(<span class="keyword">new</span> MediaController(<span class="keyword">this</span>));</span><br><span class="line">mVideoView.requestFocus();</span><br><span class="line"></span><br><span class="line">mVideoView.setOnPreparedListener(<span class="keyword">new</span> MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mediaPlayer)</span> </span>&#123;</span><br><span class="line">        mediaPlayer.setPlaybackSpeed(<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Playing m3u8 stream on Android with Vitamio would look something like this:<br>在androi上使用Vitamio播放m3u8流效果如下：<br><img src="https://camo.githubusercontent.com/98d36c22e3138c81e0142ddf614b031c750cb414/687474703a2f2f7777772e74727569746f6e2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30332f416e64726f69642d6d3375382d53747265616d696e672e706e67" alt="m3u8"></p>
<h4 id="Android_MMS_流">Android MMS 流</h4><p>Vitamio库是一个强大的库，还支持Microsoft媒体服务器（MMS）流中的播放。 MMS是网络流媒体协议，主要用于网络广播和电台直播。使用Vitamio用于在anroid的MMS流和其他协议没有什么不同。所有你需要做的只是更换路径变量指向一个MMS url：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mVideoView = (VideoView) findViewById(R.id.vitamio_videoView);</span><br><span class="line">path = <span class="string">"mms://beotelmedia.beotel.net/studiob"</span>;</span><br><span class="line">mVideoView.setVideoPath(path);</span><br><span class="line">mVideoView.setMediaController(<span class="keyword">new</span> MediaController(<span class="keyword">this</span>));</span><br><span class="line">mVideoView.requestFocus();</span><br><span class="line"></span><br><span class="line">mVideoView.setOnPreparedListener(<span class="keyword">new</span> MediaPlayer.OnPreparedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPrepared</span><span class="params">(MediaPlayer mediaPlayer)</span> </span>&#123;</span><br><span class="line">        mediaPlayer.setPlaybackSpeed(<span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="结论">结论</h2><p>通过上面的讨论，可以确定地说，Vitamio是一个强大的多平台库（ios and android）。通过使用Vitamio库 能播放多种类型的视频格式和协议如RTMP, RTSP, HTTP Live, and HTTP渐进式流协议。另外一个很好的功能是，vitamio支持字幕和多音轨的播放。Vitamio的唯一的缺点是，它不是完全的开源。您可能需要购买许可证来使用它。希望这会有所帮助。通过Facebook, Google+ and Twitter来联系我们获取更多更新。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.truiton.com/2015/03/stream-rtmp-live-android/" target="_blank" rel="external">How To Stream RTMP live in Android</a></li>
<li>原文作者 : <a href="google.com/+MohitGupt">Mohit Gupt</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/ayyb1988" target="_blank" rel="external">ayyb1988</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://camo.githubusercontent.com/c1f73924d00c1ac155aa4975c7ce20561923a0ec/687474703a2f2f7777772e74727569746f6e2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30332f416e64726f69642d52544d502d506c617965722e706e67" alt="rtmp"><br>在android上，视频/音频流直播是极少有人关注的一部分。每当我们讨论流媒体，RTMP<a href="http://en.wikipedia.org/wiki/Real_Time_Messaging_Protocol">(Real Time Messaging Protocol)</a>是不可或缺的。RTMP是一个基本的视频/音频直播流协议，但是不幸的是Android标准的<a href="http://developer.android.com/reference/android/widget/VideoView.html">VideoView</a>不支持RTMP的播放。因此，如果想在android上播放RTMP直播流，你必须使用支持RTMP协议的库。在本教程中我们将讨论如何通过使用安卓的 [Vitamio]（<a href="https://www.vitamio.org/en/）">https://www.vitamio.org/en/）</a> 库播放由 RTMP 协议传输的流媒体。<br>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="视频" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解RxJava(4)-在Android中使用响应式编程]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-4/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-4/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:45:25.000Z</updated>
    <content type="html"><![CDATA[<p>在第1，2，3篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在Android中使用RxJava.<br><a id="more"></a></p>
<h2 id="RxAndroid">RxAndroid</h2><p>RxAndroid是RxJava的一个针对Android平台的扩展。它包含了一些能够简化Android开发的工具。</p>
<p>首先，AndroidSchedulers提供了针对Android的线程系统的调度器。需要在UI线程中运行某些代码？很简单，只需要使用AndroidSchedulers.mainThread():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retrofitService.getImage(url)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));</span><br></pre></td></tr></table></figure>
<p>如果你已经创建了自己的Handler，你可以使用HandlerThreadScheduler1将一个调度器链接到你的handler上。</p>
<p>接着要介绍的就是AndroidObservable，它提供了跟多的功能来配合Android的生命周期。bindActivity()和bindFragment()方法默认使用AndroidSchedulers.mainThread()来执行观察者代码，这两个方法会在Activity或者Fragment结束的时候通知被观察者停止发出新的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AndroidObservable.bindActivity(<span class="keyword">this</span>, retrofitService.getImage(url))</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure>
<p>我自己也很喜欢AndroidObservable.fromBroadcast()方法，它允许你创建一个类似BroadcastReceiver的Observable对象。下面的例子展示了如何在网络变化的时候被通知到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">AndroidObservable.fromBroadcast(context, filter)</span><br><span class="line">    .subscribe(intent -&gt; handleConnectivityChange(intent));</span><br></pre></td></tr></table></figure>
<p>最后要介绍的是ViewObservable,使用它可以给View添加了一些绑定。如果你想在每次点击view的时候都收到一个事件，可以使用ViewObservable.clicks()，或者你想监听TextView的内容变化，可以使用ViewObservable.text()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewObservable.clicks(mCardNameEditText, <span class="keyword">false</span>)</span><br><span class="line">    .subscribe(view -&gt; handleClick(view));</span><br></pre></td></tr></table></figure>
<h2 id="Retrofit">Retrofit</h2><p>大名鼎鼎的Retrofit库内置了对RxJava的支持。通常调用发可以通过使用一个Callback对象来获取异步的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getUserPhoto</span><span class="params">(@Path(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id, Callback cb)</span>;</span><br></pre></td></tr></table></figure>
<p>使用RxJava，你可以直接返回一个Observable对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line"><span class="function">Observable <span class="title">getUserPhoto</span><span class="params">(@Path(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>现在你可以随意使用Observable对象了。你不仅可以获取数据，还可以进行变换。<br> Retrofit对Observable的支持使得它可以很简单的将多个REST请求结合起来。比如我们有一个请求是获取照片的，还有一个请求是获取元数据的，我们就可以将这两个请求并发的发出，并且等待两个结果都返回之后再做处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.zip(</span><br><span class="line">    service.getUserPhoto(id),</span><br><span class="line">    service.getPhotoMetadata(id),</span><br><span class="line">    (photo, metadata) -&gt; createPhotoWithData(photo, metadata))</span><br><span class="line">    .subscribe(photoWithData -&gt; showPhoto(photoWithData));</span><br></pre></td></tr></table></figure>
<p>在第二篇里我展示过一个类似的例子（使用flatMap()）。这里我只是想展示以下使用RxJava+Retrofit可以多么简单地组合多个REST请求。</p>
<h2 id="遗留代码，运行极慢的代码">遗留代码，运行极慢的代码</h2><p>Retrofit可以返回Observable对象，但是如果你使用的别的库并不支持这样怎么办？或者说一个内部的内码，你想把他们转换成Observable的？有什么简单的办法没？</p>
<p>绝大多数时候Observable.just() 和 Observable.from() 能够帮助你从遗留代码中创建 Observable 对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">oldMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable <span class="title">newMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.just(oldMethod());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中如果oldMethod()足够快是没有什么问题的，但是如果很慢呢？调用oldMethod()将会阻塞住他所在的线程。<br> 为了解决这个问题，可以参考我一直使用的方法–使用defer()来包装缓慢的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">slowBlockingMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable <span class="title">newMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(() -&gt; Observable.just(slowBlockingMethod()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，newMethod()的调用不会阻塞了，除非你订阅返回的observable对象。</p>
<h2 id="生命周期">生命周期</h2><p>我把最难的不分留在了最后。如何处理Activity的生命周期？主要就是两个问题：<br> 1.在configuration改变（比如转屏）之后继续之前的Subscription。</p>
<p>比如你使用Retrofit发出了一个REST请求，接着想在listview中展示结果。如果在网络请求的时候用户旋转了屏幕怎么办？你当然想继续刚才的请求，但是怎么搞？</p>
<p>2.Observable持有Context导致的内存泄露</p>
<p>这个问题是因为创建subscription的时候，以某种方式持有了context的引用，尤其是当你和view交互的时候，这太容易发生！如果Observable没有及时结束，内存占用就会越来越大。<br> 不幸的是，没有银弹来解决这两个问题，但是这里有一些指导方案你可以参考。</p>
<p>第一个问题的解决方案就是使用RxJava内置的缓存机制，这样你就可以对同一个Observable对象执行unsubscribe/resubscribe，却不用重复运行得到Observable的代码。cache() (或者 replay())会继续执行网络请求（甚至你调用了unsubscribe也不会停止）。这就是说你可以在Activity重新创建的时候从cache()的返回值中创建一个新的Observable对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable request = service.getUserPhoto(id).cache();</span><br><span class="line">Subscription sub = request.subscribe(photo -&gt; handleUserPhoto(photo));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...When the Activity is being recreated...</span></span><br><span class="line">sub.unsubscribe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...Once the Activity is recreated...</span></span><br><span class="line">request.subscribe(photo -&gt; handleUserPhoto(photo));</span><br></pre></td></tr></table></figure>
<p>注意，两次sub是使用的同一个缓存的请求。当然在哪里去存储请求的结果还是要你自己来做，和所有其他的生命周期相关的解决方案一延虎，必须在生命周期外的某个地方存储。（retained fragment或者单例等等）。</p>
<p>第二个问题的解决方案就是在生命周期的某个时刻取消订阅。一个很常见的模式就是使用CompositeSubscription来持有所有的Subscriptions，然后在onDestroy()或者onDestroyView()里取消所有的订阅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompositeSubscription mCompositeSubscription</span><br><span class="line">    = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCompositeSubscription.add(</span><br><span class="line">        AndroidObservable.bindActivity(<span class="keyword">this</span>, Observable.just(<span class="string">"Hello, World!"</span>))</span><br><span class="line">        .subscribe(s -&gt; System.out.println(s)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    mCompositeSubscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在Activity/Fragment的基类里创建一个CompositeSubscription对象，在子类中使用它。</p>
<p>注意! 一旦你调用了 CompositeSubscription.unsubscribe()，这个CompositeSubscription对象就不可用了, 如果你还想使用CompositeSubscription，就必须在创建一个新的对象了。</p>
<p>两个问题的解决方案都需要添加额外的代码，如果谁有更好的方案，欢迎告诉我。</p>
<h2 id="总结">总结</h2><p>RxJava还是一个很新的项目，RxAndroid更是。RxAndroid目前还在活跃开发中，也没有多少好的例子。我打赌一年之后我的一些建议就会被看做过时了。<br> 原文链接:<a href="http://blog.danlew.net/2014/10/08/grokking-rxjava-part-4/" target="_blank" rel="external">深入浅出RxJava四-在Android中使用响应式编程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在第1，2，3篇中，我大概介绍了RxJava是怎么使用的。下面我会介绍如何在Android中使用RxJava.<br>]]>
    
    </summary>
    
      <category term="RxJava/RxAndroid" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/"/>
    
      <category term="Reactive Extension(RX)" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Reactive-Extension-RX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解RxJava(3)-响应式的好处]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-3/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/17/grokking-rxjava-part-3/</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2015-07-11T08:45:50.000Z</updated>
    <content type="html"><![CDATA[<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.<br><a id="more"></a></p>
<h2 id="错误处理">错误处理</h2><p>到目前为止，我们都没怎么介绍onComplete()和onError()函数。这两个函数用来通知订阅者，被观察的对象将停止发送数据以及为什么停止（成功的完成或者出错了）。</p>
<p>下面的代码展示了怎么使用这两个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .map(s -&gt; potentialException(s))</span><br><span class="line">    .map(s -&gt; anotherPotentialException(s))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Completed!"</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; System.out.println(<span class="string">"Ouch!"</span>); &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>代码中的potentialException() 和 anotherPotentialException()有可能会抛出异常。每一个Observerable对象在终结的时候都会调用onCompleted()或者onError()方法，所以Demo中会打印”Completed!”或者”Ouch!”。</p>
<p>这种模式有以下几个优点：</p>
<p>1.只要有异常发生onError()一定会被调用</p>
<p>这极大的简化了错误处理。只需要在一个地方处理错误即可以。</p>
<p>2.操作符不需要处理异常</p>
<p>将异常处理交给订阅者来做，Observerable的操作符调用链中一旦有一个抛出了异常，就会直接执行onError()方法。</p>
<p>3.你能够知道什么时候订阅者已经接收了全部的数据。</p>
<p>知道什么时候任务结束能够帮助简化代码的流程。（虽然有可能Observable对象永远不会结束）</p>
<p>我觉得这种错误处理方式比传统的错误处理更简单。传统的错误处理中，通常是在每个回调中处理错误。这不仅导致了重复的代码，并且意味着每个回调都必须知道如何处理错误，你的回调代码将和调用者紧耦合在一起。</p>
<p>使用RxJava，Observable对象根本不需要知道如何处理错误！操作符也不需要处理错误状态-一旦发生错误，就会跳过当前和后续的操作符。所有的错误处理都交给订阅者来做。</p>
<h2 id="调度器">调度器</h2><p>假设你编写的Android app需要从网络请求数据（感觉这是必备的了，还有单机么？）。网络请求需要话费较长的时间，因此你打算在另外一个线程中加载数据。为问题来了！</p>
<p>编写多线程的Android应用程序是很难的，因为你必须确保代码在正确的线程中运行，否则的话可能会导致app崩溃。最常见的就是在非主线程更新UI。</p>
<p>使用RxJava，你可以使用subscribeOn()指定观察者代码运行的线程，使用observerOn()指定订阅者运行的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myObservableServices.retrieveImage(url)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(bitmap -&gt; myImageView.setImageBitmap(bitmap));</span><br></pre></td></tr></table></figure>
<p>是不是很简单？任何在我的Subscriber前面执行的代码都是在I/O线程中运行。最后，操作view的代码在主线程中运行.</p>
<p>最棒的是我可以把subscribeOn()和observerOn()添加到任何Observable对象上。这两个也是操作符！。我不需要关心Observable对象以及它上面有哪些操作符。仅仅运用这两个操作符就可以实现在不同的线程中调度。</p>
<p>如果使用AsyncTask或者其他类似的，我将不得不仔细设计我的代码，找出需要并发执行的部分。使用RxJava，我可以保持代码不变，仅仅在需要并发的时候调用这两个操作符就可以。</p>
<h2 id="订阅（Subscriptions）">订阅（Subscriptions）</h2><p>当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubscription subscription = Observable.just(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subscription.unsubscribe();</span><br><span class="line">System.out.println(<span class="string">"Unsubscribed="</span> + subscription.isUnsubscribed());</span><br><span class="line"><span class="comment">// Outputs "Unsubscribed=true"</span></span><br></pre></td></tr></table></figure>
<p>RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！</p>
<h2 id="总结">总结</h2><p>记住这个系列仅仅是对RxJava的一个入门介绍。RxJava中有更多的我没介绍的功能等你探索（比如backpressure）。当然我也不是所有的代码都使用响应式的方式–仅仅当代码复杂到我想将它分解成简单的逻辑的时候，我才使用响应式代码。</p>
<p>最初，我的计划是这篇文章作为这个系列的总结，但是我收到许多请求我介绍在Android中使用RxJava，所以你可以继续阅读第四篇了。我希望这个介绍能让你开始使用RxJava。如果你想学到更多，我建议你阅读RxJava的官方wiki。<br> 原文链接:<a href="http://blog.danlew.net/2014/09/30/grokking-rxjava-part-3/" target="_blank" rel="external">深入浅出RxJava三–响应式的好处</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在第一篇中，我介绍了RxJava的基础知识。第二篇中，我向你展示了操作符的强大。但是你可能仍然没被说服。这篇里面，我讲向你展示RxJava的其他的一些好处，相信这篇足够让你去使用Rxjava.<br>]]>
    
    </summary>
    
      <category term="RxJava/RxAndroid" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/RxJava-RxAndroid/"/>
    
      <category term="Reactive Extension(RX)" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/Reactive-Extension-RX/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Studio-1.2版本设置教程]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/10/android-studio-settings/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/10/android-studio-settings/</id>
    <published>2015-05-09T16:00:00.000Z</published>
    <updated>2015-07-11T08:41:11.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>转载请注明原文出处 <a href="http://licheetec.com/2015/05/02/android-studio-settings/" target="_blank" rel="external">http://licheetec.com/2015/05/02/android-studio-settings/</a></p>
</blockquote>
<p>这两天Google更新了Android Studio 1.2正式版，新版本的设置界面大变面，设置条目较旧版本进行了归类，不像以前那样列表长长的了。</p>
<p>趁着安装新版本的机会，把常用的设置记录一下，放到博客里面，以作备忘。<br><a id="more"></a></p>
<h1 id="Android_Studio_/_Gradle学习资源">Android Studio / Gradle学习资源</h1><p>在说设置之前，先上点学习Android Studio和Gradle的学习资源。</p>
<h2 id="官方教程">官方教程</h2><ul>
<li><p>developer.android.com上的<strong>Android Studio Overview</strong><br><a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="external">http://developer.android.com/tools/studio/index.html</a>  </p>
</li>
<li><p>developer.android.com上的<strong>Build System Overview</strong><br><a href="http://developer.android.com/sdk/installing/studio-build.html" target="_blank" rel="external">http://developer.android.com/sdk/installing/studio-build.html</a>  </p>
</li>
<li><p>tools.android.com上的<strong>Gradle Plugin User Guide*</strong>（Google出的Gradle指南）<br><a href="http://tools.android.com/tech-docs/new-build-system/user-guide" target="_blank" rel="external">http://tools.android.com/tech-docs/new-build-system/user-guide</a>  </p>
</li>
<li><p>IntelliJ IDEA <strong>Quick Start</strong>（IDEA入门教程）<br><a href="https://www.jetbrains.com/idea/help/intellij-idea-quick-start-guide.html" target="_blank" rel="external">https://www.jetbrains.com/idea/help/intellij-idea-quick-start-guide.html</a>  </p>
</li>
<li><p>IntelliJ IDEA的快捷键大全<br><a href="https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf" target="_blank" rel="external">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard_Mac.pdf</a></p>
</li>
</ul>
<h2 id="非官方资源">非官方资源</h2><ul>
<li><p><strong>Developer Phil博客</strong>的<strong>Android Studio Tips系列</strong>（里面提供快捷键效果的动态图，<strong>强烈推荐</strong>）<br><a href="http://www.developerphil.com/android-studio-tips-tricks-moving-around/#recent-posts-4" target="_blank" rel="external">http://www.developerphil.com/android-studio-tips-tricks-moving-around/#recent-posts-4</a>  </p>
</li>
<li><p>Android-Studio-Tips-by-Philippe-Breault（貌似就是上面那个，还没细看，暂时不确定是不是一样，还是发出来好了）<br><a href="https://github.com/pavlospt/Android-Studio-Tips-by-Philippe-Breault/wiki" target="_blank" rel="external">https://github.com/pavlospt/Android-Studio-Tips-by-Philippe-Breault/wiki</a>  </p>
</li>
<li><p><strong>stormzhang</strong>大神的<strong>Android Studio系列教程</strong>（推荐）<br><a href="http://stormzhang.com/posts.html#AndroidStudio" target="_blank" rel="external">http://stormzhang.com/posts.html#AndroidStudio</a>  </p>
</li>
<li><p><strong>Rinvay Tang</strong>的博客<br>（《Gradle Plugin User Guide》翻译版，《使用Gradle构建Android程序》）（推荐）<br><a href="http://rinvay.github.io/archive.html" target="_blank" rel="external">http://rinvay.github.io/archive.html</a>  </p>
</li>
<li><p><strong>Gradle Android插件用户指南翻译</strong>（《Gradle Plugin User Guide》另一个翻译版）<br><a href="http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/" target="_blank" rel="external">http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/</a>  </p>
</li>
<li><p>Github上面搜“Android Studio”（很多好东西都在里面）<br><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=Android+Studio" target="_blank" rel="external">https://github.com/search?utf8=%E2%9C%93&amp;q=Android+Studio</a></p>
</li>
</ul>
<h1 id="环境搭建相关">环境搭建相关</h1><h2 id="下载">下载</h2><p>正式版的Android Studio和SDK可以在下面的链接进行下载<br><a href="http://developer.android.com/sdk/index.html#Other" target="_blank" rel="external">http://developer.android.com/sdk/index.html#Other</a><br>关于下载，我建议下载绿色版的Android Studio和SDK，别下安装包版捆绑版的，这样如果有哪个出了问题要重装，只要动一个就行了。</p>
<p><img src="http://i4.tietuku.com/d1cdaa3469459a3f.jpg" alt="下载"><br>其他版本可以在这里找到 <a href="http://tools.android.com/download/studio/canary" target="_blank" rel="external">http://tools.android.com/download/studio/canary</a></p>
<h2 id="禁用Windows中Ctrl+Space切换输入法的快捷键">禁用Windows中<code>Ctrl+Space</code>切换输入法的快捷键</h2><p>Windows的Ctrl+Space快捷键（切换中文输入法）跟一堆IDE的冲突，所以必须禁用掉，按照下图那样修改注册表即可。<br>或者下载我改好的注册表文件（<a href="https://github.com/licheetec/filestore/raw/master/others/disable_ctrl_space.zip" target="_blank" rel="external">右键另存为</a>），双击导入压缩包里面的文件，重启系统即可。</p>
<p><img src="http://i4.tietuku.com/4824ab2a935b548c.jpg" alt="禁用Windows+Space快捷键"><br>原理参考<a href="http://answers.microsoft.com/en-us/windows/forum/windows_vista-desktop/how-do-i-disable-the-changing-of-languages-when-i/f01de525-73b2-4c4e-969e-b5aa001c0eb7" target="_blank" rel="external">这里</a>。</p>
<h2 id="环境变量">环境变量</h2><p>很多IDE依赖环境变量，正确设置好环境变量，可以确保软件能正常运行，和避免很多莫名奇妙的问题。</p>
<blockquote>
<p>设置环境变量的方法请自行搜索。下面的环境变量值都是我自己电脑的，请按照<code>实际情况</code>进行修改。<br>还有<code>PATH</code>的要特别注意，要加到原来的后面，别一脑门全部覆盖掉。</p>
</blockquote>
<h3 id="JAVA">JAVA</h3><pre><code>JAVA_HOME=E:\DevTools\Others\Java\jdk1.7.0_67
CLASSPATH=.;<span class="variable">%JAVA_HOME</span><span class="variable">%\</span>lib;<span class="variable">%JAVA_HOME</span><span class="variable">%\</span>lib\tools.jar
# 注意，<span class="variable">%PATH</span><span class="variable">%为</span>原来的环境变量值，添加<span class="string">";"</span>和后面的内容到原来值的后面
PATH=<span class="variable">%PATH</span><span class="variable">%;</span><span class="variable">%JAVA_HOME</span><span class="variable">%\</span>bin;<span class="variable">%JAVA_HOME</span><span class="variable">%\</span>jre\bin
</code></pre><h3 id="Android_SDK">Android SDK</h3><pre><code>ANDROID_HOME=E:\DevTools\Android\sdk
PATH=<span class="variable">%PATH</span><span class="variable">%;</span><span class="variable">%ANDROID_HOME</span><span class="variable">%\</span>tools;<span class="variable">%ANDROID_HOME</span><span class="variable">%\</span>platform-tools
# ADB端口，可以避免国内一堆软件，如酷狗音乐啥的把ADB端口抢占了，值随便改个不常用的就行
ANDROID_ADB_SERVER_PORT=<span class="number">7123</span>
</code></pre><h3 id="Gradle">Gradle</h3><pre><code><span class="special">#</span> Android Studio正式版后就内置了一个Gradle，当然你也可以另外去Gradle官网下载一个
GRADLE_HOME=E:<span class="command">\DevTools</span><span class="command">\Android</span><span class="command">\android</span>-studio<span class="command">\gradle</span><span class="command">\gradle</span>-2.2.1<span class="command">\bin</span>
PATH=<span class="comment">%PATH%;%GRADLE_HOME%\bin</span>
<span class="special">#</span> 依赖仓库存放路径，平时构建工程时下载的依赖库都放在这里
<span class="special">#</span> 不配置的话，Windows中默认是在C:<span class="command">\Users</span><span class="command">\&lt;</span>username&gt;<span class="command">\.</span>gradle的
<span class="special">#</span> 重装系统时忘记备份，又不想重新下载依赖的话，就赶紧把这里改了
GRADLE_USER_HOME=E:<span class="command">\DevWorks</span><span class="command">\.</span>gradle
</code></pre><h2 id="运行Android_Studio前的配置">运行Android Studio前的配置</h2><h3 id="配置SDK_Manager科学上网，升级SDK">配置SDK Manager科学上网，升级SDK</h3><p>最近红杏出了公益代理，简直是开发人员的福音，详情看：<a href="http://blog.honx.in/dev-only/" target="_blank" rel="external">http://blog.honx.in/dev-only/</a><br>按照红杏提供地址和端口（目前是<code>hx.gy:1080</code>）进行修改（别加<code>http://</code>），必要时可以按一下“Clear Cache”。</p>
<blockquote>
<p>有条件的话，可以试试买个付费的shadowsocks，我现在shadowsocks.com的99包年套餐。<br>电信8M，部分线路能达到900多KB/s的速度，几乎满速了，感觉还行。<br>具体怎么购买和配置，不在本文介绍范围内，请自行找科普。<br>如果要买的话，请务必用 <a href="https://portal.shadowsocks.com/aff.php?aff=470" target="_blank" rel="external"><code>我的推广链接</code></a> ，我有提成的。（笑）</p>
</blockquote>
<p><img src="http://i1.tietuku.com/655456e2121590d9.jpg" alt="SDK Manager配置"></p>
<p>关于下载，<code>Tools</code>中<code>Android SDK Build-tools</code>建议<code>全部下载</code>，<br>其他各个API版本，建议至少下载<code>SDK Platform</code>（必须，framework层的东东全在这里）和<code>Sources for Android SDK</code>（源码），<br><code>Extras</code>中<strong><em>必须</em></strong>下载<code>Android Support Repository</code>和<code>Android Support Library</code>（Support库的东东，现在开发离不开Support库了），<br>上面提到的是开发必须用到的，其他东西就看情况了，你有时间又不在乎资源占用的话，全下载都行。<br>顺便附上我自己下载的，<a href="http://i1.tietuku.com/53c9ca6eee9d8ab6.jpg" target="_blank" rel="external">猛戳此连接查看</a>。</p>
<h3 id="修改idea-properties文件">修改idea.properties文件</h3><p>找到<code>&lt;android-studio&gt;\bin\idea.properties</code>文件，打开，改成这样：</p>
<p><img src="http://i4.tietuku.com/6e2599351ee2b032.jpg" alt="idea.properties"></p>
<pre><code><span class="comment"># 禁止第一次运行Android Studio时，自动检查和升级Android SDK</span>
disable.android.first.run=<span class="keyword">true</span>

<span class="comment"># 下面两个是Android Studio的设置、插件和运行时产生的其他文件存放的目录</span>
<span class="comment"># 不改的话，Windows中默认在 C:\Users\&lt;username&gt;\.AndroidStudio.2\ 里面</span>
<span class="comment"># ${idea.home.path}表示Android Studio程序的主目录，注意目录分隔符要用正斜杠“/”</span>
idea.config.<span class="built_in">path</span>=$<span class="keyword">{</span>idea.<span class="literal">home</span>.<span class="built_in">path</span><span class="keyword">}</span>/.<span class="constant">Android</span>Studio.<span class="number">2</span>/config
idea.<span class="literal">system</span>.<span class="built_in">path</span>=$<span class="keyword">{</span>idea.<span class="literal">home</span>.<span class="built_in">path</span><span class="keyword">}</span>/.<span class="constant">Android</span>Studio.<span class="number">2</span>/<span class="literal">system</span>
</code></pre><blockquote>
<p>非常坑爹的是，每次Android Studio升级时，都会强制检测AS主目录里面的文件或文件夹是否被动过，<br>当然也包含这个idea.properties，<br>有些增强模板或插件，例如这个 <a href="https://github.com/gabrielemariotti/AndroidStudioTemplate" target="_blank" rel="external">AndroidStudioTemplate</a>，安装时要求覆盖<code>&lt;android-studio&gt;\plugins\android\lib\templates</code>。<br>如果发现被改了，就会要求进行<del>处理</del>（恢复默认）操作，举例来说，idea.properties和那个templates会被还原为解压时的模样，各种修改都会失效。<br>所以保险起见，这个<code>idea.properties</code>文件改完就备份一下，以后升级完AS，就手动改回去，各种插件/模板也存一个备份，别装完就删掉，免得被AS的升级程序删了后找不回来。</p>
</blockquote>
<h1 id="设置Android_Studio">设置Android Studio</h1><p>正题来了，运行后，进入欢迎界面，别急着建工程，先<code>Configure</code>→<code>Settings</code>去修改设置。</p>
<h2 id="IDE外观&amp;行为">IDE外观&amp;行为</h2><h3 id="修改主题，修改全局字体">修改主题，修改全局字体</h3><p><img src="http://i4.tietuku.com/a7467ac2bd7067bf.jpg" alt="主题&amp;字体"></p>
<ol>
<li><p>修改主题，想用炫酷的深色主题，就改成<code>Darcula</code>吧；<br>字体的话，选一个带中文的，要不然会有很多<code>口口</code>，我这里用<code>Microsoft YaHei UI</code>，很不错。  </p>
</li>
<li><p>启用/禁用动画特效，禁用掉感觉可能会快点。</p>
</li>
</ol>
<h3 id="禁止自动打开上次的工程">禁止自动打开上次的工程</h3><p>我喜欢自己选打开哪个工程，果断禁用</p>
<p><img src="http://i4.tietuku.com/ea4fb529175d61fc.jpg" alt="禁止自动打开最后打开的工程"></p>
<h3 id="设置网络代理">设置网络代理</h3><p>跟上文一样，改为红杏公益代理吧</p>
<p><img src="http://i4.tietuku.com/699907660e9f6148.jpg" alt="代理"></p>
<h3 id="禁用自动检查更新">禁用自动检查更新</h3><p>洁癖的选择，升级控请无视</p>
<p><img src="http://i4.tietuku.com/44821b256312b44c.jpg" alt="禁用更新"></p>
<h3 id="配置快捷键">配置快捷键</h3><p>不管你改不改，反正我没改，默认的好，免得以后查资料，操作对不上</p>
<p><img src="http://i4.tietuku.com/a1e17305d06190a3.jpg" alt="快捷键"></p>
<h2 id="编辑器">编辑器</h2><h3 id="鼠标悬停显示文档，格式化&amp;导包提示">鼠标悬停显示文档，格式化&amp;导包提示</h3><p><img src="http://i4.tietuku.com/9fd64f9122214d96.jpg" alt="鼠标悬停显示文档，格式化&amp;导包提示"></p>
<ol>
<li><p>鼠标指针悬停若干时间，显示文档，时间自己改。  </p>
</li>
<li><p>就是按格式化代码或者导包时，是否会显示个对话框，觉得烦人的话，都取消掉吧，反正我取消了。</p>
</li>
</ol>
<h3 id="显示行号，显示方法分隔线">显示行号，显示方法分隔线</h3><p>勾上吧，你值得拥有的</p>
<p><img src="http://i4.tietuku.com/7022f5b4a39a5dbe.jpg" alt="显示行号，显示方法分隔线"></p>
<h3 id="代码折叠">代码折叠</h3><p>Intellij IDEA有很多地方的代码都能自动折叠，不过我看不惯，所以取消了，这里见仁见智，看着办<br>P.S. <code>Ctrl + .</code> 可以折叠和展开代码</p>
<p><img src="http://i4.tietuku.com/e156cf6e6bb500d3.jpg" alt="代码折叠"></p>
<h3 id="代码智能提示">代码智能提示</h3><p><img src="http://i4.tietuku.com/afcfe37b9d6ebba5.jpg" alt="代码智能提示"></p>
<ol>
<li><p>敲什么字符会提示，All(大小写全部符合)，None（不管大小写，符合就提示），（First letter）（第一个字符符合就OK，其他随意）。我这种脑残没记性的当然选择None。  </p>
</li>
<li><p>自动弹出文档，时间看着办。  </p>
</li>
<li><p>自动弹出方法参数提示，时间看着办。</p>
</li>
</ol>
<h3 id="自动导包">自动导包</h3><p><img src="http://i4.tietuku.com/a1bb4e23dde8936a.jpg" alt="自动导包"></p>
<ul>
<li><p>Optimize imports on the fly：优化导包，格式化代码时会删掉多余的导包。  </p>
</li>
<li><p>Add unambiguous imports on the fly：敲代码时，敲简单类名就帮你把包导了。</p>
</li>
</ul>
<h3 id="创建个人代码样式配置">创建个人代码样式配置</h3><p>估计是为了保护默认的代码样式配置，让用户把配置搞坏了也能一键还原，IDEA不允许修改默认的配置，需要用户创建配置才能进行修改。<br>选择基于哪个主题的，然后<code>Save As</code>一份即可。</p>
<p><img src="http://i4.tietuku.com/2b866c9c4021e70a.jpg" alt="创建个人代码样式配置"></p>
<h3 id="修改代码字体">修改代码字体</h3><p>强烈建议用<code>Consolas</code>字体，好看！！！</p>
<p><img src="http://i4.tietuku.com/7e949854b0c76c50.jpg" alt="修改代码字体"></p>
<h3 id="修改控制台字体">修改控制台字体</h3><p>好吧，我就喜欢这个字体不行么？</p>
<p><img src="http://i4.tietuku.com/4188c779b2651289.jpg" alt="修改控制台字体"></p>
<h3 id="Logcat字体">Logcat字体</h3><p>要改的话，得先把1那个地方的勾取消掉</p>
<p><img src="http://i4.tietuku.com/a1d8f83d58306671.jpg" alt="Logcat字体"></p>
<h3 id="修改注释位置，禁用“语句堆一行”">修改注释位置，禁用“语句堆一行”</h3><p><img src="http://i4.tietuku.com/bfdcc07101de949c.jpg" alt="修改注释位置，禁用“语句堆一行”"></p>
<ul>
<li><p>Comment at frist column：启用的话，注释符号就会在行首，否则就按照缩进来注释。我取消掉了。  </p>
</li>
<li><p>Control statement in one line：格式化代码的时候，会把些很短的语句合并成一行。我觉得这样影响代码可读性，故取消。</p>
</li>
</ul>
<h3 id="修改变量前后缀">修改变量前后缀</h3><p>静态成员是s，普通成员是m，有点意思</p>
<p><img src="http://i4.tietuku.com/f623911b2a24b3ae.jpg" alt="变量前缀"></p>
<h3 id="修改新建文件文件头">修改新建文件文件头</h3><p>每次建新类的话，对下面这段注释肯定很熟悉。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"> <span class="keyword">*</span> Created by licheetec on 2015/5/2.</span><br><span class="line"> <span class="keyword">*</span>/</span><br></pre></td></tr></table></figure></p>
<p><img src="http://i4.tietuku.com/11df21d9d347afcd.jpg" alt="通用文件头"></p>
<p>上图就是通用的文件头，框住的地方是你系统的用户名，想个性化的话，可以改这里，至于哪里引用这个文件头的呢，就在隔壁。</p>
<p><img src="http://i4.tietuku.com/17155e2a606bf083.jpg" alt="引用文件头"></p>
<h3 id="修改文件编码为UTF-8">修改文件编码为UTF-8</h3><p>别坑队友，小伙伴们都统一改为UTF-8吧。</p>
<p><img src="http://i4.tietuku.com/5c6399212e1bea83.jpg" alt="修改文件编码为UTF-8"></p>
<h2 id="体验增强">体验增强</h2><h3 id="增强Live_Templates（Ctrl+J的智能提示模板）">增强Live Templates（<code>Ctrl+J</code>的智能提示模板）</h3><p>默认的Live Templates不够用，连foreach都没，幸好Github上的大神做了增强的模板，果断拿来用。</p>
<blockquote>
<p>idea-live-templates： <a href="https://github.com/keyboardsurfer/idea-live-templates" target="_blank" rel="external">https://github.com/keyboardsurfer/idea-live-templates</a></p>
</blockquote>
<p>文件下载后，找到下面这个目录：<br><code>&lt;android-studio&gt;\.AndroidStudio.2\config\templates</code>，<br>至于为什么是这个目录，麻烦往前补补 <a href="#idea-properties"><strong>修改idea.properties文件</strong></a> ,</p>
<blockquote>
<p>如果没有<code>templates</code>文件夹的话，自己手动建一个即可。</p>
</blockquote>
<p><img src="http://i4.tietuku.com/8ed6fb052db5d55e.jpg" alt="只要xml文件"></p>
<p>把所有<code>*.xml</code>文件弄进那个文件夹，重新打开Android Studio，就能看到效果了。</p>
<p><img src="http://i4.tietuku.com/3bfbf68635f3a38d.jpg" alt="修改foreach"></p>
<p><code>foreach</code>那里要改一个设置，否则<code>for ($i$ : $data$) {</code>会被自动格式化为多行。<br>下面是<code>foreach</code>和<code>fbc</code>的动图演示</p>
<p><img src="http://i4.tietuku.com/6d3e735486ae8a9d.gif" alt="foreach&amp;fbc"></p>
<h1 id="おわり">おわり</h1><p><img src="http://i4.tietuku.com/46bec46a702f7b52.gif" alt="(:з」∠)"></p>
<p>搞定，Android Studio基本设置教程暂时这样了，以后有新东西再更新，其他编译系统相关的暂时不是摸得很明白，就不乱来误人子弟了。<br>可累了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>转载请注明原文出处 <a href="http://licheetec.com/2015/05/02/android-studio-settings/">http://licheetec.com/2015/05/02/android-studio-settings/</a></p>
</blockquote>
<p>这两天Google更新了Android Studio 1.2正式版，新版本的设置界面大变面，设置条目较旧版本进行了归类，不像以前那样列表长长的了。</p>
<p>趁着安装新版本的机会，把常用的设置记录一下，放到博客里面，以作备忘。<br>]]>
    
    </summary>
    
      <category term="Android Studio" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Android-Studio/"/>
    
      <category term="AndroidIDE" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/AndroidIDE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建一个 RecyclerView LayoutManager – Part 1]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/07/building-a-recyclerview-layoutmanager-part-1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/07/building-a-recyclerview-layoutmanager-part-1/</id>
    <published>2015-05-06T16:00:00.000Z</published>
    <updated>2015-07-11T08:35:19.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文是这个系列中的 Part 1，这里是 <a href="http://wiresareobsolete.com/2014/09/recyclerview-layoutmanager-2/" target="_blank" rel="external">Part 2</a> 和 <a href="http://wiresareobsolete.com/2015/02/recyclerview-layoutmanager-3/" target="_blank" rel="external">Part 3</a> 的链接。<br><a id="more"></a><br>现如今，如果你是 Android 开发者，你肯定听说过 RecyclerView 这个控件；<br>它是一个即将加入 support library 之中的新组件，<br>通过方便的视图复用轻松实现自定义高效的视图集。<br>已经有很多优秀的文章介绍了 RecyclerView 基础，讲解如何使用<br>RecyclerView 提供的内建部分，包括 item animations。所以，<br>我们就不再重复前人的工作了，下面是一些帮你入门的资料：</p>
</blockquote>
<ul>
<li><a href="http://www.grokkingandroid.com/first-glance-androids-recyclerview/" target="_blank" rel="external">A First Glance at Android’s RecyclerView</a></li>
<li><a href="http://lucasr.org/2014/07/31/the-new-twowayview/" target="_blank" rel="external">The new TwoWayView</a></li>
<li><a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators" target="_blank" rel="external">RecyclerViewItemAnimators</a></li>
</ul>
<p>我们的这个系列文章会关注 RecyclerView 底层细节，涉及到创建你自己的<br>LayoutManager，做些比单一的 垂直/水平 滚动列表稍稍复杂的东西。</p>
<blockquote>
<p>在我们开始前，你需要知道  LayoutManager API  之所以能够让我们实现<br>强大复杂的布局是因为它只替你做了很少的工作；这就意味着<br>你不得不自己完成数量可观的代码。如果要在一个项目中使用自定义视图，<br>不要陷入过度优化或过度泛化代码之中。你只需要关心<br>在你的用例中需要实现的特性就可以了。</p>
</blockquote>
<h1 id="RecyclerView_Playground">RecyclerView Playground</h1><p>这个系列中所有的代码段都取自 <a href="https://github.com/devunwired/recyclerview-playground" target="_blank" rel="external">RecyclerView Playground sample</a> 这个项目，<br>示例应用里包含了各个方面使用 RecyclerView 的实例，从创建简单的 list<br>到自定义 LayoutManagers。</p>
<p>本文的代码来自 <code>FixedGridLayoutManager</code> ，一个可以垂直和水平<br>滚动的二维的网格布局。</p>
<blockquote>
<p>support library 里也有一个自定义的 LayoutManager；本质上<br>是一个自定义 vertical linear list  的实现：<br>[SDK_PATH]/extras/android/compatibility/samples/Support7Demos/src/com/example/android/supportv7/widget/RecyclerViewActivity.java</p>
<p>同时，Android L 和 新的 support libraries 可能还没加入 AOSP<br>之中，不过 RecyclerView 提供了 <strong>JAR</strong> 资源，可以在这里找到：<br>[SDK_PATH]/extras/android/m2repository/com/android/support/recyclerview-v7/21.0.0-rc1/recyclerview-v7-21.0.0-rc1-sources.jar</p>
</blockquote>
<h1 id="The_Recycler">The Recycler</h1><p>首先，了解下 API 的结构。当你需要从一个可能再生的前子视图中<br>回收旧的 view 或者 获取新的 view 时，<br>你的 LayoutManager 可以访问一个 <code>Recycler</code> 实例。</p>
<p>Recycler 也免掉了直接访问 view 当前适配器方法的麻烦。当你的<br>LayoutManager 需要一个新的子视图时，只要调用 <code>getViewForPosition()</code><br>这个方法，Recycler 会决定到底是从头创建一个新的视图<br>还是重用一个已存在的废弃视图。<br>你的 LayoutManager 需要及时将不再显示的视图传递给 Recycler，<br>避免 Recycler 创建不必要的 view 对象。</p>
<h2 id="Detach_vs-_Remove">Detach vs. Remove</h2><p>布局更新时有两个方法处理已存在的子视图：detach 和<br>remove (分离和移除)。Detach 是一个轻量的记录 view 操作。<br>被 detach 的视图在你的代码返回前能够重新连接。可以通过 Recycler<br>在不 重新绑定/重新构建 子视图的情况下修改已连接子视图的索引。</p>
<p>Remove 意味着这个 view 已经不需要了。任何被永久移除的 view 都应该<br>放到 Recycler 中，方便以后重用，不过 API 并没有强制要求。<br>被 remove 的视图是否被回收取决于你。</p>
<h2 id="Scrap_vs-_Recycle">Scrap vs. Recycle</h2><p>Recycler 有两级视图缓存系统： scrap heap 和 recycle pool (垃圾堆和回收池)，<br>Scrap heap 是一个轻量的集合，视图可以不经过适配器直接返回给<br>LayoutManager 。通常被 detach<br>但会在同一布局重新使用的视图会临时储存在这里。Recycle pool 存放的<br>是那些假定并没有得到正确数据(相应位置的数据)的视图，<br>因此它们都要经过适配器重新绑定后才能返回给 LayoutManager。</p>
<p>当要给 LayoutManager 提供一个新 view 时，Recycler 首先会<br>检查 scrap heap 有没有对应的 position/id；如果有对应的内容，<br>就直接返回数据不需要通过适配器重新绑定。如果没有的话，<br>Recycler 就会从 recycle pool 里弄一个合适的视图出来，<br>然后用 adapter 给它绑定必要的数据<br>(就是调用 <code>RecyclerView.Adapter.bindViewHolder()</code>) 再返回。<br>如果 recycle pool 中也不存在有效 view ，就会在绑定数据前<br>创建新的 view (就是 <code>RecyclerView.Adapter.createViewHolder()</code>)，<br>最后返回数据。</p>
<h2 id="经验法则">经验法则</h2><p>只要你原意，LayoutManager 的 API 允许你独立完成所有这些任务，<br>所以可能的组合有点多。通常来说，<br>如果你想要临时整理并且希望稍后在同一布局中重新使用某个 view 的话，<br> 可以对它调用 <code>detachAndScrapView()</code> 。如果基于当前布局<br> 你不再需要某个 view 的话，对其调用 <code>removeAndRecycleView()</code>。</p>
<h1 id="Building_The_Core">Building The Core</h1><p>LayoutManager 需要实时添加，测量和布局所有它需要的子视图。<br>当用户滚动屏幕时，布局管理器将来决定什么时候添加新的子视图，<br>什么时候可以 detache/scrap (分离/废弃)视图。</p>
<p>你需要实现下面这些方法创建一个可行的 LayoutManager 最小系统。</p>
<h4 id="generateDefaultLayoutParams()">generateDefaultLayoutParams()</h4><p>事实上你只要重写这个方法你的 LayoutManager 就能编译通过了。<br>实现也很简单，返回一个你想要默认应用给所有从<br>Recycler 中获得的子视图做参数的 <code>RecyclerView.LayoutParams</code> 实例。<br>这些参数会在对应的 <code>getViewForPosition()</code> 返回前赋值给相应的子视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.LayoutParams(</span><br><span class="line">        RecyclerView.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        RecyclerView.LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="onLayoutChildren()">onLayoutChildren()</h4><p><code>onLayoutChildren()</code> 是 LayoutManager 的主入口。<br>它会在 view 需要初始化布局时调用，<br>当适配器的数据改变时(或者整个适配器被换掉时)会再次调用。<br><strong>注意！这个方法不是在每次你对布局作出改变时调用的。</strong><br>它是 初始化布局 或者 在数据改变时重置子视图布局的好位置。</p>
<p>在接下来的部分，我们会分析在适配器更新时<br>是怎样使用它基于当前可见元素刷新布局的。<br>现在，我们将简单地解决这个问题当做子视图布局第一关。<br>下面是 <code>FixedGridLayoutManager</code> 示例的精简版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Scrap measure one child</span></span><br><span class="line">    View scrap = recycler.getViewForPosition(<span class="number">0</span>);</span><br><span class="line">    addView(scrap);</span><br><span class="line">    measureChildWithMargins(scrap, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * We make some assumptions in this code based on every child</span><br><span class="line">     * view being the same size (i.e. a uniform grid). This allows</span><br><span class="line">     * us to compute the following values up front because they</span><br><span class="line">     * won't change.</span><br><span class="line">     */</span></span><br><span class="line">    mDecoratedChildWidth = getDecoratedMeasuredWidth(scrap);</span><br><span class="line">    mDecoratedChildHeight = getDecoratedMeasuredHeight(scrap);</span><br><span class="line">    detachAndScrapView(scrap, recycler);</span><br><span class="line">    </span><br><span class="line">    updateWindowSizing();</span><br><span class="line">    <span class="keyword">int</span> childLeft;</span><br><span class="line">    <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Reset the visible and scroll positions</span><br><span class="line">     */</span></span><br><span class="line">    mFirstVisiblePosition = <span class="number">0</span>;</span><br><span class="line">    childLeft = childTop = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Clear all attached views into the recycle bin</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    <span class="comment">//Fill the grid for the initial layout of views</span></span><br><span class="line">    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会对子视图做一些记录和安排<br>(为了简便，假设来自适配器的所有子视图都是一样大的)，<br>确保所有已存在的视图在 scrap heap 之中。我将<br>大部分工作抽象到 <code>fillGrid()</code> 这个辅助方法中以便重用。<br>我们很快就会看到这个方法在更新可见视图和滚动屏幕中被大量调用。</p>
<blockquote>
<p>就像是自定义实现一个 ViewGroup，你负责触发测量和布局每一个<br>从 Recycler 获取到的子视图。API 没有直接完成这项工作 。</p>
</blockquote>
<p>通常来说，在这类方法之中你需要完成的主要步骤如下：</p>
<ol>
<li>在滚动事件结束后检查所有附加视图当前的偏移位置。</li>
<li>判断是否需要添加新视图填充由滚动屏幕产生的空白部分。并从<br> Recycler 中获取视图。</li>
<li>判断当前视图是否不再显示。移除它们并放置到 Recycler 中。</li>
<li>判断剩余视图是否需要整理。发生上述变化后可能<br> 需要你修改视图的子索引来更好地和它们的适配器位置校准。</li>
</ol>
<p>注意我们放进 <code>FixedGridLayoutManager.fillGrid()</code> 里填充 RecyclerView 的主要步骤。<br>当到达最大行数时，这个 manager 将位置从右到左排序，封装。</p>
<ol>
<li><p>清点目前我们所有的视图。将他们 Detach 以便稍后重新连接。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SparseArray&lt;View&gt; viewCache = <span class="keyword">new</span> SparseArray&lt;View&gt;(getChildCount());</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (getChildCount() != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//Cache all views by their existing position, before updating counts</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> position = positionOfIndex(i);</span><br><span class="line">		<span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">		viewCache.put(position, child);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Temporarily detach all views.</span></span><br><span class="line">	<span class="comment">// Views we still need will be added back at the proper index.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; viewCache.size(); i++) &#123;</span><br><span class="line">		detachView(viewCache.valueAt(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>测量/布局每一个当前可见的子视图。重新连接已有的视图很简单；<br> 新的视图是从 Recycler 之中获取的。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVisibleChildCount(); i++) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Layout this position</span></span><br><span class="line">    View view = viewCache.get(nextPosition);</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * The Recycler will give us either a newly constructed view,</span><br><span class="line">         * or a recycled view it has on-hand. In either case, the</span><br><span class="line">         * view will already be fully bound to the data by the</span><br><span class="line">         * adapter for us.</span><br><span class="line">         */</span></span><br><span class="line">        view = recycler.getViewForPosition(nextPosition);</span><br><span class="line">        addView(view);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * It is prudent to measure/layout each new view we</span><br><span class="line">         * receive from the Recycler. We don't have to do</span><br><span class="line">         * this for views we are just re-arranging.</span><br><span class="line">         */</span></span><br><span class="line">        measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        layoutDecorated(view, leftOffset, topOffset,</span><br><span class="line">                leftOffset + mDecoratedChildWidth,</span><br><span class="line">                topOffset + mDecoratedChildHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Re-attach the cached view at its new index</span></span><br><span class="line">        attachView(view);</span><br><span class="line">        viewCache.remove(nextPosition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>最终，所有在第一步中 detach 并且没有被重新连接的视图都不可见。<br> 将它们移入 Recycler 中，以备后用。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; viewCache.size(); i++) &#123;</span><br><span class="line">    recycler.recycleView(viewCache.valueAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说明一下，先将所有视图 detach 之后再将需要的视图重新连接是为了<br>保持每一个视图子索引的顺序 (就是  <code>getChildAt()</code> 的索引)。我们希望<br>可见视图从左上到右下的索引从 <code>0</code> 开始，到 <code>getChildCount()-1</code> 结束。<br>当我们上下滑动视图，新的子视图被添加，它的索引顺序会变得不可靠。<br>我们需要保留正确的索引来在任意点上定位每一个视图。在一个简单地<br>LayoutManager (比如 LinearLayoutManager)中，子视图可以轻松地插入<br>list 的两端， 记录层就没有存在的必要了。</p>
<h1 id="添加用户交互">添加用户交互</h1><p>目前，我们已经有一个非常好的初始布局，但是它并不能动起来。<br>RecyclerView 的关键就在于当用户浏览一组数据时动态提供视图。<br>覆盖一些方法就能实现我们的目的。</p>
<h4 id="canScrollHorizontally()_&amp;_canScrollVertically()">canScrollHorizontally() &amp; canScrollVertically()</h4><p>这些方法很简单，在你想要滚动方向对应的方法里返回 true ，<br>不想要滚动方向对应的方法里返回 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canScrollVertically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//We do allow scrolling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scrollHorizontallyBy()_&amp;_scrollVerticallyBy()">scrollHorizontallyBy() &amp; scrollVerticallyBy()</h4><p>在这里你应该实现 content 移动的逻辑。RecyclerView 已经处理了 scrolling<br>和 <a href="http://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics" target="_blank" rel="external">flinging</a> (注：Fling: Gross gesture, no on-screen target)<br>触摸操作，不需要处理 MotionEvents 或者 GestureDetectors 这些麻烦事。<br>你只需要完成下面这三个任务：</p>
<ol>
<li>将所有的子视图移动适当的位置 (对的，你得自己做这个)。</li>
<li>决定移动视图后 添加/移除 视图。</li>
<li>返回滚动的实际距离。框架会根据它判断你是否触碰到边界。</li>
</ol>
<p>在 FixedGridLayoutManager 里，这两个方法很像。这里是精简后的垂直滚动实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scrollVerticallyBy</span><span class="params">(<span class="keyword">int</span> dy, RecyclerView.Recycler recycler,</span><br><span class="line">        RecyclerView.State state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Take top measurements from the top-left child</span></span><br><span class="line">    <span class="keyword">final</span> View topView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//Take bottom measurements from the bottom-right child.</span></span><br><span class="line">    <span class="keyword">final</span> View bottomView = getChildAt(getChildCount()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Optimize the case where the entire data set is too small to scroll</span></span><br><span class="line">    <span class="keyword">int</span> viewSpan = getDecoratedBottom(bottomView) - getDecoratedTop(topView);</span><br><span class="line">    <span class="keyword">if</span> (viewSpan &lt;= getVerticalSpace()) &#123;</span><br><span class="line">        <span class="comment">//We cannot scroll in either direction</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> maxRowCount = getTotalRowCount();</span><br><span class="line">    <span class="keyword">boolean</span> topBoundReached = getFirstVisibleRow() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> bottomBoundReached = getLastVisibleRow() &gt;= maxRowCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123; <span class="comment">// Contents are scrolling up</span></span><br><span class="line">        <span class="comment">//Check against bottom bound</span></span><br><span class="line">        <span class="keyword">if</span> (bottomBoundReached) &#123;</span><br><span class="line">            <span class="comment">//If we've reached the last row, enforce limits</span></span><br><span class="line">            <span class="keyword">int</span> bottomOffset;</span><br><span class="line">            <span class="keyword">if</span> (rowOfIndex(getChildCount() - <span class="number">1</span>) &gt;= (maxRowCount - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//We are truly at the bottom, determine how far</span></span><br><span class="line">                bottomOffset = getVerticalSpace() - getDecoratedBottom(bottomView)</span><br><span class="line">                        + getPaddingBottom();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                 * Extra space added to account for allowing bottom space in the grid.</span><br><span class="line">                 * This occurs when the overlap in the last row is not large enough to</span><br><span class="line">                 * ensure that at least one element in that row isn't fully recycled.</span><br><span class="line">                 */</span></span><br><span class="line">                bottomOffset = getVerticalSpace() - (getDecoratedBottom(bottomView)</span><br><span class="line">                        + mDecoratedChildHeight) + getPaddingBottom();</span><br><span class="line">            &#125;</span><br><span class="line">            delta = Math.max(-dy, bottomOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//No limits while the last row isn't visible</span></span><br><span class="line">            delta = -dy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Contents are scrolling down</span></span><br><span class="line">        <span class="comment">//Check against top bound</span></span><br><span class="line">        <span class="keyword">if</span> (topBoundReached) &#123;</span><br><span class="line">            <span class="keyword">int</span> topOffset = -getDecoratedTop(topView) + getPaddingTop();</span><br><span class="line">            delta = Math.min(-dy, topOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delta = -dy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    offsetChildrenVertical(delta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDecoratedBottom(topView) &lt; <span class="number">0</span> &amp;&amp; !bottomBoundReached) &#123;</span><br><span class="line">            fillGrid(DIRECTION_DOWN, recycler);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bottomBoundReached) &#123;</span><br><span class="line">            fillGrid(DIRECTION_NONE, recycler);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDecoratedTop(topView) &gt; <span class="number">0</span> &amp;&amp; !topBoundReached) &#123;</span><br><span class="line">            fillGrid(DIRECTION_UP, recycler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!topBoundReached) &#123;</span><br><span class="line">            fillGrid(DIRECTION_NONE, recycler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Return value determines if a boundary has been reached</span><br><span class="line">     * (for edge effects and flings). If returned value does not</span><br><span class="line">     * match original delta (passed in), RecyclerView will draw</span><br><span class="line">     * an edge effect.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">return</span> -delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们获得了滚动距离(dx/dy)的增量来验证。方法的第一部分判断<br>按照所给的距离(标志给了滚动方向)滚动会不会超过边界。如果会，<br>我们需要计算出视图实际滚动的距离。</p>
<p>在这个方法里，我们需要自己手工移动这些视图。<br><code>offsetChildrenVertical()</code> 和 <code>offsetChildrenHorizontal()</code><br>这两个方法 可以帮助我们处理匀速移动。<br><strong>如果你不实现它，你的视图就不会滚动</strong>。<br>移动视图操作完成后，我们触发另一个填充操作，<br>根据滚动的距离替换视图。</p>
<p>最后，将实际位移距离应用给子视图。RecyclerView 根据这个值判断是否<br>绘制到达边界的效果。一般意义上，如果返回值不等于传入的值就意味着<br>需要绘制边缘的发光效果了。<br><strong>如果你返回了一个带有错误方向的值，框架的函数会把这个当做一个大的变化<br>你将不能获得正确的边缘发光特效。</strong></p>
<p>除了用来判断绘制边界特效外，返回值还被用来决定什么时候取消 flings。<br>返回错误的值会让你失去对 content  fling 的控制。框架会认为你已经提前<br>触碰到边缘并取消了 fling。</p>
<h1 id="热身结束~">热身结束~</h1><p>目前，我们已经实现了基本的功能。它少了很多的细节部分，<br>不过滚动和适当的视图回收已经完成了。<br>关于自定义 LayoutManager 还有很多要说的东西。<br><a href="http://wiresareobsolete.com/2014/09/recyclerview-layoutmanager-2/" target="_blank" rel="external">接下来</a>，我们会细致的介绍 decorations, data set changes<br>还有实现滚动到特定位置。</p>
<hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://wiresareobsolete.com/2014/09/building-a-recyclerview-layoutmanager-part-1/" target="_blank" rel="external">Building a RecyclerView LayoutManager – Part 1</a></li>
<li>原文作者 : <a href="http://wiresareobsolete.com/" target="_blank" rel="external">Dave Smith</a>  </li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a>  </li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a>   </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>状态 :   完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文是这个系列中的 Part 1，这里是 <a href="http://wiresareobsolete.com/2014/09/recyclerview-layoutmanager-2/">Part 2</a> 和 <a href="http://wiresareobsolete.com/2015/02/recyclerview-layoutmanager-3/">Part 3</a> 的链接。<br>]]>
    
    </summary>
    
      <category term="SupportLibrary" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/SupportLibrary/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过Jenkins并行完成UI的自动化测试]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/07/concurrent-android-ui-automation-jenkins/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/07/concurrent-android-ui-automation-jenkins/</id>
    <published>2015-05-06T16:00:00.000Z</published>
    <updated>2015-07-11T08:30:57.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://www.hidroh.com/assets/img/parallel-cover.jpg" alt=""><br><a id="more"></a><br>现在的 IT 公司会为了进入不同的市场开发相应的 App，来自同一家公司的 App 总会具有相似的 UI 逻辑，但 UI 的细节、风格又各有区分。随着产品的发展，抑或是在产品应用于新市场的过程中产生了旧 UI 逻辑的变种，用于测试所有 UI 逻辑的时间会与新 UI 的数量呈正比例关系增长。即使有 UI 的自动化框架可以用来减少测试所需的时间（例如 Calabash Android），使得每天只需要2个小时就能完成对 UI 的测试，但在这套 UI 衍生出四套“变种 UI”后，却要花费8个小时才能完成测试。</p>
<p>这篇博文将利用 Continuous Integration (CI) 服务，同时在不同的设备中执行 UI 测试，并介绍一种从根源上减少这种实际场景下自动化测试所需时间的方法。此外，我们的测试都是在真机上运行，而不是虚拟机。</p>
<p>更贴近现实的自动化测试：有很多东西只能通过真机来反映，像内存消耗，CPU 消耗：虚拟机通常都是消耗电脑的资源，而真机基本不会消耗电脑资源。</p>
<p>而且用真机进行测试性价比较高！Android 设备都很便宜，所以你可以在需要设备进行测试的时候毫不犹豫地买买买，如果用虚拟机测试的话，由于虚拟机会消耗很多电脑资源而且拓展电脑硬件很烧钱，这无疑会限制测试设备的数量。</p>
<p>虽说博文里同时使用了 Calabash Android 自动化框架 和 <a href="https://jenkins-ci.org/" target="_blank" rel="external">Jenkins CI</a>，但我提到的大部分方法可以通过运行在任意 CI 服务上的 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds#Distributedbuilds-RunningMultipleSlavesontheSameMachine" target="_blank" rel="external">Android Debug Bridge (ADB)</a> 应用于其他的自动化测试框架里。</p>
<h2 id="创建_Jenkins_slaves_和_slave_group">创建 Jenkins slaves 和 slave group</h2><p>完成<a href="https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds" target="_blank" rel="external">分布式构建</a>的第一步就是创建 Jenkins slave，授权它管理多个“奴隶”。我们可以通过 Jenkins -&gt; Manage Jenkins -&gt; Manage Nodes 导航到 Jenkins slaves/nodes 的配置界面。</p>
<p>根据定义，Jenkins slave 用于完成 Jenkins 主机分发下来的任务。在我们的使用场景中，需要完成的任务则是运行在 Android 设备上的自动化测试。为了完成这项任务，所有奴隶都可以<a href="https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds#Distributedbuilds-RunningMultipleSlavesontheSameMachine" target="_blank" rel="external">运行在相同的机器上</a>，也就是通过 USB 连接在电脑上的，具有执行 ADB 命令的 Android 设备。</p>
<p>下面是一个与 Samsung S3 关联的奴隶的安装细节：</p>
<p><img src="http://www.hidroh.com/assets/img/parallel-slave-1.png" alt=""></p>
<p>当所有奴隶都运行在同一台机器上时，我建议为不同的奴隶结点提供不同的系统 roots 文件，因为它们很可能会在测试结果处被存储，如果它们指向同一个 root 文件，可能会让测试结果被不同的结点重写。我们可以通过 Remote FS root 进行这样的设置。</p>
<blockquote>
<p><strong>Remote FS root</strong></p>
<p>每个奴隶都需要拥有 Jenkins 中的一个专用目录，我们在奴隶中为其指定绝对路径，如：’/var/jenkins’ 或 ‘c:\jenkins’，而且该路径应该是奴隶设备中的本地路径。但是该路径不需要对 Jenkins 可见，怎么正常怎么来就行。</p>
<p>奴隶不会持有重要数据（不同于最后创建于其上的项目的活跃工作区），所以你可以将奴隶的工作区设置到一个临时目录。这样做的唯一缺点在于：你可能会在奴隶设备关机后失去最新的工作区。</p>
</blockquote>
<p>当 separate FS roots 和多处理器允许 Calabash 的并行操作时，ADB_DEVICE_ARG 环境变量需要用于通知 Calabash，因为 Calabash 运行的设备应该向其发送 ADB 命令，防止设备的多重连接。底层中，Calabash 通过 ADB 设备命令自动化 UI，当一个设备匹配于另一个奴隶结点，ADB_DEVICE_ARG 应该通过环境变量的配置应用到 node 结点层中，并在其后在任务层变为可用。</p>
<blockquote>
<p><strong>环境变量</strong></p>
<p>这些键值对将会应用于结点上的每一个构建，并重写任意全局值，所以他们能在 Jenkins 的配置中被使用（如 $key 或 ${key}），而且将会被添加到构建上启动的进程。</p>
</blockquote>
<p>在 Nexus 4 中设置奴隶的方式如上</p>
<p><img src="http://www.hidroh.com/assets/img/parallel-slave-2.png" alt=""></p>
<p>如果你留心注意一些细节你会发现，所有奴隶结点都被配置了相同的 android-group 标签。这样做的目的主要是将奴隶分组，使得当我们需要使用奴隶时，方便我们调用特定分组里的所有奴隶。</p>
<blockquote>
<p>标签</p>
<p>标签（AKA 标签）用于将多个奴隶分到一个逻辑组中，而每一个标签都会消耗空间。例如 ‘regression java6’ 将为为结点分配 ‘regression’ 和 ‘java6’ 标签。</p>
<p>举例来说吧，如果你有多个窗口奴隶，而且你要完成的任务需要窗口，那么你可以让你的所有窗口奴隶持有 ‘windows’ 标签，然后将需要执行的任务与 ‘windows’ 标签绑定。这使得你的任务在所有窗口奴隶中被执行，而不是被随意执行。</p>
</blockquote>
<p><img src="http://www.hidroh.com/assets/img/parallel-slave-group.png" alt=""></p>
<p>现在如果我们检查 android-group，我们会得到一个所有结点都带着 android-group 标签的列表，把其他设备添加到这个组里就像拷贝一个已存在的结点和更新 ADB_DEVICE_ARG 环境变量一样简单。</p>
<h2 id="使用奴隶群建立并行任务">使用奴隶群建立并行任务</h2><p>在进行了上面的配置以后，我们现在可以创建一个 Jenkins 任务使用连接到电脑的设备，通过各自的奴隶和具有 android-group 的奴隶群执行 Calabash Android。</p>
<p><img src="http://www.hidroh.com/assets/img/parallel-downstream-1.png" alt=""></p>
<p>通过选中“如果必要的话，执行并行构建”和“限制项目运行位置”两个配置选项，使得任务可以被并行执行，主题对结点可用，仅使用标有“android-group”标签的结点。但其中的限制是：需要确保只有与已连接的设备关联的结点才能用于自动化测试，因为我们有用于完成其他任务的其他与未连接设备关联的结点。</p>
<blockquote>
<p><strong>如果必要的话，执行并行构建</strong></p>
<p>如果需要并行执行构建，Jenkins 会安排并并行执行多个构建（假设你有足够的执行器和传入的构建请求），这对于耗时长的构建和测试任务来说非常有用……此外，参数化构建也是非常实用的，因为每一个执行器的执行任务与其他执行器的执行任务相互独立。</p>
</blockquote>
<p>现在假设我们有4个自动化测试的请求和三个已连接的设备，处理完所有请求将需要两轮操作（第一轮三个设备将会被使用，剩下一个请求在队列中等待处理，当某个设备变为空闲状态则会处理该请求）。这就意味着我们可以使4个产品风格自动化测试的时间从8小时减少为4小时，如果我们再买一台或者多台设备的话，时间甚至会更少。</p>
<h2 id="通过上游任务触发并行的下游任务">通过上游任务触发并行的下游任务</h2><p>写到这里，我们已经能够随心所欲地对我们想要的设备（连接在 USB 端口处可用的设备！）手动地触发并行的自动化测试。但是，我们为什么要手动地完成这些工作呢？我们可以用 Jenkins Parameterized Trigger Plugin 设置上游任务，通过相应的参数触发多个下游任务。</p>
<p>例如，如果我们想要使用所有可用设备并行地测试多个应用 UI，那么我们可以设置一个这样的上游任务，并执行它：</p>
<p><img src="http://www.hidroh.com/assets/img/parallel-upstream-2.png" alt=""></p>
<p><img src="http://www.hidroh.com/assets/img/parallel-upstream-3.png" alt=""></p>
<p>上面的配置完成后，我们可以触发三个并行的 MOBILE_TEST 下游任务（必须进行了“如果必要的话，执行并行构建”的配置），每一个下游任务将会测试一个指定的 App 风格“cherry”，“tomato”，“rasberry”，并通过一个叫作风格的参数发送到下游任务。上游任务将会被阻塞，等待所有下游任务完成任务并因此设置构建状态。</p>
<p>我建议大家把上游任务运行在不同的奴隶结点/奴隶组中，而不是运行在和下游任务相同的奴隶结点/奴隶组中，否则它将占着设备不处理，浪费了资源</p>
<p><img src="http://www.hidroh.com/assets/img/parallel-upstream-1.png" alt=""></p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.hidroh.com/2015/04/14/concurrent-android-ui-automation-jenkins/" target="_blank" rel="external">Concurrent Android UI automation with Jenkins</a></li>
<li>原文作者 : <a href="http://www.hidroh.com/" target="_blank" rel="external">Ha Duy Trung</a>  </li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a>  </li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>校对者: <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a> </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://www.hidroh.com/assets/img/parallel-cover.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="自动化测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>