<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Android博客]]></title>
  <subtitle><![CDATA[读万卷书]]></subtitle>
  <link href="http://likebamboo.com/AndroidBlog/atom.xml" rel="self"/>
  <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//"/>
  <updated>2015-07-11T10:44:21.000Z</updated>
  <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//</id>
  
  <author>
    <name><![CDATA[likebamboo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列8]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/15/google-developing-for-android-part-8/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/15/google-developing-for-android-part-8/</id>
    <published>2015-06-14T16:00:00.000Z</published>
    <updated>2015-07-11T10:44:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="避免过度绘制">避免过度绘制</h2><p>正如在第一篇Context介绍种关于GPU讨论的部分所说，很多手机的性能有限，如果应用中有严重的过度绘制可能会导致比较糟糕的渲染性能。不透明的View会完全遮盖其它的View的情况下会导致渲染引擎进行多次绘制。你可以通过开启设置中的开发者选项的GPU overdraw来修复相应的问题。<br><a id="more"></a></p>
<h2 id="避免无用的背景">避免无用的背景</h2><p>避免过度绘制的一种方式是：移除已经拥有非透明背景View的背景。适用于View的背景不透明而且完全遮住了window背景的情况。</p>
<p>移除window backgroud的方式是一种很有效的技术，但可能是比较复杂的方式去解决过度绘制，并且在有些情况下还会导致一些奇怪的渲染问题。在manifest中为应用设置一个null backgroud虽然可行，但由于系统不能够正确的绘制starting window，可能会导致一些图形化的问题。更好的方式是在manifest中保留启动时的backgroud，而在Activity的onCreate方法中通过getWindow().setBackgroud(null)将backgroud设置为null。即便是这种方式还是会导致一些问题。比如，键盘或者IME被设置为自适应大小模式，然后以动画的方式进入到一个backgroud设置为null的activity中，因为window manager不会对window的背景进行任何绘制，从而导致一些问题。另外，全屏的ListView在由于滑动时的回弹产生的间隙也会有一些问题（可以通过ListView.setOverscrollFooter/Header来解决）。</p>
<p>这种情况下正确定位过度绘制的方式是使用starting window。放置想要的背景图片并通过window自身的windowBackgroud主题属性让这些介于容器之间的View保持默认的透明背景，而不是在window 背景和Views之间使用一些带有不透明背景色的容器。</p>
<h2 id="避免关闭Starting_Window功能">避免关闭Starting Window功能</h2><p>正如在<a href="https://medium.com/google-developers/developing-for-android-iii-2efc140167fd" target="_blank" rel="external">性能</a>篇中提到的如何加快启动速度的问题一样，当应用被加载的时候，通过starting window可以提供一种快速启动的体验。请求系统关闭starting window会失去这种体验（通过windowDisabl<br>ePreview主题属性设置）。一些应用这样做的原因时他们希望启动一个自定义的splash screen或者其它品牌性质的体验。或者因为starting window看上去与启动的activity的初始化内容看上去不搭。这种处理方式就会导致那些app会花费更长的时间启动，并且由于activity没有任何可见反馈，用户就得干等着。</p>
<p>为了提供最好的体验，你应该开启默认的starting window。如果需要优化，可以选择activity的主题，该主题会被starting window使用，从而更好的适应你的activity。当然你也可以为starting window制定自定义的drawable（通过windowBackgroud主题属性）以便更好的品牌化或者定制启动体验。</p>
<h2 id="沉浸模式下允许方便的退出">沉浸模式下允许方便的退出</h2><p>应用可以开启全屏幕模式，这种模式下只有滑动屏幕的边缘才会展开导航栏。这种模式只有在沉浸式的游戏中是可以被接受的，因为并不希望用户点击某块屏幕的时候会退出游戏。对于其他类型的app来说，特别是内容浏览的app，比如media player，当用户点击屏幕时应该更容易的退出，而不是滑动方式再去展开导航。更多关于如何正确的使用沉浸模式请参考 (immersive mode develper guide)[<a href="https://developer.android.com/training/system-ui/immersive.html" target="_blank" rel="external">https://developer.android.com/training/system-ui/immersive.html</a>]</p>
<h2 id="为starting_window设置正确的状态/导航栏的颜色">为starting window设置正确的状态/导航栏的颜色</h2><p>如果你的应用拥有带颜色的状态栏或者导航栏，那么你的主题（用于应用启动时的starting window）应该拥有相同的颜色。为了避免从starting window 到应用内容窗口的切换比较突兀，可以通过android:statusBarColor和android:navigationBarColor属性为starting window设置状态栏或者导航栏的颜色。如果你的activity window需要不同的颜色可以通过getWindow().setStatusBarColor()和getWindow.setNavigationbarColor()方法设置。</p>
<h2 id="使用适当的Context">使用适当的Context</h2><p>你可以从Application获得Context，但是将它用于创建UI的Context来说是不合适的，因为Application Context没有正确的主题信息，因此你应该使用Activity的Context对象。比如，你正在为activity获取资源，那么你应该使用activity的context而不是Application的。</p>
<h2 id="避免在异步回调中出现View的相关引用">避免在异步回调中出现View的相关引用</h2><p>避免在网络操作或者长时间的异步交互中引用一个View，Activity，或者Fragment，比如：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// some activity code</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    webservice.fetchPosts(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Response repsonse)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// View may not be valid, Activity may be gone</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View的引用可能导致占用过多资源的Context泄漏（也有可能是对View的间接引用），或者导致应用crash，因为的那个回调时，旧的引用可能已经不存在了。因此，考虑使用事件总线或者依赖性低的 回调并小心的处理attachment和detachement。</p>
<h2 id="为RTL设计">为RTL设计</h2><p>在API 17中，应用应该使用布局的start/end 而不是left/right属性。比如，你应该使用paddingStart和paddingEnd，而不是paddingLeft和paddingRignt。这样可以保证在从右到左的情况下正确的布局。</p>
<p>测试应用布局的正确性：开启开发者选项下的<code>Force RTL layout direction</code>设置。</p>
<h2 id="对数据进行本地缓存">对数据进行本地缓存</h2><p>“本地缓存，全局同步”<br>本地缓存数据对于提高启动速度是很重要的事情之一。除了一些像图片的大文件，也应该保存从服务器获取的数据。如果可以的话，你应该创建一个本地数据库来以一种更有意义的方式来保存这些（不是简单的对服务返回结果的序列化）。</p>
<p>在Google I/O 2010中有一个<a href="https://www.youtube.com/watch?v=xHXn3Kg2IQE" target="_blank" rel="external">Android Rest Client Application</a>的演讲。这里介绍了一些组件，相比多去，它们可以更好的帮助我们开发（ORM，JobQueue，EventBus），但演讲中谈论的思想和方式仍然是有效的。</p>
<h2 id="对用户的输入进行本地缓存">对用户的输入进行本地缓存</h2><p>当用户的输入需要转发到服务器时，应该在转发到服务器之前缓存它。可以想象得到，在很多累积的响应情况下，网络交互可能是异步机制的（比如一个网络请求池）。对用户输入进行缓存的主要原因是避免网络失败情况下，用户的输入丢失。缓存输入让应用可以让你在网络状态正常时进行重试。</p>
<p>在UI中你应该提供一个提示，能够让用户知道自己的请求已经完成了还是延迟了。</p>
<h2 id="将网络和后台硬盘操作分开">将网络和后台硬盘操作分开</h2><p>当你使用一个线程池维护后台所有的操作时，因为长时间的后台操作（比如网络请求），某些快速任务可能要被迫等待。对于本地的存储操作，考虑使用独立的线程池。这样可以确保本地变化可以立即更新到用户的界面而不是受到长时间的网络请求或者IPC调用的影响。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/13/google-for-android-8-user-interface/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/13/google-for-android-8-user-interface/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-viii-e91ced595fac" target="_blank" rel="external">Developing for Android VIII The Rules: User Interface</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="避免过度绘制">避免过度绘制</h2><p>正如在第一篇Context介绍种关于GPU讨论的部分所说，很多手机的性能有限，如果应用中有严重的过度绘制可能会导致比较糟糕的渲染性能。不透明的View会完全遮盖其它的View的情况下会导致渲染引擎进行多次绘制。你可以通过开启设置中的开发者选项的GPU overdraw来修复相应的问题。<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列9]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/15/google-developing-for-android-part-9/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/15/google-developing-for-android-part-9/</id>
    <published>2015-06-14T16:00:00.000Z</published>
    <updated>2015-07-11T10:44:18.000Z</updated>
    <content type="html"><![CDATA[<p>本篇文章为Google Developing for Android 系列的最后一篇文章,文章结尾如是说：</p>
<blockquote>
<p>Fin<br>(The End)<br>(Last Chapter. Done. No more. Finished.)<br><a id="more"></a><br>Andorid提供了很多可以帮助我们debug和分析问题的工具，它们可以让你的app拥有更好的性能。这些检测工具涵盖了内存分析，比如Allocation Tracker(在DDMS和Android Studio中都有)和设备性能。</p>
</blockquote>
<p>知道这些工具很重要，但更重要的是要真正的使用这些工具，保证你的应用拥有期望的表现（60帧限制，避免垃圾回收器搅动）。通过尽可能的优化和提高整体体验可以帮助Android更好的整体平台性。</p>
<p>通常用于分析性能的工具有两种类型：host和on-device。Host工具是那些运行在计算机上的工具（命令行，DDMS，Android Studio等）。on-device工具是设备上的一些工具（比如开发者选项下的一些工具），可以展示一些时时的信息，通常涉及到性能的评测。</p>
<h2 id="Host_Tools">Host Tools</h2><h3 id="Systrace">Systrace</h3><p><a href="http://developer.android.com/tools/help/systrace.html" target="_blank" rel="external">Systrace</a>是一个很强大的工具，可以展示系统中某一时间点各种事件的情况和持续时间。你可以通过运行该工具捕捉一些数据，然后在浏览器打开追踪文件去分析结果。</p>
<p>你可以在Android Studio或者命令行来打开它：<br>$SDK_ROOT/platform-tools/systrace/systrace.py.</p>
<h3 id="AllocationTracker">AllocationTracker</h3><p>可以从ddms或者Android Studio打开。允许你追踪在你开启到结束该功能期间的所有内存分配。对于查出在何处或者何时应该避免那些不必要的内存分配是非常有用的。比如，检测某一动画期间的对象分配，先启动动画，点击“Start Allocations”按钮，几帧之后但在动画结束前，再点击“Get Allocations”按钮（你可能需要将动画时长设置的比默认值更高些，以便有足够的时间完成该过程）。动画期间所有的内存分配将会被统计。更多信息参考文章 <a href="https://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">Debugging Memory</a></p>
<h3 id="TraceView">TraceView</h3><p>同样可从DDMS或者Android Studio运行。一个方法分析器，可以运行在trace mode（追踪每一次的方法调用）或者sample mode（特定时间间隔内的方法调用）。Trace mode能够很好的帮助追踪间隔期间内应用所执行的完整的代码路径，并标明了不同方法耗费的时间。由于处理这些信息相当的麻烦，因此该View已经提供了方法的调用时间。Sample mode避免了大部分的工作，因为它并没有追踪每一次调用而是指定时间内，但也丢失了代码流程的细节。<br>此外,重要的是要注意,sample模式的间隔并不总是均等的(因为运行期间只能在GC的安全点取样),它无法在内联方法中取样,而且取样中的JNI方法比例有可能超过Java方法。</p>
<h3 id="Hierarchyviewer">Hierarchyviewer</h3><p>可以作为独立的工具也可以从AndroidStudio打开。展示了所选应用的View的整个层级关系，也可以查看每个View的属性值。对于查看View层级是否复杂很有用。是否大多数时间你维持了很多不可见的View。是否使用了独立关系的布局而导致View的层级是否比较深。</p>
<h3 id="MAT(内存分析工具)">MAT(内存分析工具)</h3><p>有时你怀疑activity内部可能发生了内存泄漏，而内存的足迹又不太容易追踪。有一些内存泄漏可能是大对象（比如Activities）导致的，可能发生在屏幕方向变化时。MAT可以很好的追踪这些问题。</p>
<p>首先，通过ddms或者Android Studio进行一次heap dump。它保存了对象关系的状态。然后你可以通过命令行执行<code>hprof-conv</code>(运行<code>hprof-conv-z</code>可以抽取非app的heaps)将这些数据转化成MAT可视化的格式。最终，可以将这些数据倒入到MAT工具中（独立的工具或者Eclipse插件）得到可视化的内存图，从图中可以看到哪些对象常驻在内存中以及为什么常驻内存。</p>
<p>MAT教程视频Google I/O 2011 <a href="https://www.youtube.com/watch?v=_CruQY55HOk" target="_blank" rel="external">Memory Management for Android pps</a>,也可以参考 <a href="https://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">Debugging Memory</a> 文章。</p>
<h3 id="Memory_Monitor">Memory Monitor</h3><p>Momory Monitor是AndroidStudio的新工具，能够可视化指定进程期间的heap内存使用情况。</p>
<h3 id="meminfo">meminfo</h3><p>运行<code>adb shell dumpsys meminfo</code> 可以输出系统总体或者指定进程的不同统计数据。更多信息参考文章 <a href="https://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">Debugging Memory</a></p>
<h2 id="On－device_工具">On－device 工具</h2><p>有几种可以在设备上使用的工具或者模式，它们能够直接在屏幕上展示应用运行期间的系统的总体信息。大多数可以在开发者设置中找到。</p>
<h3 id="StrictMode">StrictMode</h3><p><a href="http://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">Strict mode</a>可以通过“Strict mode enabled”开发者选项开启，当一些操作违背了strict mode时屏幕的边界会闪现红色，比如在UI 线程做了太多的工作。StrictMode的相关信息会输出在log中。</p>
<h3 id="Profile_GPU_rendering">Profile GPU rendering</h3><p>通过开发者选项的“Profile GPU redering”开启，展示了每一帧渲染的时间以及4种主要处理过程的渲染时间：DisplayList的创建（处理绘制命令），同步渲染内容到RenderThread（大多涉及Bitmap纹理的加载），DisplayList（将本地渲染处理命令转化为OpenGL命令和参数并传送到GPU），缓冲区交换（包括缓冲区的返回和用于完成整个处理过程的GPU命令的延迟时间）</p>
<h3 id="Debug_GPU_overdraw">Debug GPU overdraw</h3><p>通过“Debug GPU overdraw”开发者选项开启，在屏幕上展示了所有像素的信息，同一帧内该像素被绘制了多少次，可以给你一些总体的参考：是否在同一区域是否向GPU创建了太多次的渲染操作（通常由于一些View被遮蔽导致）。</p>
<p>很多过度绘制是可以避免的。比如，text的底部不应该绘制背景，其阴影或者底部透明View都会导致过渡绘制。但是大块的不透明区域的过渡绘制应该被分析出来。</p>
<h3 id="Animator_duration_scale">Animator duration scale</h3><p>通过“Animator duration scale”开发者选项开启，可以减慢或者加度动画的时间。在调试动画的时候很有用，可以观测加速或者减慢情况下的动画是否会有问题。还有两个相似的级别设置，other级别用于控制不同类型的window和系统动画，“animator”级别用于控制应用内部的动画使用了Animator对象。</p>
<h3 id="录屏">录屏</h3><p>通过adb shell命令(<code>adb shell screenrecord /sdcard/myscreenrecord.mp4</code>)开启，用于记录设备和mpeg vid的帧。Ctrl－C可以停止，然后执行<code>adb pull</code>命令可以将该文件导入到电脑上。录屏对于调试动画和其它很在绝对时间哪难分析的交互情况是非常有用的。</p>
<h3 id="Show_hardware_layer_updates">Show hardware layer updates</h3><p>通过开发者选项“Show hardware layer updates”开启。当layer更新的时候，屏幕上会闪现绿色。对于在动画期间不会变化的View来说，通过Hardware layers可以获取更好的性能。但是如果hardware层的View或者其子层级的View发生变化了，就可能会导致严重的性能问题。使用该工具允许你看到不期望的layer更新。</p>
<h2 id="本系列完结！">本系列完结！</h2><blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/13/google-for-android-9-tools/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/13/google-for-android-9-tools/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-ix-tools-375134af1098" target="_blank" rel="external">Developing for Android IX Tools</a>  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章为Google Developing for Android 系列的最后一篇文章,文章结尾如是说：</p>
<blockquote>
<p>Fin<br>(The End)<br>(Last Chapter. Done. No more. Finished.)<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVVM 模式简介]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/mvvm-on-android-what-you-need-to-know/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/mvvm-on-android-what-you-need-to-know/</id>
    <published>2015-06-13T16:00:00.000Z</published>
    <updated>2015-07-11T10:21:11.000Z</updated>
    <content type="html"><![CDATA[<p>Google 在今年的 IO 大会推出了一个超赞的框架，开发者可以通过这个框架为 View 中的任何一个对象的数据域进行绑定，框架会注意到数据是否被更新，如果数据被更新，将自动更新 View 中对应的内容。<br><a id="more"></a><br>说实话，这个框架真的很实用，还能让我们使用 Windows 程序开发时使用的 MVVM 模式。在结合这个新的框架和 MVVM 模式进行开发之前，花时间了解 MVVM 架构的基本概念和它能为应用带来的好处是个性价比极高的选择，MVVM 模式由下面三个部分组成：</p>
<ul>
<li>Model – 代表你的业务逻辑 </li>
<li>View – 显示界面内容</li>
<li>ViewModel – 关联上面两者的对象</li>
</ul>
<p>ViewModel 接口提供 Action 和 Data，Action 改变基础的 Model（例如：点击监听器，文字修改状态监听器，等等……），而 Data 则是 Model 的内容。</p>
<p>举个例子，一个用于拍卖页面的 ViewModel 可能对外公布的数据域有：拍卖品的图片、标题、描述和价钱；此外，还可能会对外提供进行拍卖、购买、与卖方沟通的方法。</p>
<p>在传统的 Android 架构中，Controller 为 View 提供数据，你要做的就是在 Activity 中找到相应的 View，并更新其中的数据。但在 MVVM 中，如果 ViewModel 修改了某些内容，而且数据绑定框架注意到内容发生了改变，框架就会自动更新与该数据相关的所有 View，通过这个提供数据和命令的接口使得这两个组件间呈松耦合状态。</p>
<p>这个框架除了让 View 变得更加智能，使用起来更加便利以外，还大大简化了测试的过程。</p>
<p>由于 ViewModel 再也不需要依赖于 View 了，这使你甚至能对一个不存在的 View 进行测试，通过对其他依赖进行恰当的依赖注入，大大简化了测试的复杂度。</p>
<p>还是举例子来说吧，如果我们不能将 ViewModel 与某个已存在的 View 绑定，开发者可能会在测试用例中新建一个 ViewModel，然后为它提供一些数据，再执行某些操作以确保数据正确地被改变。回到刚刚的拍卖例子中，你可能会创建一个提供 mock API 服务的 ViewModel，用它读取任意一个拍卖品并投标，然后确保显示出来的数据是正确的。不需要与实体 View 产生交互就能完成上面所有操作。</p>
<p>当对某个 View 进行测试时，开发者可以创建许多对外暴露预测试状态（与通过请求网络或访问数据库获得数据相反）的 mock ViewModel，并分析 View 在任何数量发生改变时的反应。</p>
<p>希望这篇博文能帮助你理解 MVVM 模式的概念以及它的好处，接下来我们将发布一些博文为大家讲解具体的实现细节，以及使用数据绑定框架开发时的一些小提示和小技巧。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.willowtreeapps.com/blog/mvvm-on-android-what-you-need-to-know/" target="_blank" rel="external">MVVM on Android: What You Need to Know</a></li>
<li>原文作者 : <a href="http://www.willowtreeapps.com/" target="_blank" rel="external">Frank</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Google 在今年的 IO 大会推出了一个超赞的框架，开发者可以通过这个框架为 View 中的任何一个对象的数据域进行绑定，框架会注意到数据是否被更新，如果数据被更新，将自动更新 View 中对应的内容。<br>]]>
    
    </summary>
    
      <category term="MVVM" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/MVVM/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Android架构" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/Android%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Design Support Library (I)-Navigation View]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/android-design-support-library-part-1-navigation-view/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/android-design-support-library-part-1-navigation-view/</id>
    <published>2015-06-13T16:00:00.000Z</published>
    <updated>2015-07-11T10:29:08.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://events.google.com/io2015/" target="_blank" rel="external">Google I/O 2015</a> 给 Android 开发者提供了一整套新工具，让 Android 开发更容易。<br>我会完成一个系列文章来介绍超级实用的 <a href="http://android-developers.blogspot.com.es/2015/05/android-design-support-library.html" target="_blank" rel="external">Design Support Library</a>.<br><a id="more"></a><br><a href="https://github.com/chrisbanes/cheesesquare/" target="_blank" rel="external">Github</a> 上已经有一个很好的使用示例，不过我会通过完成一个<a href="https://github.com/antoniolg/MaterializeYourApp" target="_blank" rel="external">App</a>，<br>深入讲解每一个新特性。</p>
<h2 id="Navigation_View">Navigation View</h2><p>在这次的文章中，我们先介绍 <strong>Navigation View</strong>。Material Design 发布以来，<br>我们只是知道 <a href="http://www.google.com/design/spec/patterns/navigation-drawer.html" target="_blank" rel="external">Navigation Drawer </a> 应该长什么样。</p>
<p><img src="http://antonioleiva.com/wp-content/uploads/2015/05/navigation_drawer1-e1433071058464.png" alt="img-01"></p>
<p>想要完成自己实现一个又不是很容易。不过现在我们有了 navigation view，<br>这个工作就很轻松了。</p>
<h2 id="Navigation_View如何工作">Navigation View如何工作</h2><p>你应该用它替换你之前 Drawer Layout 中自定义 View 的位置。<br>Navigation View 可以接受一些参数，一个可选的 header layout，<br>还有一个用来构建导航选项的 menu。然后你只需添加事件监听器就可以了。</p>
<h2 id="Implementation">Implementation</h2><p>首先，创建 menu。很简单，创建一个 group，设置同时只有一个 item 能被选中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">menu</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">group</span></span><br><span class="line">        <span class="attribute">android:checkableBehavior</span>=<span class="value">"single"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_home"</span></span><br><span class="line">            <span class="attribute">android:checked</span>=<span class="value">"true"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_home_black_24dp"</span></span><br><span class="line">            <span class="attribute">android:title</span>=<span class="value">"@string/home"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_favourite"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_favorite_black_24dp"</span></span><br><span class="line">            <span class="attribute">android:title</span>=<span class="value">"@string/favourite"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_settings"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_settings_black_24dp"</span></span><br><span class="line">            <span class="attribute">android:title</span>=<span class="value">"@string/settings"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>理论上，你也可以像下面这样，在每个 item 中添加子 menu 实现带有分类的选项块：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">item</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/section"</span></span><br><span class="line">    <span class="attribute">android:title</span>=<span class="value">"@string/section_title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">menu</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_favourite"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_favorite_black_24dp"</span></span><br><span class="line">            <span class="attribute">android:title</span>=<span class="value">"@string/favourite"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="title">item</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_downloaded"</span></span><br><span class="line">            <span class="attribute">android:icon</span>=<span class="value">"@drawable/ic_file_download_black_24dp"</span></span><br><span class="line">            <span class="attribute">android:title</span>=<span class="value">"@string/downloaded"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样会创建一个 divider 和 header，然后把 items 加到它的正下方。然而这样我们就没办法<br>判断哪个 item 被选中了。如果日后我知道怎样做我会更新这部分的。不过，我还是鼓励你去尝试<br>看看它的效果。</p>
<p>现在，我们可以把 navigation view 加到我们的 activity layout 里了，设置好 menu 和  header layout。<br>Header 可以是任意 view ，所以这里不做过多介绍，你可以到 <a href="https://github.com/antoniolg/MaterializeYourApp/blob/master/app/src/main/res/layout/drawer_header.xml" target="_blank" rel="external">Github</a> 查看 header 部分代码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.v4.widget.DrawerLayout</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/drawer_layout"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:fitsSystemWindows</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">FrameLayout</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.design.widget.NavigationView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/navigation_view"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_gravity</span>=<span class="value">"start"</span></span><br><span class="line">        <span class="attribute">app:headerLayout</span>=<span class="value">"@layout/drawer_header"</span></span><br><span class="line">        <span class="attribute">app:menu</span>=<span class="value">"@menu/drawer"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="title">android.support.v4.widget.DrawerLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来看看 Java 代码部分。首先你要启用  <code>home as up</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br><span class="line"><span class="keyword">final</span> ActionBar actionBar = getSupportActionBar();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (actionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">    actionBar.setHomeAsUpIndicator(R.drawable.ic_menu_black_24dp);</span><br><span class="line">    actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后初始化 navigation drawer。当一个 item 被选中时，显示一个 <code>Snackbar</code> (我会在下篇文章中介绍它)，<br>选中被点击的 item，关闭 drawer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);</span><br><span class="line"> </span><br><span class="line">NavigationView view = (NavigationView) findViewById(R.id.navigation_view);</span><br><span class="line">view.setNavigationItemSelectedListener(<span class="keyword">new</span> NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNavigationItemSelected</span><span class="params">(MenuItem menuItem)</span> </span>&#123;</span><br><span class="line">        Snackbar.make(content, menuItem.getTitle() + <span class="string">" pressed"</span>, Snackbar.LENGTH_LONG).show();</span><br><span class="line">        menuItem.setChecked(<span class="keyword">true</span>);</span><br><span class="line">        drawerLayout.closeDrawers();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后，在 menu action 按下时打开 drawer ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> android.R.id.home:</span><br><span class="line">            drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion">Conclusion</h2><p>创建一个满足 Material 设计准则的 navigation drawer 是如此简单！感谢 design support library 。<br>下篇文章会继续介绍其他好用的新控件。你可以到这(<a href="https://github.com/antoniolg/MaterializeYourApp" target="_blank" rel="external">Github</a>)查看我们所有的代码<br>。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://antonioleiva.com/navigation-view/" target="_blank" rel="external">Design Support Library (I): Navigation View</a></li>
<li>原文作者 : <a href="http://antonioleiva.com/about/" target="_blank" rel="external">Antonio</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a> </li>
<li>校对者:  <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a> </li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://events.google.com/io2015/">Google I/O 2015</a> 给 Android 开发者提供了一整套新工具，让 Android 开发更容易。<br>我会完成一个系列文章来介绍超级实用的 <a href="http://android-developers.blogspot.com.es/2015/05/android-design-support-library.html">Design Support Library</a>.<br>]]>
    
    </summary>
    
      <category term="SupportLibrary" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/SupportLibrary/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="材料设计" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E6%9D%90%E6%96%99%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Design Support Library]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/android-design-support-library/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/android-design-support-library/</id>
    <published>2015-06-13T16:00:00.000Z</published>
    <updated>2015-07-11T10:23:30.000Z</updated>
    <content type="html"><![CDATA[<p>Android 5.0是有史以来最重要的Android 版本之一，这其中有很大部分要归功于Material design的引入，这种新的设计语言让整个Android的用户体验焕然一新。我们的详细专题是帮助你开始采用Material Design。但是我们也知道，这种设计对于开发者，尤其是那些在意向后兼容的开发者来说是一种挑战。在Android Design Support Library的帮助下，我们为所有的开发者，所有2.1以上的设备，带来了一些重要的Material design控件。你可以在这里面找到Navigation Drawer View，输入控件的悬浮标签，Floating Action Button，Snackbar，Tab以及将这些控件结合在一起的手势滚动框架。<br><a id="more"></a><br><a href="https://youtu.be/32i7ot0y78U" target="_blank" rel="external">YouTube的介绍</a></p>
<h3 id="Navigation_View">Navigation View</h3><p><a href="http://www.google.com/design/spec/patterns/navigation-drawer.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Navigation drawer</a>是app识别度与内部导航的关键，保持这里设计上的一致性对app的可用性至关重要，尤其是对于第一次使用的用户。 NavigationView 通过提供抽屉导航所需的框架让实现更简单，同时它还能够直接通过菜单资源文件直接生成导航元素。</p>
<p><img src="https://camo.githubusercontent.com/00c54ac78c2dd31a464b43c7018b16a8d003c088/687474703a2f2f332e62702e626c6f6773706f742e636f6d2f2d576d42425151454a494b4d2f5657696b417979303873492f41414141414141414276632f3152333654786b383355492f733430302f6472617765722e706e67" alt=""></p>
<p>把NavigationView作为DrawerLayout的内容视图来使用，布局如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="class">.support</span><span class="class">.v4</span><span class="class">.widget</span><span class="class">.DrawerLayout</span></span><br><span class="line">        xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:fitsSystemWindows=<span class="string">"true"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- your <span class="attribute">content</span> layout --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.NavigationView</span></span><br><span class="line">            android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_gravity=<span class="string">"start"</span></span><br><span class="line">            app:headerLayout=<span class="string">"@layout/drawer_header"</span></span><br><span class="line">            app:menu=<span class="string">"@menu/drawer"</span>/&gt;</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.v4</span><span class="class">.widget</span><span class="class">.DrawerLayout</span>&gt;</span><br></pre></td></tr></table></figure>
<p>你会注意到 NavigationView 的两个属性：app:headerLayout  - 控制头部的布局， app:menu - 导航菜单的资源文件（也可以在运行时配置）。NavigationView处理好了和状态栏的关系，可以确保NavigationView在API21+设备上正确的和状态栏交互。</p>
<p>最简单的抽屉菜单往往是几个可点击的菜单的集合：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;group android:<span class="variable">checkableBehavior=</span><span class="string">"single"</span>&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:<span class="variable">id=</span><span class="string">"@+id/navigation_item_1"</span></span><br><span class="line">        android:<span class="variable">checked=</span><span class="string">"true"</span></span><br><span class="line">        android:<span class="variable">icon=</span><span class="string">"@drawable/ic_android"</span></span><br><span class="line">        android:<span class="variable">title=</span><span class="string">"@string/navigation_item_1"</span>/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:<span class="variable">id=</span><span class="string">"@+id/navigation_item_2"</span></span><br><span class="line">        android:<span class="variable">icon=</span><span class="string">"@drawable/ic_android"</span></span><br><span class="line">        android:<span class="variable">title=</span><span class="string">"@string/navigation_item_2"</span>/&gt;</span><br><span class="line">&lt;/group&gt;</span><br></pre></td></tr></table></figure>
<p>被点击过的item会高亮显示在抽屉菜单中，让用户知道当前是哪个菜单被选中。<br>你也可以在menu中使用subheader来为菜单分组：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;item</span><br><span class="line">    android:<span class="variable">id=</span><span class="string">"@+id/navigation_subheader"</span></span><br><span class="line">    android:<span class="variable">title=</span><span class="string">"@string/navigation_subheader"</span>&gt;</span><br><span class="line">    &lt;menu&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:<span class="variable">id=</span><span class="string">"@+id/navigation_sub_item_1"</span></span><br><span class="line">            android:<span class="variable">icon=</span><span class="string">"@drawable/ic_android"</span></span><br><span class="line">            android:<span class="variable">title=</span><span class="string">"@string/navigation_sub_item_1"</span>/&gt;</span><br><span class="line">        &lt;item</span><br><span class="line">            android:<span class="variable">id=</span><span class="string">"@+id/navigation_sub_item_2"</span></span><br><span class="line">            android:<span class="variable">icon=</span><span class="string">"@drawable/ic_android"</span></span><br><span class="line">            android:<span class="variable">title=</span><span class="string">"@string/navigation_sub_item_2"</span>/&gt;</span><br><span class="line">    &lt;/menu&gt;</span><br><span class="line">&lt;/item&gt;</span><br></pre></td></tr></table></figure>
<p>你可以通过设置一个OnNavigationItemSelectedListener，使用其setNavigationItemSelectedListener()来获得元素被选中的回调事件。它为你提供可以点击的<a href="http://developer.android.com/reference/android/view/MenuItem.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">MenuItem</a>，让你可以处理选择事件，改变复选框状态，加载新内容，关闭导航菜单，以及其他任何你想做的操作。</p>
<h3 id="Floating_labels_for_editing_text">Floating labels for editing text</h3><p>即便是十分简单的EditText，在Material Design 中也有提升的空间。在EditText中，当你填入第一个字符后，hint就消失了。现在将它换成<a href="http://developer.android.com/reference/android/support/design/widget/TextInputLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">TextInputLayout</a>，提示信息会变成一个显示在EditText之上的floating label，这样用户就始终知道他们现在输入的是什么。</p>
<p><img src="https://camo.githubusercontent.com/8c5b3105f15e4c566c3c9b04ec16fa5402c3fb05/687474703a2f2f342e62702e626c6f6773706f742e636f6d2f2d42554b633541777a5334412f56576968566c48723963492f41414141414141414276492f72736c42416f6148777a412f73313630302f74657874696e7075746c61796f75742e706e67" alt=""></p>
<p>除此以外，还可以通过setError()设置当用户输入不合法时的Error提示；</p>
<h3 id="Floating_Action_Button">Floating Action Button</h3><p><a href="http://www.google.com/design/spec/components/buttons-floating-action-button.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Floating action button</a>是一个负责显示界面基本操作的圆形按钮。Design library中的<a href="http://developer.android.com/reference/android/support/design/widget/FloatingActionButton.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">FloatingActionButton</a> 实现了一个默认颜色为主题中colorAccent的悬浮操作按钮。</p>
<p><img src="https://camo.githubusercontent.com/784f2192b4ad36e679acaa59047feb51f49d226a/687474703a2f2f322e62702e626c6f6773706f742e636f6d2f2d746472674e596e515a79772f5657694f636653526f59492f41414141414141414275552f364c734f784a46453468452f73313630302f696d61676530332e706e67" alt=""></p>
<p>除了一般大小的悬浮操作按钮，它还支持mini size（fabSize=”mini”）。FloatingActionButton继承自ImageView，你可以使用android:src或者ImageView的任意方法，比如<a href="http://developer.android.com/reference/android/widget/ImageView.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog#setImageDrawable(android.graphics.drawable.Drawable" target="_blank" rel="external">setImageDrawable()</a>来设置FloatingActionButton里面的图标。</p>
<h3 id="Snackbar">Snackbar</h3><p>如果你需要一个轻量级、可以快速作出反馈的控件，可以试试<a href="http://www.google.com/design/spec/components/snackbars-toasts.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">SnackBar</a>。<a href="http://www.google.com/design/spec/components/snackbars-toasts.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Snackbar</a>显示在屏幕的底部,包含了文字信息与一个可选的操作按钮。在指定时间结束之后自动消失。另外，用户还可以滑动删除它们。</p>
<p><a href="http://material-design.storage.googleapis.com/publish/material_v_3/material_ext_publish/0B6Okdz75tqQsLVVnZlF4UEtKRU0/components_snackbar_specs_fabtablet_002.webm" target="_blank" rel="external">example video</a></p>
<p>Snackbar，可以通过滑动或者点击进行交互，可以看作是比Toast更强大的快速反馈机制，你会发现他们的API非常相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Snackbar</span><br><span class="line">  .make(parentLayout, R.<span class="built_in">string</span>.<span class="keyword">snackbar_t</span>ext, Snackbar.LENGTH_LONG)</span><br><span class="line">  .setAction(R.<span class="built_in">string</span>.snackbar_action, myOnClickListener)</span><br><span class="line">  .show(); <span class="comment">// Don’t forget to show!</span></span><br></pre></td></tr></table></figure>
<p>你应该注意到了make()方法中把一个View作为第一个参数，Snackbar试图找到一个合适的父亲以确保自己是被放置于底部。</p>
<h3 id="Tabs">Tabs</h3><p>通过选项卡的方式切换<a href="http://www.google.com/design/spec/components/tabs.html" target="_blank" rel="external">View</a>并不是Material design中才有的新概念，它们和<a href="http://www.google.com/design/spec/patterns/app-structure.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog#app-structure-top-level-navigation-strategies" target="_blank" rel="external">顶层导航模式</a>或者组织app中不同分组内容（比如，不同风格的音乐）是同一个概念。</p>
<p><img src="https://camo.githubusercontent.com/8ad148ec47ab6aa2c27083da5ef3c546fb98f0c5/687474703a2f2f312e62702e626c6f6773706f742e636f6d2f2d6c69726151684c456e36302f5657696862696158614a492f41414141414141414276512f6e4b69315f78637836796b2f733332302f746162732e706e67" alt=""></p>
<p>Design library的<a href="http://developer.android.com/reference/android/support/design/widget/TabLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">TabLayout</a> 既实现了固定的选项卡（View的宽度平均分配），也实现了可滚动的选项卡（View宽度不固定同时可以横向滚动）,也可以通过编写代码添加Tab。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TabLayout <span class="keyword">tabLayout</span> = ...;</span><br><span class="line"><span class="keyword">tabLayout</span>.addTab(<span class="keyword">tabLayout</span>.newTab().setText(<span class="string">"Tab 1"</span>));</span><br></pre></td></tr></table></figure></p>
<p>如果，你使用<a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">ViewPager</a>在tab之间横向切换，你可以直接从<a href="http://developer.android.com/reference/android/support/v4/view/PagerAdapter.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">PagerAdapter</a>的<a href="http://developer.android.com/reference/android/support/v4/view/PagerAdapter.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog#getPageTitle(int" target="_blank" rel="external">getPageTitle()</a>)中创建选项卡，然后使用setupWithViewPager()将两者联系在一起。它可以使tab的选中事件能更新ViewPager,同时ViewPager的页面改变能更新tab的选中状态。</p>
<h3 id="CoordinatorLayout,_动作和滚动">CoordinatorLayout, 动作和滚动</h3><p>独特的视觉效果只是Material design小小的一部分：运动也是设计好一款Material designed应用的重要组成部分。而在Material design中，包括<a href="http://www.google.com/design/spec/animation/responsive-interaction.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog#responsive-interaction-surface-reaction" target="_blank" rel="external">触摸Ripple</a>和<a href="http://www.google.com/design/spec/animation/meaningful-transitions.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">有意义的转场</a>，Design library引入<a href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog0" target="_blank" rel="external">CoordinatorLayout</a>，一个从另一层面去控制子view之间触摸事件的布局，Design library中的很多控件都利用了它。</p>
<h3 id="CoordinatorLayout和Floating_Action_Buttons">CoordinatorLayout和Floating Action Buttons</h3><p>一个很好的例子就是当你将FloatingActionButton作为一个子View添加进CoordinatorLayout并且将CoordinatorLayout传递给 Snackbar.make()，在3.0及其以上的设备上，Snackbar不会显示在悬浮按钮的上面，而是FloatingActionButton利用CoordinatorLayout提供的回调方法，在Snackbar以动画效果进入的时候自动向上移动让出位置，并且在Snackbar动画地消失的时候回到原来的位置，不需要额外的代码。</p>
<p><a href="http://material-design.storage.googleapis.com/publish/material_v_3/material_ext_publish/0B6Okdz75tqQsLWFucDNlYWEyeW8/components_snackbar_usage_fabdo_002.webm" target="_blank" rel="external">example video</a></p>
<p>CoordinatorLayout还提供了layout_anchor和layout_anchorGravity属性一起配合使用，可以用于放置floating view，比如FloatingActionButton与其他View的相对位置</p>
<h3 id="CoordinatorLayout_和app_bar">CoordinatorLayout 和app bar</h3><p>另一个比较重要的场合是CoordinatorLayout结合app bar (或者action bar)和 <a href="http://www.google.com/design/spec/patterns/scrolling-techniques.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">滚动处理</a>. 你可能在你的布局里已经使用了<a href="https://developer.android.com/reference/android/support/v7/widget/Toolbar.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Toolbar</a>, 能让你自定义外观，将应用中最显眼的部分和其他部分整合到一起. Design library采用了进一步的解决方案:使用<a href="http://developer.android.com/reference/android/support/design/widget/AppBarLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">AppBarLayout</a>可以让Toolbar和其他View（例如展示Tab的TabLayout）对滚动事件作出反应，前提是他们在一个标有ScrollingViewBehavior的View中.因此，你可以创建如下的布局：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.CoordinatorLayout</span></span><br><span class="line">        xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">        xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;! -- Your Scrollable View --&gt;</span><br><span class="line">    &lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.RecyclerView</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            app:layout_behavior=<span class="string">"@string/appbar_scrolling_view_behavior"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.AppBarLayout</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span>&gt;</span><br><span class="line">   &lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span></span><br><span class="line">                  ...</span><br><span class="line">                  app:layout_scrollFlags=<span class="string">"scroll|enterAlways"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.TabLayout</span></span><br><span class="line">                  ...</span><br><span class="line">                  app:layout_scrollFlags=<span class="string">"scroll|enterAlways"</span>/&gt;</span><br><span class="line">     &lt;/android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.AppBarLayout</span>&gt;</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.CoordinatorLayout</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，随着用户滚动RecyclerView，AppBarLayout通过子视图上的scroll flag，处理事件作出反应，控制他们如何进入，如何退出。Flag包括：</p>
<blockquote>
<ul>
<li>scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。</li>
<li>enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用”快速返回”模式。</li>
<li>enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只会在最小高度处进入，只有当滚动视图到达顶部时才扩大到完整高度。</li>
<li>exitUntilCollapsed: 在滚动过程中，只有当视图折叠到最小高度的时候，它才退出屏幕。</li>
</ul>
</blockquote>
<p>注意：那些使用Scroll flag的视图必须在其他视图之前声明。这样才能确保所有的视图从顶部撤离，剩下的元素固定在前面（译者注：剩下的元素压在其他元素的上面）。</p>
<h3 id="折叠_Toolbars">折叠 Toolbars</h3><p>直接向AppBarLayout添加ToolBar，你需要添加enteralwayscollapsed和exituntilcollapsed两个滚动Flag，但是不能在细节上不同的元素对此的反应。为此，您可以使用 <a href="http://developer.android.com/reference/android/support/design/widget/CollapsingToolbarLayout.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">CollapsingToolbarLayout</a>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.AppBarLayout</span></span><br><span class="line">        android:layout_height=<span class="string">"192dp"</span></span><br><span class="line">        android:layout_width=<span class="string">"match_parent"</span>&gt;</span><br><span class="line">    &lt;android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.CollapsingToolbarLayout</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            app:layout_scrollFlags=<span class="string">"scroll|exitUntilCollapsed"</span>&gt;</span><br><span class="line">        &lt;android<span class="class">.support</span><span class="class">.v7</span><span class="class">.widget</span><span class="class">.Toolbar</span></span><br><span class="line">                android:layout_height=<span class="string">"?attr/actionBarSize"</span></span><br><span class="line">                android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">                app:layout_collapseMode=<span class="string">"pin"</span>/&gt;</span><br><span class="line">        &lt;/android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.CollapsingToolbarLayout</span>&gt;</span><br><span class="line">&lt;/android<span class="class">.support</span><span class="class">.design</span><span class="class">.widget</span><span class="class">.AppBarLayout</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这个设置使用collapsingtoolbarlayout的layout_collapsemode =”pin” 确保在View折叠时，Toolbar本身仍然在屏幕顶部。更好的是，当你同时使用collapsingtoolbarlayout和Toolbar，当布局完全可见时，标题看上去明显变大了；当布局折叠完成后，它恢复到其默认大小。请注意，在这些情况下，你应该调用CollapsingToolbarLayout#settitle() ，而不是调用Toolbar。</p>
<p><a href="http://material-design.storage.googleapis.com/publish/material_v_3/material_ext_publish/0B0NGgBg38lWWcFhaV1hiSlB4aFU/patterns-scrollingtech-scrolling-070801_Flexible_Space_xhdpi_003.webm" target="_blank" rel="external">example video</a></p>
<p>如果你希望添加压住特定的视图效果，您可以使用app：layout_collapsemode =”parallax”（和app：layout_collapseparallaxmultiplier =“0.7”（可选,用于设置视差乘数）实现视差滚动（也就是说ImageView，作为Toolbar的兄弟节点，在collapsingtoolbarlayout中）。在这种情况下，建议在CollapsingToolbarLayout中设置<br>app:contentScrim=”?attr/colorPrimary”这一属性，这样，当视图折叠的时候，就会有蒙上纱布的渐变效果。</p>
<p><a href="http://material-design.storage.googleapis.com/publish/material_v_4/material_ext_publish/0B6Okdz75tqQscXNQY3dNdVlYeTQ/patterns-scrolling-techniques_flex_space_image_xhdpi_003.webm" target="_blank" rel="external">example video</a></p>
<h3 id="CoordinatorLayout与自定义控件">CoordinatorLayout与自定义控件</h3><p>还有一件需要注意的事情，CoordinatorLayout跟FloatingActionButton或AppBarLayout需要一定的配置-它在<a href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog" target="_blank" rel="external">Coordinator.Behavior</a>提供了一些API,子视图既可以更好地控制触摸事件也可以通过<a href="http://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html?utm_campaign=io15&amp;utm_source=dac&amp;utm_medium=blog#onDependentViewChanged(android.support.design.widget.CoordinatorLayout,%20V,%20android.view.View" target="_blank" rel="external">onDependentViewChanged()</a>)给别人提供一个回调方法。</p>
<p>Views可以用CoordinatorLayout.DefaultBehavior(YourView.Behavior.class)注解（annotation）声明默认的Behavior,或者在你的布局文件中声明app:layout_behavior=”com.example.app.YourView$Behavior” 属性. 这样做，就可以将任何一个View和CoordinatorLayout整合在一起.</p>
<h3 id="马上使用吧！">马上使用吧！</h3><p>Design library现在就可以使用，请确保已经用SDk Manager更新了Android Support Repository. 然后添加一条dependency，你就可以使用Design library了:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.android.support:design:22.2.0'</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，Design library 依赖于Support v4和AppCompat Support Libraries,在你添加  Design library时，这些库也会自动的添加到依赖中。同时，这些控件在Android Studio的Layout Editor (可以在CustomView中找到)中是可用的，你可以便捷的预览一些新的控件。</p>
<p>Design library, AppCompat和所有的Android Support Library 都是开发Android的强有力工具，当你打造一个符合当代风格、好看的应用时，可以使用提供现成的模块，无需从0开始。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://android-developers.blogspot.jp/2015/05/android-design-support-library.html" target="_blank" rel="external">Android Design Support Library</a></li>
<li>原文作者 : <a href="http://developer.android.com/index.html" target="_blank" rel="external">Android Developers Blog</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/MiJack" target="_blank" rel="external">MiJack</a> </li>
<li>状态 :  校对完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android 5.0是有史以来最重要的Android 版本之一，这其中有很大部分要归功于Material design的引入，这种新的设计语言让整个Android的用户体验焕然一新。我们的详细专题是帮助你开始采用Material Design。但是我们也知道，这种设计对于开发者，尤其是那些在意向后兼容的开发者来说是一种挑战。在Android Design Support Library的帮助下，我们为所有的开发者，所有2.1以上的设备，带来了一些重要的Material design控件。你可以在这里面找到Navigation Drawer View，输入控件的悬浮标签，Floating Action Button，Snackbar，Tab以及将这些控件结合在一起的手势滚动框架。<br>]]>
    
    </summary>
    
      <category term="SupportLibrary" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/SupportLibrary/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="材料设计" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E6%9D%90%E6%96%99%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android之WebRTC介绍]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/introduction-to-webRTC-on-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/14/introduction-to-webRTC-on-android/</id>
    <published>2015-06-13T16:00:00.000Z</published>
    <updated>2015-07-11T10:22:05.000Z</updated>
    <content type="html"><![CDATA[<p>WebRTC被誉为是web长期开源开发的一个新启元，是近年来web开发的最重要创新。WebRTC允许Web开发者在其web应用中添加视频聊天或者点对点数据传输，不需要复杂的代码或者昂贵的配置。目前支持Chrome、Firefox和Opera，后续会支持更多的浏览器，它有能力达到数十亿的设备。<br><a id="more"></a><br>然而，WebRTC一直被误解为仅适合于浏览器。事实上，WebRTC最重要的一个特征是允许本地和web应用间的互操作，很少有人使用到这个特性。</p>
<p>本文将探讨如何在自己的Android应用中植入WebRTC，使用<a href="http://www.webrtc.org/" target="_blank" rel="external">WebRTC Initiative</a>中提供的本地库。这边文章不会讲解如何使用信号机制建立通话，而是重点探讨Android与浏览器中实现的差异性和相似性。下文将讲解Android中实现对应功能的一些接口。如果想要了解WebRTC的基础知识，强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Sam Dutton’s Getting started with WebRTC</a>。</p>
<h2 id="项目中添加WebRTC">项目中添加WebRTC</h2><p><em>下面的讲解基于Android WebRTC库版本9127.</em></p>
<p>首先要做的是在应用中添加WebRTC库。 WebRTC Initiative 提供了<a href="http://www.webrtc.org/native-code/android" target="_blank" rel="external">一种简洁的方式来编译</a>，但尽量不要采用那种方式。取而代之，建议使用原始的io编译版本，可以从<a href="https://oss.sonatype.org/content/groups/public/io/pristine/" target="_blank" rel="external">maven central repository</a>中获取。</p>
<p>添加WebRTC到工程中，需要在你的依赖中添加如下内容：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">compile</span> <span class="string">'io.pristine:libjingle:9127@aar'</span></span><br></pre></td></tr></table></figure></p>
<p>同步工程后，WebRTC库就准备就绪。</p>
<h2 id="权限">权限</h2><p>同其他Android应用一样，使用某些 API 需要申请相应权限。WebRTC也不例外。制作的应用不同，或者需要的功能不同，例如音频或者视频，所需要的权限集也是不同的。请确保按需申请！一个好的视频聊天应用权限集如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 <span class="tag">&lt;<span class="title">uses-feature</span> <span class="attribute">android:name</span>=<span class="value">"android.hardware.camera"</span> /&gt;</span></span><br><span class="line">2 <span class="tag">&lt;<span class="title">uses-feature</span> <span class="attribute">android:name</span>=<span class="value">"android.hardware.camera.autofocus"</span> /&gt;</span></span><br><span class="line">3 <span class="tag">&lt;<span class="title">uses-feature</span> <span class="attribute">android:glEsVersion</span>=<span class="value">"0x00020000"</span> <span class="attribute">android:required</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">4 </span><br><span class="line">5 <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.CAMERA"</span> /&gt;</span></span><br><span class="line">6 <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.RECORD_AUDIO"</span> /&gt;</span></span><br><span class="line">7 <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line">8 <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line">9 <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.MODIFY_AUDIO_SETTINGS"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="灯光，摄影，工厂">灯光，摄影，工厂</h2><p>在浏览器中使用WebRTC时，有一些功能完善、说明详细的API可供使用。 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getUserMedia" target="_blank" rel="external">navigator.getUserMedia</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection" target="_blank" rel="external">RTCPeerConnection</a> 包含了可能用到的几乎所有功能。结合<code>&lt;video&gt;</code>标签使用，可以显示任何想要显示的本地视频流和远程视频流。</p>
<p>所幸的是Android上也有相同的API，虽然它们的名字有所不同。Android相关的API有<a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#VideoCapturerAndroid" target="_blank" rel="external">VideoCapturerAndroid</a>, <a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#VideoRenderer" target="_blank" rel="external">VideoRenderer</a>, <a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#MediaStream" target="_blank" rel="external">MediaStream</a>, <a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#PeerConnection" target="_blank" rel="external">PeerConnection</a>, 和 <a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/#PeerConnectionFactory" target="_blank" rel="external">PeerConnectionFactory</a>。下面我们将逐一讲解。</p>
<p>在开始之前，需要创建PeerConnectionFactory，这是Android上使用WebRTC最核心的API。</p>
<h2 id="PeerConnectionFactory">PeerConnectionFactory</h2><p>Android WebRTC最核心的类。理解这个类并了解它如何创建其他任何事情是深入了解Android中WebRTC的关键。它和我们期望的方式还是有所不同的，所以我们开始深入挖掘它。</p>
<p>首先需要初始化PeerConnectionFactory，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, we initiate the PeerConnectionFactory with</span></span><br><span class="line"><span class="comment">// our application context and some options.</span></span><br><span class="line">PeerConnectionFactory.initializeAndroidGlobals(</span><br><span class="line">    context,</span><br><span class="line">    initializeAudio,</span><br><span class="line">    initializeVideo,</span><br><span class="line">    videoCodecHwAcceleration,</span><br><span class="line">    renderEGLContext);</span><br></pre></td></tr></table></figure></p>
<p>为了理解这个方法，需要了解每个参数的意义：</p>
<p><strong>context</strong><br>应用上下文，或者上下文相关的，和其他地方传递的一样。</p>
<p><strong>initializeAudio</strong><br>是否初始化音频的布尔值。</p>
<p><strong>initializeVideo</strong><br>是否初始化视频的布尔值。跳过这两个就允许跳过请求API的相关权限，例如数据通道应用。</p>
<p><strong>videoCodecHwAcceleration</strong><br>是否允许硬件加速的布尔值。</p>
<p><strong>renderEGLContext</strong><br>用来提供支持硬件视频解码，可以在视频解码线程中创建共享EGL上下文。可以为空——在本文例子中硬件视频解码将产生yuv420帧而非texture帧。</p>
<p>initializeAndroidGlobals也是返回布尔值，true表示一切OK，false表示有失败。如果返回false是最好的练习。更多信息请参考<a href="https://code.google.com/p/webrtc/source/browse/trunk/talk/app/webrtc/java/src/org/webrtc/PeerConnectionFactory.java?r=8344&amp;spec=svn8423#64" target="_blank" rel="external">源码</a>。</p>
<p>如果一切ok，可以使用PeerConnectionFactory 的构造函数创建自己的工厂，和其他类一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> PeerConnectionFactory peerConnectionFactory = <span class="keyword">new</span> PeerConnectionFactory();</span><br></pre></td></tr></table></figure></p>
<h2 id="行动、获取媒体流、渲染">行动、获取媒体流、渲染</h2><p>有了<code>peerConnectionFactory</code>实例，就可以从用户设备获取视频和音频，最终将其渲染到屏幕上。web中可以使用<code>getUserMedia</code> 和<code>&lt;video&gt;</code>。在Android中，没有这么简单，但可以有更多选择！在Android中，我们需要了解VideoCapturerAndroid，VideoSource，VideoTrack和VideoRenderer，先从VideoCapturerAndroid开始。</p>
<h3 id="VideoCapturerAndroid">VideoCapturerAndroid</h3><p>VideoCapturerAndroid其实是一系列Camera API的封装，为访问摄像头设备的流信息提供了方便。它允许获取多个摄像头设备信息，包括前置摄像头，或者后置摄像头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="comment">// Returns the number of camera devices                       </span></span><br><span class="line"><span class="number">2</span>  VideoCapturerAndroid.getDeviceCount();                        </span><br><span class="line"><span class="number">3</span>                                                              </span><br><span class="line"><span class="number">4</span>  <span class="comment">// Returns the front face device name                         </span></span><br><span class="line"><span class="number">5</span>  VideoCapturerAndroid.getNameOfFrontFacingDevice();            </span><br><span class="line"><span class="number">6</span>  <span class="comment">// Returns the back facing device name                        </span></span><br><span class="line"><span class="number">7</span>  VideoCapturerAndroid.getNameOfBackFacingDevice();             </span><br><span class="line"><span class="number">8</span>                                                              </span><br><span class="line"><span class="number">9</span>  <span class="comment">// Creates a VideoCapturerAndroid instance for the device name</span></span><br><span class="line"><span class="number">10</span> VideoCapturerAndroid.create(name);</span><br></pre></td></tr></table></figure></p>
<p>有了包含摄像流信息的VideoCapturerAndroid实例，就可以创建从本地设备获取到的包含视频流信息的MediaStream，从而发送给另一端。但做这些之前，我们首先研究下如何将自己的视频显示到应用上面。</p>
<h3 id="VideoSource/VideoTrack">VideoSource/VideoTrack</h3><p>从VideoCapturer实例中获取一些有用信息，或者要达到最终目标————为连接端获取合适的媒体流，或者仅仅是将它渲染给用户，我们需要了解VideoSource 和 VideoTrack类。</p>
<p><a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/src/org/webrtc/VideoSource.java" target="_blank" rel="external">VideoSource</a>允许方法开启、停止设备捕获视频。这在为了延长电池寿命而禁止视频捕获的情况下比较有用。</p>
<p><a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/src/org/webrtc/VideoTrack.java" target="_blank" rel="external">VideoTrack</a> 是简单的添加VideoSource到MediaStream 对象的一个封装。</p>
<p>我们通过代码看看它们是如何一起工作的。<code>capturer</code>是VideoCapturer的实例，<code>videoConstraints</code>是MediaConstraints的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="comment">// First we create a VideoSource                                     </span></span><br><span class="line"><span class="number">2</span>  VideoSource videoSource =                                            </span><br><span class="line"><span class="number">3</span>  	       peerConnectionFactory.createVideoSource(capturer, videoConstraints);</span><br><span class="line"><span class="number">4</span>                                                                       </span><br><span class="line"><span class="number">5</span>  <span class="comment">// Once we have that, we can create our VideoTrack                   </span></span><br><span class="line"><span class="number">6</span>  <span class="comment">// Note that VIDEO_TRACK_ID can be any string that uniquely          </span></span><br><span class="line"><span class="number">7</span>  <span class="comment">// identifies that video track in your application                   </span></span><br><span class="line"><span class="number">8</span>  VideoTrack localVideoTrack =                                         </span><br><span class="line"><span class="number">9</span>  	       peerConnectionFactory.createVideoTrack(VIDEO_TRACK_ID, videoSource);</span><br></pre></td></tr></table></figure></p>
<h3 id="AudioSource/AudioTrack">AudioSource/AudioTrack</h3><p><a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/src/org/webrtc/AudioSource.java" target="_blank" rel="external">AudioSource</a>和<a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/src/org/webrtc/AudioSource.java" target="_blank" rel="external">AudioTrack</a>与VideoSource和VideoTrack相似，只是不需要AudioCapturer 来获取麦克风，<code>audioConstraints</code>是 MediaConstraints的一个实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="comment">// First we create an AudioSource                                    </span></span><br><span class="line"><span class="number">2</span>  AudioSource audioSource =                                            </span><br><span class="line"><span class="number">3</span>  	       peerConnectionFactory.createAudioSource(audioConstraints);          </span><br><span class="line"><span class="number">4</span>                                                                       </span><br><span class="line"><span class="number">5</span>  <span class="comment">// Once we have that, we can create our AudioTrack                   </span></span><br><span class="line"><span class="number">6</span>  <span class="comment">// Note that AUDIO_TRACK_ID can be any string that uniquely          </span></span><br><span class="line"><span class="number">7</span>  <span class="comment">// identifies that audio track in your application                   </span></span><br><span class="line"><span class="number">8</span>  AudioTrack localAudioTrack =                                         </span><br><span class="line"><span class="number">9</span>  	       peerConnectionFactory.createAudioTrack(AUDIO_TRACK_ID, audioSource);</span><br></pre></td></tr></table></figure></p>
<h3 id="VideoRenderer">VideoRenderer</h3><p>通过在浏览器中使用WebRTC，你肯定已经熟悉了使用<code>&lt;Video&gt;</code>标签来显示出从 getUserMedia 方法得到的 MediaStream。但在本地Android中，没有类似<code>&lt;Video&gt;</code>的标签。进入VideoRenderer，WebRTC库允许通过<code>VideoRenderer.Callbacks</code>实现自己的渲染。另外，它提供了一种非常好的默认方式VideoRendererGui。简而言之，<a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/app/webrtc/java/android/org/webrtc/VideoRendererGui.java" target="_blank" rel="external">VideoRendererGui</a>是一个<a href="https://developer.android.com/reference/android/opengl/GLSurfaceView.html" target="_blank" rel="external">GLSurfaceView</a> ，使用它可以绘制自己的视频流。我们通过代码看一下它是如何工作的，以及如何添加renderer 到 VideoTrack。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="comment">// To create our VideoRenderer, we can use the                           </span></span><br><span class="line"><span class="number">2</span>   <span class="comment">// included VideoRendererGui for simplicity                              </span></span><br><span class="line"><span class="number">3</span>   <span class="comment">// First we need to set the GLSurfaceView that it should render to       </span></span><br><span class="line"><span class="number">4</span>   GLSurfaceView videoView = (GLSurfaceView) findViewById(R.id.glview_call);</span><br><span class="line"><span class="number">5</span>                                                                            </span><br><span class="line"><span class="number">6</span>   <span class="comment">// Then we set that view, and pass a Runnable                            </span></span><br><span class="line"><span class="number">7</span>   <span class="comment">// to run once the surface is ready                                      </span></span><br><span class="line"><span class="number">8</span>   VideoRendererGui.setView(videoView, runnable);                           </span><br><span class="line"><span class="number">9</span>                                                                            </span><br><span class="line"><span class="number">10</span>  <span class="comment">// Now that VideoRendererGui is ready, we can get our VideoRenderer      </span></span><br><span class="line"><span class="number">11</span>  VideoRenderer renderer = VideoRendererGui.createGui(x, y, width, height);</span><br><span class="line"><span class="number">12</span>                                                                           </span><br><span class="line"><span class="number">13</span>  <span class="comment">// And finally, with our VideoRenderer ready, we                         </span></span><br><span class="line"><span class="number">14</span>  <span class="comment">// can add our renderer to the VideoTrack.                               </span></span><br><span class="line"><span class="number">15</span>  localVideoTrack.addRenderer(renderer);</span><br></pre></td></tr></table></figure></p>
<p>这里要说明的一点是createGui 需要四个参数。这样做是使一个单一的GLSurfaceView 渲染所有视频成为可能。但在实际使用中我们使用了多个GLSurfaceViews，这意味为了渲染正常，x、y一直是0。这让我们了解到实现过程中各个参数的意义。</p>
<h3 id="MediaConstraints">MediaConstraints</h3><p>MediaConstraints是支持不同约束的WebRTC库方式的类，可以加载到MediaStream中的音频和视频轨道。具体参考<a href="https://w3c.github.io/mediacapture-main/#idl-def-MediaTrackSupportedConstraints" target="_blank" rel="external">规范</a>查看支持列表。对于大多数需要MediaConstraints的方法，一个简单的MediaConstraints实例就可以做到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  MediaConstraints audioConstraints = <span class="keyword">new</span> MediaConstraints();</span><br></pre></td></tr></table></figure></p>
<p>要添加实际约束，可以定义<code>KeyValuePairs</code>，并将其推送到约束的<code>mandatory</code>或者<code>optional</code>list。</p>
<h3 id="MediaStream">MediaStream</h3><p>现在可以在本地看见自己了，接下来就要想办法让对方看见自己。在web开发时，对<a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_API" target="_blank" rel="external">MediaStream</a>已经很熟悉了。<code>getUserMedia</code>直接返回MediaStream ，然后将其添加到RTCPeerConnection 传送给对方。在Android上此方法也是通用的，只是我们需要自己创建MediaStream。 接下来我们就研究如何添加本地的VideoTrack 和AudioTrack来创建一个合适的MediaStream。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="comment">// We start out with an empty MediaStream object,                                             </span></span><br><span class="line"><span class="number">2</span>   <span class="comment">// created with help from our PeerConnectionFactory                                           </span></span><br><span class="line"><span class="number">3</span>   <span class="comment">// Note that LOCAL_MEDIA_STREAM_ID can be any string                                          </span></span><br><span class="line"><span class="number">4</span>   MediaStream mediaStream = peerConnectionFactory.createLocalMediaStream(LOCAL_MEDIA_STREAM_ID);</span><br><span class="line"><span class="number">5</span>                                                                                                 </span><br><span class="line"><span class="number">6</span>   <span class="comment">// Now we can add our tracks.                                                                 </span></span><br><span class="line"><span class="number">7</span>   mediaStream.addTrack(localVideoTrack);                                                        </span><br><span class="line"><span class="number">8</span>   mediaStream.addTrack(localAudioTrack);</span><br></pre></td></tr></table></figure></p>
<h2 id="Hi，有人在那里吗？">Hi，有人在那里吗？</h2><p>我们现在有了包含视频流和音频流的MediaStream实例，而且在屏幕上显示了我们漂亮的脸庞。现在就该把这些信息传送给对方了。这篇文章不会介绍如何建立自己的信号流，我们直接介绍对应的API方法，以及它们如何与web关联的。<a href="https://chromium.googlesource.com/external/webrtc/+/master/talk/examples/android/" target="_blank" rel="external">AppRTC</a>使用<a href="http://autobahn.ws/android/" target="_blank" rel="external">autobahn</a>使得WebSocket连接到信号端。我建议下载下来这个项目来仔细研究下如何在Android中建立自己的信号流。</p>
<h3 id="PeerConnection">PeerConnection</h3><p>现在我们有了自己的MediaStream，就可以开始连接远端了。幸运的是这部分和web上的处理很相似，所以如果对浏览器中的WebRTC熟悉的话，这部分就相当简单了。创建PeerConnection很简单，只需要PeerConnectionFactory的协助即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  PeerConnection peerConnection = peerConnectionFactory.createPeerConnection(</span><br><span class="line"><span class="number">2</span>  	        iceServers,                                                               </span><br><span class="line"><span class="number">3</span>  	        constraints,                                                              </span><br><span class="line"><span class="number">4</span>  	        observer);</span><br></pre></td></tr></table></figure></p>
<p>参数的作用如下：</p>
<p><strong>iceServers</strong><br>连接到外部设备或者网络时需要用到这个参数。在这里添加STUN 和 TURN 服务器就允许进行连接，即使在网络条件很差的条件下。</p>
<p><strong>constraints</strong><br>MediaConstraints的一个实例，应该包含<code>offerToRecieveAudio</code> 和 <code>offerToRecieveVideo</code></p>
<p><strong>observer</strong><br>PeerConnectionObserver实现的一个实例。</p>
<p>PeerConnection 和web上的对应API很相似，包含了addStream、addIceCandidate、createOffer、createAnswer、getLocalDescription、setRemoteDescription 和其他类似方法。下载<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection" target="_blank" rel="external">WebRTC入门</a> 来学习如何协调所有工作在两点之间建立起通讯通道，或者<a href="https://chromium.googlesource.com/external/webrtc/+/master/talk" target="_blank" rel="external">AppRTC</a>如何使得一个实时的功能完整的Android WebRTC应用工作的。我们快速浏览一下这几个重要的方法，看它们是如何工作的。</p>
<h3 id="addStream">addStream</h3><p>这个是用来将MediaStream 添加到PeerConnection中的,如同它的命名一样。如果你想要对方看到你的视频、听到你的声音，就需要用到这个方法。</p>
<h3 id="addIceCandidate">addIceCandidate</h3><p>一旦内部IceFramework发现有candidates允许其他方连接你时，就会创建<a href="http://stackoverflow.com/questions/21069983/what-are-ice-candidates-and-how-do-the-peer-connection-choose-between-them/21071464#21071464" target="_blank" rel="external">IceCandidates</a> 。当通过PeerConnectionObserver.onIceCandidate传递数据到对方时，需要通过任何一个你选择的信号通道获取到对方的IceCandidates。使用addIceCandidate 添加它们到PeerConnection，以便PeerConnection可以通过已有信息试图连接对方。</p>
<h3 id="createOffer/createAnswer">createOffer/createAnswer</h3><p>这两个方法用于原始通话的建立。如你所知，在WebRTC中，已经有了caller和callee的概念，一个是呼叫，一个是应答。createOffer是caller使用的，它需要一个sdpObserver，它允许获取和传输会话描述协议Session Description Protocol (SDP)给对方，还需要一个MediaConstraint。一旦对方得到了这个请求，它将创建一个应答并将其传输给caller。SDP是用来给对方描述期望格式的数据（如video、formats、codecs、encryption、resolution、 size等）。一旦caller收到这个应答信息，双方就相互建立的通信需求达成了一致，如视频、音频、解码器等。</p>
<h3 id="setLocalDescription/setRemoteDescription">setLocalDescription/setRemoteDescription</h3><p>这个是用来设置createOffer和createAnswer产生的SDP数据的，包含从远端获取到的数据。它允许内部PeerConnection 配置链接以便一旦开始传输音频和视频就可以开始真正工作。</p>
<h3 id="PeerConnectionObserver">PeerConnectionObserver</h3><p>这个接口提供了一种监测PeerConnection事件的方法，例如收到MediaStream时，或者发现iceCandidates 时，或者需要重新建立通讯时。这些在功能上与web相对应，如果你学习过相关web开发理解这个不会很困难，或者学习<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection" target="_blank" rel="external">WebRTC入门</a>。这个接口必须被实现，以便你可以有效处理收到的事件，例如当对方变为可见时，向他们发送信号iceCandidates。</p>
<h2 id="结束语">结束语</h2><p>如上所述，如果你了解了如何与web相对应，Android上面的API是非常简单易懂的。有了以上这些工具，我们就可以开发出一个WebRTC相关产品，立即部署到数十亿设备上。</p>
<p>WebRTC打开了人与人之间的通讯，对开发者免费，对终端用户免费。 它不仅仅提供了视频聊天，还有其他应用，比如健康服务、低延迟文件传输、种子下载、甚至游戏应用。</p>
<p>想要看到一个真正的WebRTC应用实例，请下载<a href="https://play.google.com/store/apps/details?id=appear.in.app&amp;referrer=utm_source%3Dtech.appear.in%26utm_medium%3Dblog%26utm_campaign%3Dandroid-launch-may15" target="_blank" rel="external">Android</a>或<a href="https://itunes.apple.com/app/apple-store/id878583078?pt=1259761&amp;ct=tech.appear.in&amp;mt=8" target="_blank" rel="external">ios</a>版的appear.in。它在浏览器和本地应用间运行的相当完美，在同一个房间内最多可以8个人免费使用。不需要安装和注册。</p>
<p>现在就发挥你们的潜力，开发出更多新的应用！</p>
<blockquote>
<ul>
<li>原文链接 : <a href="https://tech.appear.in/2015/05/25/Introduction-to-WebRTC-on-Android/" target="_blank" rel="external">Introduction to WebRTC on Android</a></li>
<li>原文作者 : <a href="https://disqus.com/home/forums/appearin/" target="_blank" rel="external">Dag-Inge Aas</a></li>
<li>译文出自 : <a href="https://tech.appear.in/" target="_blank" rel="external">appear.in</a></li>
<li>译者 : <a href="https://github.com/DorisMinmin" target="_blank" rel="external">DorisMinmin</a> </li>
<li>状态 ：完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>WebRTC被誉为是web长期开源开发的一个新启元，是近年来web开发的最重要创新。WebRTC允许Web开发者在其web应用中添加视频聊天或者点对点数据传输，不需要复杂的代码或者昂贵的配置。目前支持Chrome、Firefox和Opera，后续会支持更多的浏览器，它有能力达到数十亿的设备。<br>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列6]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-6/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-6/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:25:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="避免文件路径的硬编码">避免文件路径的硬编码</h2><p>尽量从上context或者Environment中获取</p>
<ul>
<li><p>不要硬编码全局的路径”/sdcard”，使用Environment.getExternalStorageDirectory() 或者相关的方法替代</p>
</li>
<li><p>不要硬编码应用路径： “/data/data/myapp/databases”, 使用 Context.getDatabasePath(), Context.getFilesDir()或者相关的方法替代</p>
<a id="more"></a>
<h2 id="只持久化相对路径">只持久化相对路径</h2></li>
</ul>
<p>当你需要持久化某个路径的时候，为了防止路径的变化，你应该使用相对路径。比如你的应用的备份需要恢复到一个新的设备上，数据路径就可能有些不同。</p>
<p>比如通过Context.getFilesDir() 方法返回的路径在不同的设备，用户或者配置时发生变化。因此在运行期间只通过相对路径构造绝对路径是最安全的。</p>
<p>避免过重的标准化以免出现特定的安全情况。</p>
<h2 id="对临时文件使用缓存存储">对临时文件使用缓存存储</h2><p>通过Context.getCacheDir(). 返回的缓存目录将应用的临时文件从其它的持久化数据中分离出来。下面是更高效的存储的建议：</p>
<ul>
<li><p>缓存目录的文件在内存不足的情况下可能会被系统删除掉，不像在data目录下的文件只有在应用被卸载或者用户明确请求清除应用数据的时候才会被删除。</p>
</li>
<li><p>cache目录的文件从来不会被备份，不像data目录下的文件可能会自动备份</p>
</li>
</ul>
<h2 id="简单的需求避免使用SQLite">简单的需求避免使用SQLite</h2><p>SQLite是一个完全的关系型数据引擎，对于不需要维护关系的简单的数据结构或者key/value 键值对来说是过度的使用。事务的完整性在每次I/O操作中很重要，但是如果你不需要它们，就会让你的应用更慢。</p>
<p>如果你的数据很简单，考虑以下替换：</p>
<ul>
<li><p>简单的key values 使用SharedPreferences存储。首先它们在第一次读取之后会被静态的缓存。这样加速了访问速度，但是如果你使用过于复杂可能导致泄漏和内存的问题。第二，commit的变化会导致整个SharedPreferences结构的重写，因此小而频繁的更新所做的工作可能会比期望的更多。</p>
</li>
<li><p>当需要存储一些时序事件的数据时，使用只会在尾部添加的log文件，并定时处理它</p>
</li>
<li><p>如果你需要的只是NoSQL，并且能够正确的，最小化的使用JNI，你可以使用<a href="https://github.com/google/leveldb" target="_blank" rel="external">LevelDB</a></p>
</li>
</ul>
<h2 id="避免使用太多的数据库">避免使用太多的数据库</h2><p>SQLite数据库在硬盘和内存中都是比较耗资源的。不要为每一个表单独创建一个独立的DB。大多数应用应该只有一个DB。</p>
<h2 id="让用户选择内容的存储位置">让用户选择内容的存储位置</h2><p>设备通常有多个存储位置，包括多个SDCard，USB驱动以及云存储。通过<a href="">Storage Access Framework</a>让用户去选择打开或者存储数据的位置.</p>
<p>可以启动简单的intents去提示用户打开或者保存一个文件，接收一个content:// UIR准备数据存储。当需要一个传统样式的文件API时，<a href="https://developer.android.com/reference/android/support/v4/provider/DocumentFile.html" target="_blank" rel="external">DocumentFile</a>support library类可以更容易的适应现有的代码。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-6-storage/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-6-storage/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-vi-c0b1539f0e98" target="_blank" rel="external">Developing for Android VI The Rules: Storage</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="避免文件路径的硬编码">避免文件路径的硬编码</h2><p>尽量从上context或者Environment中获取</p>
<ul>
<li><p>不要硬编码全局的路径”/sdcard”，使用Environment.getExternalStorageDirectory() 或者相关的方法替代</p>
</li>
<li><p>不要硬编码应用路径： “/data/data/myapp/databases”, 使用 Context.getDatabasePath(), Context.getFilesDir()或者相关的方法替代</p>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列1]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-1/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-1/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:19:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>前几天在G+上看到Google Developers站点，有一个Android系列的文章，分享到个人微博，周末闲来没事就学写了下，把它们简单的翻译了下，没想到一发不可收拾，六篇文章全部都翻译完了，有些地方省略了部分示例的描述或者换了另一种表述，如果有理解的不准确的地方，还望指正<br><a id="more"></a></p>
<hr>
<h2 id="context或者这些建议为何如此重要">context或者这些建议为何如此重要</h2><p>对于理解这些最佳实践的相关上下文是非常重要的。特别是明白移动端存在一些严重的限制，和台式机以及服务器端的计算是完全不同的。因此，在开发应用的时候，如果没有将这些限制考虑进去，将会导致很大的性能问题和内存消耗，这不是针对于某一个应用而言，而是针对整个设备，因为很多拥有相同性能问题的app共同导致了一个性能很差的设备。<br>以下使一些重要的约束，限制和现实，在过去以及将来的移动设备中都很重要。</p>
<h2 id="内存">内存</h2><p>移动设备的内存是很有限的。当然不是指所有的设备，不过对于大多数的移动系统是这样的。对于开发者来说，我们使用的手机可能是比大多数用户现在或者将来所使用的设备更快更好，也更新。比如，拥有一个带有 1GB－2GB内存Nexus 5对于我们来说是比较合理的，512M的内存配置的手机在美国以及一些新兴的低端市场是很常见的。因此，以2GB或者更大内存的标准去衡量一个App是不现实的。<br>明白Android会运行多个Activity和多个并行的Service也是很重要的。在最近App列表中切换而不是重新启动一个App的方式对于创造出一种很好的体验是非常重要的。但是这样意味着如果这些app消耗了比它们本应该消耗的更多内存，那么留给其它的应用的系统内存就很少了。如果这种低内存情况发生，应用就不能保留在后台，系统会干掉app的进程，用户就被迫以重新启动的方式去开启一个App，显然这样的体验就比较差。</p>
<h2 id="CPU">CPU</h2><p>即使最高级别的移动设备的CPU也要远远比台式设备的CPU慢。当然即使你意识到了这一点，你也应该考虑那些大多数使用了比你更慢的CPU的用户。适用于内存的建议也同样适用于CPU：世界范围的低端设备一直在售卖，因此不要以你自己相对较好的设备的性能为基准，因为跑在那些大多数拥有较慢处理器和更低内存配置的设备上的差别是非常大的。<br>另一个问题是，CPU的处理器是不会一直保持在最大的速度的。当系统认为电池的发热程度达到了临界点的时候，就会导致CPU降频。一般来说，这些情况发生的时候用户可能不会注意到，比如屏幕关闭了，或者输入事件不响应了，或者动画不再运行了。降频对App来说有两层含意：(1)你的app可能在很多情况下降低运转速度，因此，即使是一个不错的CPU，你也只能够获取一个有限的速度 (2)你的app可能做了一些操作导致CPU无法降频，使得CPU始终维持在处理速度最大化的状态（比如，频繁，长时间或者无休止的动画应该被避免，因为在动画期间，为了让动画更加流畅，系统将试图以最大的功率来运行）。显然，你不想去权衡较高的CPU速率和使用对降低电池的使用寿命的影响，因此当你不需要的时候，尽量避免它们。<br><a id="more"></a></p>
<h2 id="GPU">GPU</h2><p>GPU性能的建议类似于CPU，当然还有些额外需要注意的地方：</p>
<ul>
<li><p>上传是消耗资源的<br>在任何系统上上传大大纹理（bitmap）都是比较消耗资源的，bitmap越大，操作时间越长。因此，这意味着频繁大进行bitmap相关大图形化操作会导致性能问题，比如bitmap，paths（会被光栅化到Bitmap中），和大量到新的或者不同的text（有种问题是大量的非英文的字符集合的导致的问题）</p>
</li>
<li><p>我们通常面临的问题并不是几何的绘制，甚至一些纹理的绘制，而是大量的像素填充到高分辨率的设备上。这些高分辨率的屏幕会导致一个性能问题，因为在动画某一帧中硬件不能够填充如此多的像素。比较常见的是过渡绘制，由于重叠的内容，比如window背景，内容背景和一些半透明的View，就会导致应用会多次重绘同一块区域。</p>
</li>
</ul>
<h2 id="内存_==_性能">内存 == 性能</h2><p>在这个系列中，很多的指导会围绕着内存的使用来讨论。但有一点很重要，就是内存是和运行期间的性能以及电池的寿命是紧紧关联的。因为你分配的内存越多，设备就要为你的应用做更多的工作。内存分配和回收增加了运行期间的活动会。大的heap内存意味着你的你的app占用了更多的内存，但是设备总体的内存是减少了，会导致其它的活动被迫减少自己的内存开销，或者直接被kill掉，这样将导致设备的总体性能，因为用户会在不同的活动中切换，而这些Activity需要重新启动。更的的Heaps也会导致更长时间的GC中断，因为一个较大的heap内存会导致内存的分配和回收消耗更长的时间。这些所有的行为都会消耗更多的电量，因为设备所做的工作越多，电池就会消耗越多也更有限。</p>
<p>因此这个系列的文章很多涉及到了性能问题，事实就是这些技术对于写出一个好的App来讲，是非常重要的。</p>
<p>因此这篇文档的最佳实践所涉及到的点不是内存就是性能，这些技术也是能够写出一个好的app所必须的。</p>
<h2 id="低端设备">低端设备</h2><p>上面很多部分也提到，就是开发者所使用的设备可能比大多数未来使用者的设备都要好。虽然在2015年2GB已经是主流，但是很多在世界范围的很多新兴市场仍然卖着512M的设备。</p>
<h2 id="更平滑的帧率">更平滑的帧率</h2><p>对于Android的最佳体验是低于16毫秒的帧率。也就是说应用必须在16毫秒内完成所有的输入，布局，绘制和其它所有的事情。这个速度允许系统在动画和输入事件的过程中以60帧美妙的速度渲染。动画必须能在60帧率的时间内完成必要部分的重绘已完成平滑的动效。问题更多的是，很多应用通常可以在16ms内完成渲染，但它丢弃了当前帧，并且之后不能够延续之前的帧率，这种不连续的间隔会容易会引起用户的注意。</p>
<p>平滑的完成一帧意味着任何特殊的帧需要执行所有的渲染代码（包括framework发送给GPU和CPU绘制到缓冲区的命令）都要在16ms内完成。这也就是为什么即使在垃圾回收事件中丢失了5ms也会有很大的影响。因为它严重限制了一帧时间内剩余的绘制时间。越接近16ms，在垃圾回收事件触发的时候，就越容易导致卡顿。</p>
<p>缓冲区只能够在</p>
<h2 id="运行期">运行期</h2><p>有两个运行环境需要主要：Dalvik和ART。在5.0版本之前，Android使用Dalvik。开发者可以在4.4版本中选择ART进行测试。但是它只会在5.0的系统中运行。</p>
<p>Dalvik是采用的时 JIT编译器，能够执行一些细微的优化，但是和其它的很多JIT编译器是不同的。ART是一个Ahead-of-Time 编译器，比Dalvik会做更多的优化。然而，不论是Dalvik还是ART提供的优化水平与服务器和台式机运行平台都是不一样的。比如方法的内联和escape analysis。有一些内联，ART会在叶子方法上执行，但是更进一步的优化只可能在将来的版本中出现，因为未来会有新的优化编译器。由于app开发者可能需要支持老得版本，他们需要继续关心现在和之前编译器的限制。</p>
<p>通常，ART性能要比Dalvik提升30 - 200+%。ART的编译器会执行更多的优化，比如，实质性的提升接口的分发。ART优化的范围要更大些，内存分配也更快。最终，应用的线程会更少的受限于垃圾回收，短时间的中断次数也会减少。</p>
<h2 id="垃圾回收器">垃圾回收器</h2><p>垃圾回收器是一个通过运行期间释放那些不再引用的内存的过程。GC也是导致严重性能问题的原因之一，如果GC所做的工作超过了那些必须的工作，那么留给应用平滑的帧率的时间就越少。</p>
<p>在Dalvik和ART中的垃圾回收器实质上是不同的。一个主要的区别就是Dalvik不是一个移动的回收器。就是说所有的分配对象都将呆在Heap的同一个地方，这对于Dalvik来说，为新的对象找到可分配的内存就会更加困难和耗时，特别是当Heap颗粒化和碎片化并且又有大量对象急需内存的时候。Heap碎片化也会导致GC更频繁的中断，因为Dalvik会尝试清理从那些无用的heap。这些GC中断是非常消耗资源的，并且在正常的情况下一个比较快的手机也会很容易耗费掉10-20ms的时间。很重要的是，垃圾回收的时间与在堆中对象的数量成正比,这是尽可能避免分配对象的另一个原因。</p>
<p>ART会动态的提升垃圾回收的效率。比如，ART是一个移动的垃圾回收器，在应用长时间单中止时，它会让heap变得紧凑而不会影响用户的体验。而且，这里有一些独立的专门用于大对象的heap，比如像bitmap这样的对象，ART就会更快的找到内存，而不是有序的遍历碎片化的heap。在ART中的中断，通常在2-3ms间。</p>
<p>尽管ART相对于Dalvik来说的垃圾回收来说有一个很大的性能提升。但是在写Android app的时候，仍然需要注意的是即使是2-3ms的时间对于超过16ms帧率的界限也是足够的。因此，尽管垃圾回收在5.0之后不再是耗资源的行为，但也是始终需要尽可能避免的，特别是在执行动画的情况下，可能会导致一些让用户明显感觉的丢帧。</p>
<h2 id="UI_Thread">UI Thread</h2><p>很多的性能和卡顿问题是由于我们在UI线程中做了大量的工作。Android是一个独立线程的UI系统，在这里所有发生在View上的操作，包括View的绘制，都发生在Activity的UI线程上。任何发生在相同UI线程的操作，即使是View的绘制也可能导致卡顿，因为它没有时间在16ms的时间内达到一个平滑的帧率。</p>
<p>在5.0版本里，framework引入了“Render Thread”，用于向GPU发送实际渲染的操作。这个线程减轻了一些UI Thread减少的操作。但是输入，滚动和动画仍然在UI thread，因为thread必须能够响应操作。</p>
<h2 id="存储">存储</h2><p>存储的指标在不同的Android设备上是不同的，但是可能是比较慢而且是受限制的。移动设备只有8G（2015年，在低于中等水平的设备中很常见）甚至4G搭配一个SDcard，去存储整个系统，所有的应用以及所有的音频，很容易就满了。在这种情况下，一个app可能导致用户为它删除其它内容以便获取更多空间，或者因为每有足够的空间就直接卸载它。</p>
<p>存储性能也是需要关心的点。移动设备和桌面设备的硬盘相比是完全不同的。</p>
<p>同时，也要注意到外部存储SDcard的内存在I/O性能上可能有很大的不确定性，其依赖于供应商，芯片和速度指标。但是App不应该阻止用户使用SDcard，因为很多设备确实内存比较小，需要它作为扩展。</p>
<h2 id="网络">网络</h2><p>位于在城市中的大多数软件开发者来说拥有一些现代的基础设施和移动网络是很简单的。但很多其它地区并不具备这样的设施。更别说LTE或4G了。很多国家的地区还是2G的网络而且可能还要承受大量数据的传输。这样就会导致两个通用的问题：</p>
<ul>
<li><p><strong>依赖于快速的网络速度</strong><br>App严重依赖大媒体数据（Video，audio，images）在网络基础较差的地方可能没有选择。但是避免下载，直到条件允许的情况下再去下载也是App体验的一部分</p>
</li>
<li><p><strong>多度同步</strong><br>也许你的App希望更新一些信息，但是用户并不需要它，更重要的问题，设备并不应该承受所有应用程序与网络不断交互的情况。这种动态会很容易地使设备持续工作而不能够进行休眠,最终影响电池的续航。</p>
</li>
</ul>
<h2 id="每一个设备都是一个村落">每一个设备都是一个村落</h2><p>用户的设备上会安装很多的应用，包括系统的UI和Launcher App。如果你的App使用了越多的资源（内存，CPU，GPU，电池），那么其它应用就会越少，那么呈现给的用户的设备就会越差。<code>如果你的处理越多，当系统需要更多内存的时候，就越有可能试图从内存中干掉它</code>，那就意味着你的App就要花费更长时间去开启，从而导致一种很不好的体验。</p>
<p>因此，在Android设备上成为一个良好的公民吧。也是每个App应该去做的，因为如果每个应用都贪婪，那么最终痛苦是设备和用户。</p>
<h2 id="平民的灾难">平民的灾难</h2><p>移动设备最大的问题是一些app在自己感兴趣的情况下活动导致了设备的整体性能和体验。分析特定app可能不是应用需要修复的标志性的问题。但是对设备整体的影响，所有的app都遭受资源的限制，最终用户的体验很差。</p>
<p>一个好的例子是观察某个应用是否太频繁的同步。那意味着特定的应用在以特定的频率访问服务器。但是如果用户有超过100个应用都在这样做，相比较那些延迟，批处理的同步系统来说，结果就是设备将永远不能够休眠并且很快耗完电。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-1-mobile-context/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-1-mobile-context/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-i-understanding-the-mobile-context-fd2351b131f8" target="_blank" rel="external">Developing for Android, I:Understanding the Mobile Context</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>前几天在G+上看到Google Developers站点，有一个Android系列的文章，分享到个人微博，周末闲来没事就学写了下，把它们简单的翻译了下，没想到一发不可收拾，六篇文章全部都翻译完了，有些地方省略了部分示例的描述或者换了另一种表述，如果有理解的不准确的地方，还望指正<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列2]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-2/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:27:20.000Z</updated>
    <content type="html"><![CDATA[<p>在决定应用的行为，是否有好的用户体验以及整体的设备体验来说，内存的使用可能是独立因素中最重要的。内存因素包括应用的内存占用，以及内存搅动（导致的垃圾回收会对运行期间的性能有影响）。<br><a id="more"></a></p>
<h2 id="避免在循环中分配内存">避免在循环中分配内存</h2><p>内存分配虽然不可避免，但是应尽可能的避免，特别是在平凡的调用的代码块中。比如在绘制代码中，因为每一帧的渲染都会执行该方法。</p>
<p>避免在自定义View的onDraw方法中分配内存，因为动画也许会调用它。使用缓存对象替换临时对象可以避免新的内存开销。典型的例子就是在onDraw方法中分配了一个新的Paint对象，因为Canvas需要一个Paint对象。对于这种自定义View的实例只分配一个独立的Paint对象而后在onDraw方法中临时使用更好。</p>
<h2 id="尽可能的避免内存分配">尽可能的避免内存分配</h2><p>避免常量，临时变量的内存分配。下面有一些可参考的策略，也许并不适用于传统的java编码，但是对于Android开发是推荐的。通常可以使用工具帮助我们去决定是否某一块代码需要优化。如果代码的某一部分很少执行（比如用户改变一些设置的操作），更简洁和传统的抽象层是不错的选择。但是如果分析表明某些代码频繁执行并导致了大量的内存搅动，考虑以下策略：</p>
<ul>
<li><p><strong>对象缓存</strong><br>重用对象在一些常量内存的再分配中很有用，比如在内部循环中避免内存分配。比如，有些频繁调用的方法中可能需要一个Rect对象存储一些中间值，最好在把Rect作为类级别的常量，只分配一次内存，甚至是静态的，避免每次方法调用的时候都分配。关于单例的一些警示对于这种方式也是适用的，在Android上，静态的常见缺陷就是它们对于某一个进程是静态的，但是可能有多个活动在同一进程中。小心应用，这种技术在避免内存的再分配中是通用的</p>
</li>
<li><p><strong>对象池</strong><br>如果代码临时需要同一种类型的多个对象，考虑适用对象池而不是频繁的分配内存。但对象池可能不容易管理。如果对象有状态并且又是被任意线程访问的情况，要注意一些并发性的问题。在内存压力方面也有问题（可以使用LruCache策略），对象的增加存在着内存泄漏的风险，因此当你使用对象池的时候注意这些问题，考虑只在特定的情况下使用它。如果这种策略在那些内存配置低低老版本或者设备上非常有用，你应该通过API版本或者isLowRamDevice()方法来检测对象池的使用限制</p>
</li>
<li><p><strong>Arrays</strong><br>ArrayList是一种很便利的集合也不会造成太多的分配。它会再分配，并且会复制当前的数组添加到列表后面，但是设置一个合理的初始化容量可以避免频繁的分配内存。如果你的集合不需要动态的变化大小，考虑使用Array</p>
</li>
<li><p><strong>Andorid集合类</strong><br>除非你需要一个map去存储大量的数据，否则考虑使用ArrayMap或者是SimpleArayMap作为数据结构而不是HashMap。这些类是经过优化的，相对于HashMap会有更高的内存效率以及更少的GC压力，这样的数据结构在移动设备上能够更好的满足通用的使用情景（另外它们也支持实体的遍历而不使用Iterator）。当然，考虑设置一个恰当的初始容量去避免自动扩容</p>
</li>
<li><p><strong>需要修改对象的方法</strong><br>这种情况你不应该不要返回一个新的对象，考虑将该对象作为参数传入进来，去修改该对象：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rect <span class="title">getRect</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br></pre></td></tr></table></figure>
<p>考虑使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRect</span><span class="params">(Rect rect, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>当原始类型可以满足时避免使用对象类型</strong> 使用Integer，Float而不是int，float时，会导致内存分配，自动装箱以及更多对象自身内存的分配。比如，如果你的方法中一个Integer，然后代码调用附带了一个int，由于自动装箱，将会导致一个内存分配。带有传统类型的集合类和泛型可能不可避免的，但是当原始类型可以搞定的时候应该避免包装类型。Android中提供了一些像SparseIntArray和SparseLongArray的集合类，它们内部使用的就是原始类型而不是对象类型。</li>
<li><strong>避免对象数组</strong> 如果你有一组简单的数据对象，可以考虑将每一个字段存储到数组中。比如，假设你绘制的时候需要追踪一些之前的touch X/Y的point数据。你应该使用两个int[]来保存它们，一个用于存储X坐标值，另一个用于存储Y坐标值，而不是使用一个Point[]。这样不仅仅减少了原始对象的个数（节省了内存），也增加了数据的局部性，可以更好的利用宝贵的内存和CPU的缓存。</li>
</ul>
<h2 id="避免Interators">避免Interators</h2><p>明确的(<code>List.iterator()</code>)或者不明确的(<code>for(Object o : myObjects)</code>)使用Interator会导致一个Interator对象的内存分配。单独一个内存分配不是什么大事，但是应该尽量避免在内部循环中分配内存。当然，直接的使用角标进行集合遍历可以不用分配任何的内存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> count = myList.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    Object o = myList.get(i);</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，Interator总会导致一个内存的分配，即使是空集合。因此，如果当你非要使用foreach的时候，应该在遍历集合的之前可以进行一次isEmpty的检验。</p>
<h2 id="避免枚举">避免枚举</h2><p>枚举通常可以用来代表常量，但是会比原始类型耗费更多，它涉及到代码量的大小和枚举对象内存的分配。</p>
<p>一个临时的枚举不会造成较大的内存消耗。但是Proguard会，在一些情况下他会进行一些静态的分析所有的代码，将枚举优化为int值。当枚举在整个应用中被被广泛的使用或者当一个library或某个API中的枚举被其它很多应用使用的时候时就是问题了，甚至会很糟糕。</p>
<p>使用AndioStudio1.3版本中的<code>@IntDef</code>注解能够保证你的代码在build时期是类型安全的（当lint error开启的时候）。因此使用int变量对于性能和代码量都会更好。</p>
<h2 id="避免非移动应用的Frameworks和Libraries">避免非移动应用的Frameworks和Libraries</h2><p>有时会使用一些熟悉的java平台的一些框架，比如注解依赖的Guice。但是它并没有为移动应用进行优化，使用它们将会导致一些问题。</p>
<p>如果你只是使用了某个Library中的一小部分，你可以试着将那一部分抽取出来。即使Proguard在很多情况下可以跳过那些不用的代码，但是在大的library的依赖图可能会导致优化失败（也会大大增加Proguard的build时间）。</p>
<p>有一些libraries虽然被引入到Android应用中，但是你不应该随意使用，除非很熟悉它，知道它可能为应用带来的问题。</p>
<p>还有些问题就是使用那些非移动的框架和库可能会增加内存的开销。你可以通过监视内存的使用和垃圾回收器的行为来检测它们导致的问题程度。</p>
<h2 id="避免静态的内存泄漏">避免静态的内存泄漏</h2><p>对于避免临时的内存分配使用static对象很有用。但是应该注意使用静态变量去缓存对象时，它们实际上不应该一直存在整个进程的生命周期中。特别的，这些static的变量不应该和Activity的生命周期一致。比如，当屏幕方向改变的时候Activity会destroy并recreate，但是static变量持有Activity的引用，这样会导致内存泄漏。Activities是非常耗资源的，这种内存泄漏很快会导致你的应用和系统OOM。</p>
<h2 id="避免Finalizers">避免Finalizers</h2><p>因为和java语言的席位差别，finalizers需要的不是一个垃圾回收器，而是两个。这就意味着不仅资源会被finalizer会被冻住直到两个垃圾回收器都触发的时候，而且系统中同时运行两个垃圾回收器也会导致资源消耗和卡顿。有一种特殊情况需要finalization，当你的对象持有一个本地的指针时。如果没有这样的情况，就可以完全避免finalizers。</p>
<p>如果你确实需要finalizers，考虑实现AutoCloseable接口并且在你的代码域内通过close方法释放所有的资源。</p>
<h2 id="避免过度的静态初始化">避免过度的静态初始化</h2><p>在你的应用中一些重要的时间内（比如启动的时候），过多的初始化可能导致性能的问题和较差的用户体验。可以在你需要它的时候再去加载代码。</p>
<h2 id="通过命令释放缓存">通过命令释放缓存</h2><p>从API 14，<a href="http://developer.android.com/reference/android/content/ComponentCallbacks2.html" target="_blank" rel="external">ComponentCallbacks2</a>提供了onTrimMemory()回调方法允许你的app在较低内存压力的情况下释放内存。更多详情可以参考Google I/O 2012的Video <a href="https://www.youtube.com/watch?v=gbQb1PVjfqM&amp;t=4m" target="_blank" rel="external">Doing More with Less</a>，展示了一个如何LruCache处理bitmap的例子。</p>
<h2 id="使用_isLowRamDevice()">使用 isLowRamDevice()</h2><p>KitKat版本中出现的ActivityManager.isLowRamDevice()方法可以帮助你检测应用运行时的内存限制.当你的应用中有一些特性比较好内存的时候，可以通过这种方式去检测内存是否可以满足你的特性，然后决定是否开启。</p>
<h2 id="避免请求较大的Heap内存">避免请求较大的Heap内存</h2><p>应用可以通过在mainfest文件中设置application tag来开启请求较大heap内存的功能，但是你不应该这么做。请求一个大的Heap的行为可能着该应用只考虑到自己的需求，但是对于整个设备度体验来说是一个错误度决定。</p>
<p>请求大的Heap在很少的情况下可能是必要的，比如media内容的处理。但是应用使用该功能只是为了更好的管理内存和资源而不是导致整个设备的用户体验变得更差。应用请求较大的heap将会导致设备上其它的进程拥有更少的内存，用户在切换activity的时候就有可能导致其它应用被kill掉然后重启。</p>
<h2 id="避免在必要情况外过长的运行service">避免在必要情况外过长的运行service</h2><p>每一个进程在系统中都有一个资源的限制。如果你不需要service在后台一致运行，就及时将它关闭。</p>
<p>Android提供了很多机制来确保组件只在特定的范围内运行：</p>
<ul>
<li>使用BroadcastReceiver去接收那些重要但是不频繁的事件，而不是使用一个大多数时间都无用的Service，比如network状态变化或者alarm。App可以在不需要但时候 关闭BroadcastReceivers，以至于系统只在需要的时候才被唤醒。</li>
<li>使用IntentService实现一个service，这样的service会在任务栈为空的时候自动关闭</li>
</ul>
<h2 id="优化代码大小">优化代码大小</h2><p>瘦身的应用会运行更快。加载的代码量越少,用户下载你的app的时间就会越少，你的应用也会更快的启动和初始化。下面是一些建议：</p>
<ul>
<li>使用Proguard剔除无用的代码。使用Gradle也可以，而且它还会从你依赖的libraries中剔除那些无用的代码</li>
<li>谨慎依赖 当你只是需要某一种指定的数据类型的时候不要使用那些拥有各种集合较大的library。</li>
<li>确保你自己理解那些自动化生成代码的消耗</li>
<li>越简单越好，直接解决问题，而不是创造出大量的结构和抽象去解决问题</li>
</ul>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-2-memory/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-2-memory/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-ii-bb9a51f8c8b9" target="_blank" rel="external">Developing for Android, II The Rules: Memory</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在决定应用的行为，是否有好的用户体验以及整体的设备体验来说，内存的使用可能是独立因素中最重要的。内存因素包括应用的内存占用，以及内存搅动（导致的垃圾回收会对运行期间的性能有影响）。<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列7]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-7/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-7/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:24:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="避免选择应用组件搭建架构">避免选择应用组件搭建架构</h2><p>应用组件（activities, services, providers, receivers)是你与操作系统交互的接口但是不要将它们看作是搭建整个应用架构的基础工具。每一个组件在系统中有自己特定语境，通常也只应该有需要的时候才使用：<br><a id="more"></a></p>
<ul>
<li><p><strong>Activity</strong> 应用顶级的UI实体。它相当于传统操作系统中的main函数 （当用户点击应用icon的时候运行）。当你希望其它应用启动你应用的特定部分的时候才应该使用Activity来实现它。比如执行一个分享的操作或者打开应用中的一些内容时。如果你只是从自己的应用中去获取一个UI的时候，没有必要通过Activity来实现它，你也可以只转变当前UI的状态（比如通过fragments）。在fragments出现之前一个应用的架构可能通过多个activities来实现是比较常见的，但是现在已经是不必要的了，除非你需要特定的设计。</p>
</li>
<li><p><strong>Service</strong> 一个用于在Activity UI 之外执行一个长时间的操作的服务。它可以自启动（通过Context.startService()）或者运行在另一个进程中（Context.bindService()），如果这些行为你都不需要，那么你就不应该使用Service。</p>
</li>
</ul>
<p>比如你需要后台工作但是不需要自启动（下载UI需要的内容，可以在用户重新回到UI的时候resume），你应该使用本地线程的原始类，比如： AsyncTask, Loader, HandlerThread, 等等。service是资源敏感的（需要作为全局状态的一部分被一直追踪），而且当你的应用不需要service的时候它还在后台运行，可能导致一些bug（这是Android中常见的问题，而且对系统是有害的）。如果你需要将同一进程的代码关联起来，不要使用bindSerice()，使用简单的callbacks和其它工具就可以。因为它们更容易编码也更容易理解，并且资源耗费更少。当然你要理解AsyncTask的异步特性，当Activity finish掉之后结果才返回的情况也是有可能的。在使用结果时请check Activity的状态。</p>
<p>-Broadcast Receiver 关注感兴趣的特定事件，在事件发生的时候会自动唤起 。</p>
<h2 id="Services要么被绑定要么自启动">Services要么被绑定要么自启动</h2><p>Service要么是作为一个被绑定的服务，要么是一个自发起的服务，避免两者同时出现。</p>
<p>如果有必要，一个绑定的service为了继续在后台执行可以自启动，但是当工作完成的时候也要finish掉自己。（额外的start-service产生的冲突可能会导致一些错误）</p>
<h2 id="独立的事件优先选择Broadcast而不是Service">独立的事件优先选择Broadcast而不是Service</h2><p>使用broadcasts去分发独立的事件，使用service处理那些生命周期较长的事件。</p>
<h2 id="避免通过Binder传递大对象">避免通过Binder传递大对象</h2><p>为了通过Binder进行序列化，对象需要被复制，因此对象越大，传递过程的处理时间就越长。</p>
<h2 id="将UI处理从后台service中区分开来">将UI处理从后台service中区分开来</h2><p>当系统资源受限的时候activity manager会将activities干掉。如果你的activity与后台的任务绑定的太近，那么其中一者挂掉，另外一者也同样不可用了。一个好的例子是music 应用将UI和播放内容的service分离开来，UI activity可能被干掉，但不会引起后台service继续音乐的播放。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-7-framework/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-7-framework/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-vii-the-rules-framework-concerns-d0210e52eee3" target="_blank" rel="external">Developing for Android VII The Rules: Framework</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="避免选择应用组件搭建架构">避免选择应用组件搭建架构</h2><p>应用组件（activities, services, providers, receivers)是你与操作系统交互的接口但是不要将它们看作是搭建整个应用架构的基础工具。每一个组件在系统中有自己特定语境，通常也只应该有需要的时候才使用：<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列3]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-3/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-3/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:27:02.000Z</updated>
    <content type="html"><![CDATA[<p>在Android中，性能和内存的关系很密切，因为系统的整体内存大小会影响所有进程的性能，因为垃圾回收器会对运行期间的性能产生很大的影响。下面的重点是运行期间的性能问题而不是内存。<br><a id="more"></a></p>
<h2 id="避免在动画和交互期间繁重的操作">避免在动画和交互期间繁重的操作</h2><p>正如在第一篇文章中提到过的，在UI Thread做繁重的操作会影响到渲染的处理。同样会导致动画的问题，因为它依赖于每一帧的渲染。这就意味着在动画期间避免在UI进行繁重的操作就更加重要。以下是一些可以避免的常见情况：</p>
<ul>
<li><p><strong>Layout</strong><br>Measurement 和 layout是比较繁重的操作，view的层级越复杂，操作就会越繁重。Measurement和layout是在UI Thred发发生的。因此当系统需要运行一个动画的时候紧接着还需进行layout，而它们都是在同一个线程，因此动画的流畅度可能就会受到影响。<br>假设你的动画在13ms内就可以完成所有的渲染，在16帧率之内。然后某一请求导致了layout，花费了5ms的时间。该layout在下一帧绘制前会发生，那么总的绘制时间就会达到18ms，最终你的动画就明显的跳过一帧。当动画过程中需要进行layout的时候，为了避免这种情况，可以在动画启动前进行layout或者延迟layout到动画完成。当然，尽量为那些不会触发layout的属性添加动画。比如，View的<code>translationX</code>和<code>tanshlationY</code>属性影响到post-layout属性。LayoutParams 属性也会需要请求layout操作，因此对这些属性进行动画的时候在相对复杂的UI上会导致卡顿。</p>
</li>
<li><p><strong>Inflation</strong><br>View 填充也只会发生在UI Thread，也是比较繁重的操作（View的层级越大，工作越繁重）。填充工作会在手动填充一个View 或者启动一个activity的时候发生。这些都是在相同的UI线程进行的，当新的activity被填充的时候将会导致动画暂停。为了避免这种情况，可以在动画完成的时候再启动Activity。或者避免滚动列表时填充不同类型的View导致的卡顿，可以考虑预填充。比如，RecyclerView支持使用RecycledViewPool来装载不同的View类型。</p>
</li>
</ul>
<h2 id="加快启动速度">加快启动速度</h2><p>View的填充比较耗资源。不仅要解析资源数据，还要实例化潜在的View以及它们所需要的数据，包括第一次需要的decode bitmap，layout和draw。UI越复杂，填充操作就会越繁重。</p>
<p>上述所有都会降低启动速度。当用户启动一个应用时时，希望等得到一个及时的反馈说明应用已经在运行了。Android通过使用了一个“Starting Window”来弱化这种问题，该window通过应用主题和一些指定背景的图片构成。这样可以很好的让系统进程在后台去进行加载和填充工作。当activity准备好展示的时候，starting window就会过渡到真实的内容紧接着用户就可以使用应用了。</p>
<p>然而，这种starting window应该给用户更多的反馈以表明应用正在进行一些处理，当然这种策略不足以满足那种需要2秒甚至跟多时间去启动的应用，用户会被动的坐在那里一直等到完全加载完毕。</p>
<p>为了启动更快，一些不需要立即展示的UI可以延迟加载。通过使用ViewStub可以搞定。任何时候都尽可能的避免繁重的操作，比如进行大bitmap的decoding，避免由于内存分配和回收产生的内存搅动。可以使用工具监视启动时间去解决瓶颈问题。</p>
<p>避免在Application对象中初始化代码。Application在每一次进程启动的时候会被创建，会导致更多的工作而占用了实际需要展示给用户的UI的初始化时间。比如用户正在浏览一张图片，决定share，选中了你的app，那么你的app需要做的就是展示给用户分享的UI，其它都是多余的。Application的子类更倾向在某些情况下需要做一些耗时的操作，建议你选择使用singletons去持有公共全局的状态，这样就会在它第一次被访问的时候进行初始化。有一点相关的注意事项，不要在Application对象中进行网络有关的操作。That object may be created when one of the app’s Services or BroadcastReceivers is started; hitting the network will turn code that does a local update at a specific frequency into a regular DDoS.</p>
<p>还要注意，应用的不同状态对于启动时间有一个很大的区别。如果应用第一次启动，那么就会做大量的工作：启动进程，初始化所有的状态，必要的填充，布局和绘制。如果应用已经启动了并且在后台存活，重新启动就就很简单。这两种极端的例子会有另外两种情况出现，一：应用在用户退出后还存在，但是任务需要重新创建（通过调用<code>Activity.onCreaate()</code>），二：进程被系统干掉了，需要重新启动该进程，但是任务可以在Activity.onCreate()方法中通过保存的bundle恢复状态。你在进行应用启动时间测试的时候，确保优化最糟糕的情况：进程被干掉，需要重新启动。你可以通过从任务列表中移除你的应用来模拟这种情况。</p>
<h2 id="避免复杂的View层级">避免复杂的View层级</h2><p>布局越复杂，操作的时间就会越长：填充，布局和渲染（一些潜在的无用内容的内存开销，自定义View中多余数据的引入）。寻找最节省资源的方式去展示嵌套的内容。一种方法就是使用自定义View或者自定义布局，在自定义布局中去避免复杂的嵌套，对于一个单独的View来说绘制一些text和icons，相对于一个嵌套的ViewGroup就更简单。如何在一个交互模块中绑定多个元素呢？如果用户可以通过一个元素就可以完成交互，那么该元素应该是一个独立的View，而不是和其它元素绑定在一起。</p>
<h2 id="避免在View层级的顶层使用RelativeLayout">避免在View层级的顶层使用RelativeLayout</h2><p>RelativeLayout使用起来很方便，因为可以任意指定View的相对位置。在很多时候，可能是最好的选择，但是相对布局是消耗资源的一种方案，因为它需要两次measurement去确保自己处理了所有的布局关系。而且这个问题会伴随着View层级中的ReativeLayout的增多，而变得跟严重。想象一下，一个顶部是RelativeLayout的布局，本来就进行两次的measurement工作，如果它的第一个child也是RelativeLayout，那么该chilld RelativeLayout下面的布局也要进行两次measurement，整个布局就要进行4次measurement。</p>
<p>在不需要RelativeLayout的一些属性的时候，可以选择使用其它的布局类型。比如LinearLayout或者自定义的布局。确实需要对child进行相对布局的时候，可以考虑更优化的GridLayout，它已经预处理了Child View的关系，可以避免double－measurement的问题。</p>
<h2 id="避免在UI_Thread_进行繁重的操作">避免在UI Thread 进行繁重的操作</h2><p>在UI Thread中复杂的操作会导致动画和绘制的延迟，最终会导致明显的卡顿。一些已知的应该避免耗时操作的方法：<code>onDraw</code>，<code>onLayout</code>，以及任何与View相关的在UI thread调用的相关方法。还有一些其它的操作，比如webservice的调用，网络操作以及数据库的操作。可以考虑使用Loaders或者其它执行在其它线程的工具去操作，完成后再填充到UI上。一个可以追踪卡顿原因的工具是<code>StrictMode</code>。</p>
<p>另一个在UI Thread中避免访问文件系统和数据库的原因是：Android设备的存储在处理多个并发的读写操作时支持的不够好。即使你的app处理空闲状态，但是其它的app可能正在执行繁重的I/O操作（Play Store更新apps）也可能会导致你的应用产生ANR或者一些比较大的延迟。</p>
<p>总的来说，所有的事情都应该是异步的，UI Thread应该只操作那些核心的UI 操作，比如处理View的属性和绘制。</p>
<h2 id="最小化_Wakeups">最小化 Wakeups</h2><p>BroadcastReceivers可以用于从其它应用接收那些期望响应的信息和事件。但是过多的响应以至于超过了本身所需的话，这些事件就会导致app经常被唤醒，最终导致整个设备的性能和资源的耗费。当你的应用不需要关心这些结果时，考虑关闭BroadcastReceivers，并且慎重选择那些要响应的Intent。</p>
<h2 id="为低端手机考虑">为低端手机考虑</h2><p>大多数用户的手机比开发者手机的配置要低。因此去为这个市场的用户开发就很重要。在关注性能问题的时候，不要以自己的手机水平作为衡量标准，使用不同档次的手机进行测试，确保你的应用可以满足不同水平的设备。</p>
<p>低端手机的一些关注点还包括一些RAM的大小，屏幕的大小，比如512M的RAM或者768*480的屏幕分辨率的配置在低端手机中很常见。</p>
<h2 id="性能检测">性能检测</h2><p>使用Android提供的一些测试工具去追踪重要的性能相关的信息：渲染性能（是否达到60的帧率？），内存分配（内存分配是否导致垃圾回收最终导致动画的卡顿？），启动性能（在第一启动的时候是否做了太多的工作，导致用户等太久？）找到这些问题，解决它们！</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-3-performance/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-3-performance/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-iii-2efc140167fd" target="_blank" rel="external">Developing for Android, III:The Rules: Performance</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android中，性能和内存的关系很密切，因为系统的整体内存大小会影响所有进程的性能，因为垃圾回收器会对运行期间的性能产生很大的影响。下面的重点是运行期间的性能问题而不是内存。<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列4]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-4/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-4/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:26:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="不要过度同步">不要过度同步</h2><p>向云端发送数据和获取数据是非常耗电的行为之一。不是网络传输会将设备搞挂，而是一定量的后台应用向服务发起的这些请求会导致设备不能进入睡眠状态（或者对于收音机的低电量模式），一定时间后会导致严重的电量的流失。如果你不需要立即获取数据，就不要获取。如果将来需要获取数据，那么可以使用<code>JobScheduler</code>或者<code>GCM Network Manager</code>将它们和一些系统的请求一起处理。<br>下面是一些避免过度请求的一些建议：<br><a id="more"></a></p>
<ul>
<li><p>使用 GoogleCloudMessaging（GCM）。而不是使用新的持久化连接。</p>
</li>
<li><p>使用JobScheduler（API 21以及之后）或者GCM NetrowManager将一些异步请求绑在一起进行批处理，这些API可以保证操作只在设备恰当的闲暇状态下进行</p>
</li>
<li><p>不要轮询，任何情况都不要</p>
</li>
<li><p>只同步你需要的数据。数据同步已经被认为是电池和总体系统健康的罪魁祸首之一。因此开发者需要谨慎的选择哪些是真正需要同步的数据，以及多久同步一次,这些都可以让用户有更好的体验。</p>
</li>
<li><p>这里有一些参考文章可以查看更多信息:<a href="http://developer.android.com/training/efficient-downloads/regular_updates.html" target="_blank" rel="external">Minimizing the Effect of Regular Updates</a>,<a href="http://developer.android.com/training/sync-adapters/index.html" target="_blank" rel="external">Transferring Data Using Sync Adapters</a>,<a href="http://developer.android.com/training/efficient-downloads/efficient-network-access.html" target="_blank" rel="external">Optimizing Downloads for Efficient Network Access</a></p>
</li>
</ul>
<p><a id="more"></a></p>
<h2 id="避免过度加载服务">避免过度加载服务</h2><p>当服务请求失败，应该使用备用的技术避免请求一直，重复的请求。另外,不要设置固定时间，不然服务器在设定的时间上会被过多的请求压垮。</p>
<h2 id="不要对网络想当然">不要对网络想当然</h2><p>进行网络调用前，确保使用<code>NetworkInfo.isConnected()</code>进行检测。</p>
<p>网络请求不确定性很大，比较耗时，因此另一个建议是不要在UI 线程或者其它需要立即同步的行为中进行网络的请求。</p>
<h2 id="考虑低端网络环境">考虑低端网络环境</h2><p>类似于Performance篇里提到的要考虑低端手机的性能一样，网络方面也类似。如果你的应用的内容（Video或者music应用）依赖于一些网络性能，那么你就要考虑那些网络比较差的情况，你要理解一些市场不能够访问到较快的网速。如果你的应用可以从文本内容中获取大量信息（message或者社交app），那么在没有依赖于处理了较慢网络情况的媒体组件下，能够正常访问就很重要。2G网络可以用来测试很多市场上流行的较慢网络。</p>
<h2 id="设计适合客户端使用模式的服务端API">设计适合客户端使用模式的服务端API</h2><p>为了向所有的客户提供相同的API，向后兼容就是必要的。尽管这种向后兼容的策略是合理的，但是并不是好的主意，在一些小的设备上，完成数据的大量传输或者处理都是不好的，可以考虑将它们放到服务端。</p>
<p>比如，应用需要展示混合内容，请确保客户端可以通过一个单独的请求获取到所需要的信息并且返回的数据适合直接缓存。你通常希望客户端能够识直接别实体以便持久化，也希望避免重复的对象出现在内存中（开发者处理过程产生的对象内存开销）。</p>
<p>然而，很多API返回的数据结构是非标准化的。这种数据结构可能对于服务端处理更合适，但是对于移动端的数据持久化和从硬盘的读取都不够好。</p>
<p>客户端从返回的信息中能够直接用于展示的信息越多，就越高效。应用要很仔细的去筛选那些需要缓存的，剔除一些无用的，以及新数据到来时如何刷新视图。如果对待客户端像一个简单的HTML渲染机制一样就会丢掉客户端自身的很多优势。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-4-network/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-4-network/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-iv-e7dc4ce0a59" target="_blank" rel="external">Developing for Android, IV:The Rules: Networking</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="不要过度同步">不要过度同步</h2><p>向云端发送数据和获取数据是非常耗电的行为之一。不是网络传输会将设备搞挂，而是一定量的后台应用向服务发起的这些请求会导致设备不能进入睡眠状态（或者对于收音机的低电量模式），一定时间后会导致严重的电量的流失。如果你不需要立即获取数据，就不要获取。如果将来需要获取数据，那么可以使用<code>JobScheduler</code>或者<code>GCM Network Manager</code>将它们和一些系统的请求一起处理。<br>下面是一些避免过度请求的一些建议：<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google Developing for Android 系列5]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-5/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/11/google-developing-for-android-part-5/</id>
    <published>2015-06-10T16:00:00.000Z</published>
    <updated>2015-07-11T10:25:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用Android自身适当的数据结构">使用Android自身适当的数据结构</h2><p>出于对内存分配的考虑，传统的集合类在Android上可能不是最优选。Android特地提供的一些集合类型在很多情况下更合适，比如ArrayMap（好过HashMap），SparseArray。当集合非常大的时候，那些一般的集合仍然是合适的。而较小的集合则受益于自动装箱和内存分配的减少。<br><a id="more"></a></p>
<h2 id="Serialization">Serialization</h2><h3 id="Parcelable">Parcelable</h3><p>Parcelable是Andorid的IPC序列化格式，或者说它是一种可以通过Binder传递数据的接口，它有以下限制</p>
<ul>
<li><p>将Parcels写入到硬盘中是不安全的</p>
</li>
<li><p>你可以实现自己的Parcelables，但是如果在unparceling（Parcel反序列化）时不能访问到相同到类，那么就会unparcel就失败（对于向framework传递Parcels也适用）。</p>
</li>
<li><p>一些对象被存入到Parcels而不是共享内存中的情况，比如文件描述器，也许是很好的性能优化，但是隐藏了该Parcel对象真实的内存耗费（直到该对象被unparceling反序列化后才会占用真实的内存）。</p>
</li>
</ul>
<h3 id="持久化的Bundles">持久化的Bundles</h3><p>从API21开始，有一个新的PersistableBundle类，该类型的Bundle持有一个数据表支持XML格式数据的序列化。它接收的数据类型只能是Bundle所支持的子类。特别的，它不支持Parcelable对象。</p>
<p>当处理一些需要通过Binder IPC传递的数据时，PersistableBundle类非常有用。</p>
<h3 id="避免Java序列化">避免Java序列化</h3><p>Serializable，ObjectOutputStream以及相关的类一直是可以用的，但是这些方式总体来说很重，会增加原始序列化的字段。比如，对于一些较长期的硬盘的序列化来说，Serializable类型的序列化导致了一些额外的信息，而这些信息又是不必要的的。下面有些更好的选择：</p>
<ul>
<li>使用Parcelable去处理所有在运行期间的数据交换</li>
<li><p>SharedPreferences也是不错的选择，快速的key－value存储对于少量的数据来说非常合适</p>
</li>
<li><p>使用SQLite来处理更复杂，row-oriented的数据。</p>
</li>
</ul>
<p>有一种特殊的情况可能需要java 序列化。如果你的app需要和一些需要特定协议的老的服务器交互。这种情况下应该考虑系统升级以便更高效。</p>
<h3 id="XML_和_JSON">XML 和 JSON</h3><p>基于文本的格式通常比较慢也比较冗长，因此它们不适合大量的，复杂的，IPC（使用Parcelable代替），或者需要查询的数据（使用SQLite）。集成基于JSON或者XML的web service是比较好的。也可以使用一些XML去存储少量的较少修改的数据（虽然SharedPreferences更简单）</p>
<p>XML数据在Android资源文件种会被压缩成一种运行期更高效解析的格式。这并不是说XML是运行期间解析XML的特定格式。</p>
<h2 id="避免JNI">避免JNI</h2><p>JNI的问题有很多原因。首先，native代码要求JNI必须为所有平台编译（ARM，ARM64，MIPS等）。不像java代码一样可以跨平台运行。在JNI间的来回调用是相当耗资源的，远远超过native层的一些无关紧要的方法调用。最终还为查找bug带来了困难，因为native层的内存访问是不明显的。</p>
<p>如果确实要使用JNI，可以参考以下建议：</p>
<ul>
<li>使用long类型的指针确保64位的兼容性</li>
<li>native方法应该总是是静态的，本地对象的指针作为第一个参数传递</li>
<li>java语言的对象应该决定native的生命周期，而不是其它方式</li>
<li>注意全局的对象引用可能会导致内存泄漏</li>
<li>在调用JNI方法前进行参数检查而不是到迷乱的JNI中</li>
<li>最小化JNI的交互次数，每一次JNI调用尽量做更多工作</li>
<li>通过值传递native指针而不是来自native的成员查询。这种方式只对非静态对方法有效，</li>
<li>考虑使用RenderScript 执一些计算敏感的操作</li>
</ul>
<h2 id="优先选择原始类型">优先选择原始类型</h2><p>在内存优化中已经提及，但在这里重复一次也是必要的。当有选择的时候，尽量使用原始类型（int，float，boolean）替代对象类型（Integer，Float，Boolean）。在涉及内存（对象实例会开销更多内存）和性能（对象需要更多的时间去访问值）的时候，在Android上，你应该一直优先选择原始类型。</p>
<p>泛型和数据结构需要对象类型，但是注意在Android上有一些优化的集合(ArrayMap, SimpleArrayMap, SparseArray, SparseBooleanArray, SparseIntArray, SparseLongArray, and LongSparseArray)可以满足特定的环境。</p>
<blockquote>
<p>译文链接：<a href="http://www.lightskystreet.com/2015/06/07/google-for-android-5-language-libraries/" target="_blank" rel="external">http://www.lightskystreet.com/2015/06/07/google-for-android-5-language-libraries/</a><br>译文作者：<a href="http://www.lightskystreet.com/" target="_blank" rel="external">lightSky</a><br>原文链接：<a href="https://medium.com/google-developers/developing-for-android-v-f6b8038b42f5" target="_blank" rel="external">Developing for Android V:The Rules: Language and Libraries</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用Android自身适当的数据结构">使用Android自身适当的数据结构</h2><p>出于对内存分配的考虑，传统的集合类在Android上可能不是最优选。Android特地提供的一些集合类型在很多情况下更合适，比如ArrayMap（好过HashMap），SparseArray。当集合非常大的时候，那些一般的集合仍然是合适的。而较小的集合则受益于自动装箱和内存分配的减少。<br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 5.0 Activity切换动画]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/08/android_5_0_activity_animations/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/08/android_5_0_activity_animations/</id>
    <published>2015-06-07T16:00:00.000Z</published>
    <updated>2015-07-11T10:13:56.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://images0.cnblogs.com/blog2015/354225/201506/071858146918959.gif" alt=""><br><a id="more"></a><br>在Androiod5.0中,Google定义了Material Design的规范.而动画切换,能给用户直观的连贯性的体验,也是Google推崇的.<br>为此,在Android5.0中,Android新支持了不少炫酷的动画效果.这里是Android官方对于Material Design的动画的介绍文档.<br>下面要介绍的其中一种Activity的切换效果(如上图).当前后两个Activity有共同的UI元素时候,适合用这种动画效果,给用户连贯性的体验.  </p>
<h3 id="实现步骤">实现步骤</h3><h4 id="1-_新建一个Android应用Project,里面有两个Activity;">1. 新建一个Android应用Project,里面有两个Activity;</h4><h4 id="2-_下面是MainActivity的代码和XML布局;">2. 下面是MainActivity的代码和XML布局;</h4><p>代码和布局都非常简单.解释一下<code>onClick()</code>方法的代码.<br><code>makeSceneTransactionAnimation()</code>方法第二个参数是用来告诉指定共同的UI元素是哪一个,这里是shareView.<br><code>makeSceneTransactionAnimation()</code>方法第三个参数是<code>&quot;robot&quot;</code>,和XML布局里面的<code>android:transactionName=&quot;robot&quot;</code>的值是一一对应的.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.garena.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActionBar;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.ActivityOptions;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> View shareView = findViewById(R.id.share_element_image_view);</span><br><span class="line">        shareView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">                ActivityOptions options = ActivityOptions</span><br><span class="line">                        .makeSceneTransitionAnimation(MainActivity.<span class="keyword">this</span>, shareView, <span class="string">"robot"</span>);</span><br><span class="line">                startActivity(intent, options.toBundle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ActionBar actionBar = getActionBar();</span><br><span class="line">        <span class="keyword">if</span> (actionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actionBar.setTitle(R.string.first_activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@string/hello_world"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/share_element_image_view"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:src</span>=<span class="value">"@drawable/ic_launcher"</span></span><br><span class="line">        <span class="attribute">android:transitionName</span>=<span class="value">"robot"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-下面是SecondActivity的代码和布局;">3.下面是SecondActivity的代码和布局;</h4><p>在onClick()方法里面,调用finishAfterTransaction()来finish activity.<br>在XML布局里面,同样是需要用android:transactionName=”roboto”来标识共同的UI元素.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.garena.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActionBar;</span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.second_activity);</span><br><span class="line">        ActionBar actionBar = getActionBar();</span><br><span class="line">        <span class="keyword">if</span> (actionBar !=  <span class="keyword">null</span>) &#123;</span><br><span class="line">            actionBar.setTitle(R.string.second_activity);</span><br><span class="line">        &#125;</span><br><span class="line">        View btnBack = findViewById(R.id.btn_back);</span><br><span class="line">        btnBack.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                finishAfterTransition();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:gravity</span>=<span class="value">"center"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/title_icon_image_view"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:src</span>=<span class="value">"@drawable/ic_launcher"</span></span><br><span class="line">        <span class="attribute">android:transitionName</span>=<span class="value">"robot"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/btn_back"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@string/back"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_运行效果(如上图);">4. 运行效果(如上图);</h4><p>从最终运行的效果图可以看到,点击小机器人的图标进入SecondActivity时,能看到小机器人图标移动到SecondActivity这个小机器人图标的位置.<br>点击SecondActivity的Back按钮,小机器人图标会移动到MainActivity中小机器人图标的位置.  </p>
<blockquote>
<p>原文链接 :<a href="http://www.cnblogs.com/wingyip/p/4558923.html" target="_blank" rel="external">http://www.cnblogs.com/wingyip/p/4558923.html</a><br>作者 : <a href="http://www.cnblogs.com/wingyip/" target="_blank" rel="external">wingyip</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://images0.cnblogs.com/blog2015/354225/201506/071858146918959.gif" alt=""><br>]]>
    
    </summary>
    
      <category term="特效" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%89%B9%E6%95%88/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范第2季]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/08/android-performance-patterns-season-2/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/08/android-performance-patterns-season-2/</id>
    <published>2015-06-07T16:00:00.000Z</published>
    <updated>2015-07-11T10:15:31.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_2.png" alt="android_perf_patterns_season_2"><br><a id="more"></a><br>Google前几天刚发布了<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Android性能优化典范第2季</a>的课程，一共20个短视频，包括的内容大致有：电量优化，网络优化，Wear上如何做优化，使用对象池来提高效率，LRU Cache，Bitmap的缩放，缓存，重用，PNG压缩，自定义View的性能，提升设置alpha之后View的渲染性能，以及Lint，StictMode等等工具的使用技巧。 下面是对这些课程的总结摘要，认知有限，理解偏差的地方请多多指教！</p>
<h2 id="1)Battery_Drain_and_Networking">1)Battery Drain and Networking</h2><p>对于手机程序，网络操作相对来说是比较耗电的行为。优化网络操作能够显著节约电量的消耗。在性能优化第1季里面有提到过，手机硬件的各个模块的耗电量是不一样的，其中移动蜂窝模块对电量消耗是比较大的，另外蜂窝模块在不同工作强度下，对电量的消耗也是有差异的。当程序想要执行某个网络请求之前，需要先唤醒设备，然后发送数据请求，之后等待返回数据，最后才慢慢进入休眠状态。这个流程如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_network_request_mode.png" alt="android_perf_2_network_request_mode"></p>
<p>在上面那个流程中，蜂窝模块的电量消耗差异如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_battery_drain_mode.png" alt="android_perf_2_battery_drain_mode"></p>
<p>从图示中可以看到，激活瞬间，发送数据的瞬间，接收数据的瞬间都有很大的电量消耗，所以，我们应该从如何传递网络数据以及何时发起网络请求这两个方面来着手优化。</p>
<h4 id="1-1)何时发起网络请求">1.1)何时发起网络请求</h4><p>首先我们需要区分哪些网络请求是需要及时返回结果的，哪些是可以延迟执行的。例如，用户主动下拉刷新列表，这种行为需要立即触发网络请求，并等待数据返回。但是对于上传用户操作的数据，同步程序设置等等行为则属于可以延迟的行为。我们可以通过Battery Historian这个工具来查看关于移动蜂窝模块的电量消耗（关于这部分的细节，请点击<a href="http://hukai.me/android-performance-battery/" target="_blank" rel="external">Android性能优化之电量篇</a>）。在Mobile Radio那一行会显示蜂窝模块的电量消耗情况，红色的部分代表模块正在工作，中间的间隔部分代表模块正在休眠状态，如果看到有一段区间，红色与间隔频繁的出现，那就说明这里有可以优化的行为。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_battery_mobile_radio.png" alt="android_perf_2_battery_mobile_radio"></p>
<p>对于上面可以优化的部分，我们可以有针对性的把请求行为捆绑起来，延迟到某个时刻统一发起请求。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_battery_batch_delay.png" alt="android_perf_2_battery_batch_delay"></p>
<p>经过上面的优化之后，我们再回头使用Battery Historian导出电量消耗图，可以看到唤醒状态与休眠状态是连续大块间隔的，这样的话，总体电量的消耗就会变得更少。</p>
<p><img src="http://hukai.me/images/android_perf_2_battery_mobile_radio_2.png" alt="android_perf_2_battery_mobile_radio_2"></p>
<p>当然，我们甚至可以把请求的任务延迟到手机网络切换到WiFi，手机处于充电状态下再执行。在前面的描述过程中，我们会遇到的一个难题是如何把网络请求延迟，并批量进行执行。还好，Android提供了<a href="http://developer.android.com/intl/zh-cn/reference/android/app/job/JobScheduler.html" target="_blank" rel="external">JobScheduler</a>来帮助我们达成这个目标。</p>
<h4 id="1-2)如何传递网络数据">1.2)如何传递网络数据</h4><p>关于这部分主要会涉及到Prefetch(预取)与Compressed(压缩)这两个技术。对于Prefetch的使用，我们需要预先判断用户在此次操作之后，后续零散的请求是否很有可能会马上被触发，可以把后面5分钟有可能会使用到的零散请求都一次集中执行完毕。对于Compressed的使用，在上传与下载数据之前，使用CPU对数据进行压缩与解压，可以很大程度上减少网络传输的时间。</p>
<p>想要知道我们的应用程序中网络请求发生的时间，每次请求的数据量等等信息，可以通过Android Studio中的<a href="http://developer.android.com/intl/zh-cn/tools/debugging/ddms.html#network" target="_blank" rel="external">Networking Traffic Tool</a>来查看详细的数据，如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_battery_network_tracking.png" alt="android_perf_2_battery_network_tracking"></p>
<h2 id="2)Wear_&amp;_Sensors">2)Wear &amp; Sensors</h2><p>在Android Wear上会大量的使用Sensors来实现某些特殊功能，如何在尽量节约电量的前提下利用好Sensor会是我们需要特别注意的问题。下面会介绍一些在Android Wear上的最佳实践典范。</p>
<p>尽量减少刷新请求，例如我们可以在不需要某些数据的时候尽快注销监听，减小刷新频率，对Sensor的数据做批量处理等等。那么如何做到这些优化呢？</p>
<ul>
<li>首先我们需要尽量使用Android平台提供的既有运动数据，而不是自己去实现监听采集数据，因为大多数Android Watch自身记录Sensor数据的行为是有经过做电量优化的。</li>
<li>其次在Activity不需要监听某些Sensor数据的时候需要尽快释放监听注册。</li>
<li>还有我们需要尽量控制更新的频率，仅仅在需要刷新显示数据的时候才触发获取最新数据的操作。</li>
<li>另外我们可以针对Sensor的数据做批量处理，待数据累积一定次数或者某个程度的时候才更新到UI上。</li>
<li>最后当Watch与Phone连接起来的时候，可以把某些复杂操作的事情交给Phone来执行，Watch只需要等待返回的结果。</li>
</ul>
<p>更对关于Sensors的知识，可以点击<a href="https://www.youtube.com/watch?v=82M8DmFz4P8&amp;index=2&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">这里</a></p>
<h2 id="3)Smooth_Android_Wear_Animation">3)Smooth Android Wear Animation</h2><p>Android Material Design风格的应用采用了大量的动画来进行UI切换，优化动画的性能不仅能够提升用户体验还可以减少电量的消耗，下面会介绍一些简单易行的方法。</p>
<p>在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。</p>
<p><img src="http://hukai.me/images/android_perf_2_waer_animation.png" alt="android_perf_2_waer_animation"></p>
<p>另外尽量减少每次重绘的元素可以极大的提升性能，假如某个钟表界面上有很多需要显示的复杂组件，我们可以把这些组件做拆分处理，例如把背景图片单独拎出来设置为一个独立的View，通过setLayerType()方法使得这个View强制用Hardware来进行渲染。至于界面上哪些元素需要做拆分，他们各自的更新频率是多少，需要有针对性的单独讨论。</p>
<p>如何使用Systrace等工具来查看某些View的渲染性能，在前面的章节里面有提到过，感兴趣的可以点击<a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">这里</a></p>
<p>对于大多数应用中的动画，我们会使用PropertyAnimation或者ViewAnimation来操作实现，Android系统会自动对这些Animation做一定的优化处理，在Android上面学习到的大多数性能优化的知识同样也适用于Android Wear。</p>
<p>想要获取更多关于Android Wear中动画效果的优化，请点击<a href="http://developer.android.com/samples/WatchFace/index.html" target="_blank" rel="external">WatchFace</a>这个范例。</p>
<h2 id="4)Android_Wear_Data_Batching">4)Android Wear Data Batching</h2><p>在Android Training里面有关于Wear上面如何利用Wearable API与Phone进行沟通协作的课程(详情请点击<a href="http://developer.android.com/training/wearables/data-layer/index.html" target="_blank" rel="external">这里</a>)。因为Phone的CPU与电量都比Wear要强大，另外Phone还可以直接接入网络，而Wear要接入网络则相对更加困难，所以我们在开发Wear应用的时候需要尽量做到把复杂的操作交给Phone来执行。例如我们可以让Phone来获取天气信息，然后把数据返回Wear进行显示。更进一步，在之前的性能优化课程里面我们有学习过如何使用JobScheduler来延迟批量处理任务，假设Phone收到来自Wear的其中一个任务是每隔5分钟检查一次天气情况，那么Phone使用JobScheduler执行检查天气任务之后，先判断这次返回的结果和之前是否有差异，仅仅当天气发生变化的时候，才有必要把结果通知到Wear，或者仅仅把变化的某一项数据通知给Wear，这样可以更大程度上减少Wear的电量消耗。</p>
<p>下面我们总结一下如何优化Wear的性能与电量：</p>
<ul>
<li>仅仅在真正需要刷新界面的时候才发出请求</li>
<li>尽量把计算复杂操作的任务交给Phone来处理</li>
<li>Phone仅仅在数据发生变化的时候才通知到Wear</li>
<li>把零碎的数据请求捆绑一起再进行操作</li>
</ul>
<h2 id="5)Object_Pools">5)Object Pools</h2><p>在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，paints等等。关于对象池的操作原理，不展开述说了，请看下面的图示：</p>
<p><img src="http://hukai.me/images/android_perf_2_object_pool.png" alt="android_perf_2_object_pool"></p>
<p>使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做<strong>预分配</strong>。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。</p>
<h2 id="6)To_Index_or_Iterate?">6)To Index or Iterate?</h2><p>遍历容器是编程里面一个经常遇到的场景。在Java语言中，使用Iterate是一个比较常见的方法。可是在Android开发团队中，大家却尽量避免使用Iterator来执行遍历操作。下面我们看下在Android上可能用到的三种不同的遍历方法：</p>
<p><img src="http://hukai.me/images/android_perf_2_iterate_1.png" alt="android_perf_2_iterate_1"></p>
<p><img src="http://hukai.me/images/android_perf_2_iterate_for_loop.png" alt="android_perf_2_iterate_for_loop"></p>
<p><img src="http://hukai.me/images/android_perf_2_iterate_simple_loop.png" alt="android_perf_2_iterate_simple_loop"></p>
<p>使用上面三种方式在同一台手机上，使用相同的数据集做测试，他们的表现性能如下所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_iterate_result.png" alt="android_perf_2_iterate_result"></p>
<p>从上面可以看到for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。</p>
<h2 id="7)The_Magic_of_LRU_Cache">7)The Magic of LRU Cache</h2><p>这小节我们要讨论的是缓存算法，在Android上面最常用的一个缓存算法是LRU(Least Recently Use)，关于LRU算法，不展开述说，用下面一张图演示下含义：</p>
<p><img src="http://hukai.me/images/android_perf_2_lru_mode.png" alt="android_perf_2_lru_mode"></p>
<p>LRU Cache的基础构建用法如下：</p>
<p><img src="http://hukai.me/images/android_perf_2_lru_key_value.png" alt="android_perf_2_lru_key_value"></p>
<p>为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的：</p>
<p><img src="http://hukai.me/images/android_perf_2_lru_size.png" alt="android_perf_2_lru_size"></p>
<p>使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法：</p>
<p><img src="http://hukai.me/images/android_perf_2_lru_sizeof.png" alt="android_perf_2_lru_sizeof"></p>
<p>使用LRU Cache能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。</p>
<h2 id="8)Using_LINT_for_Performance_Tips">8)Using LINT for Performance Tips</h2><p>Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具。</p>
<p><img src="http://hukai.me/images/android_perf_2_lint_overview.png" alt="android_perf_2_lint_overview"></p>
<p>例如，如果我们在onDraw方法里面执行了new对象的操作，Lint就会提示我们这里有性能问题，并提出对应的建议方案。Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -&gt; Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。</p>
<p>Lint的功能非常强大，他能够扫描各种问题。当然我们可以通过Android Studio设置找到Lint，对Lint做一些定制化扫描的设置，可以选择忽略掉那些不想Lint去扫描的选项，我们还可以针对部分扫描内容修改它的提示优先级。</p>
<p>建议把与内存有关的选项中的严重程度标记为红色的Error，对于Layout的性能问题标记为黄色Warning。</p>
<h2 id="9)Hidden_Cost_of_Transparency">9)Hidden Cost of Transparency</h2><p>这小节会介绍如何减少透明区域对性能的影响。通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。原因是包含alpha的view需要事先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。</p>
<p>在某些情况下，一个包含alpha的View有可能会触发改View在HierarchyView上的父View都被额外重绘一次。下面我们看一个例子，下图演示的ListView中的图片与二级标题都有设置透明度。</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_listview.png" alt="android_perf_2_trans_listview"></p>
<p>大多数情况下，屏幕上的元素都是由后向前进行渲染的。在上面的图示中，会先渲染背景图(蓝，绿，红)，然后渲染人物头像图。如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理。很多时候，我们会给整个View设置alpha的来达到fading的动画效果，如果我们图示中的ListView做alpha逐渐减小的处理，我们可以看到ListView上的TextView等等组件会逐渐融合到背景色上。但是在这个过程中，我们无法观察到它其实已经触发了额外的绘制任务，我们的目标是让整个View逐渐透明，可是期间ListView在不停的做Blending的操作，这样会导致不少性能问题。</p>
<p>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_hw_layer.png" alt="android_perf_2_trans_hw_layer"></p>
<p>如何才能够让GPU来渲染某个View呢？我们可以通过setLayerType的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用ViewPropertyAnimator.alpha().withLayer()来指定。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_setlayertype.png" alt="android_perf_2_trans_setlayertype"></p>
<p>另外一个例子是包含阴影区域的View，这种类型的View并不会出现我们前面提到的问题，因为他们并不存在层叠的关系。</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_overlap.png" alt="android_perf_2_trans_overlap"></p>
<p>为了能够让渲染器知道这种情况，避免为这种View占用额外的GPU内存空间，我们可以做下面的设置。</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_override_lap.png" alt="android_perf_2_trans_override_lap"></p>
<p>通过上面的设置以后，性能可以得到显著的提升，如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_trans_overlap_compare.png" alt="android_perf_2_trans_overlap_compare"></p>
<h2 id="10)Avoiding_Allocations_in_onDraw()">10)Avoiding Allocations in onDraw()</h2><p>我们都知道应该避免在onDraw()方法里面执行导致内存分配的操作，下面讲解下为何需要这样做。</p>
<p>首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。</p>
<p><img src="http://hukai.me/images/android_perf_2_ondraw_gc.png" alt="android_perf_2_ondraw_gc"></p>
<p>如果在onDraw里面执行内存分配的操作，会容易导致内存抖动，GC频繁被触发，虽然GC后来被改进为执行在另外一个后台线程(GC操作在2.3以前是同步的，之后是并发)，可是频繁的GC的操作还是会影响到CPU，影响到电量的消耗。</p>
<p>那么简单解决频繁分配内存的方法就是把分配操作移动到onDraw()方法外面，通常情况下，我们会把onDraw()里面new Paint的操作移动到外面，如下面所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_ondraw_paint.png" alt="android_perf_2_ondraw_paint"></p>
<h2 id="11)Tool:_Strict_Mode">11)Tool: Strict Mode</h2><p>UI线程被阻塞超过5秒，就会出现ANR，这太糟糕了。防止程序出现ANR是很重要的事情，那么如何找出程序里面潜在的坑，预防ANR呢？很多大部分情况下执行很快的方法，但是他们有可能存在巨大的隐患，这些隐患的爆发就很容易导致ANR。</p>
<p>Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过<a href="http://developer.android.com/reference/android/os/StrictMode.html" target="_blank" rel="external">StrictMode</a> API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。下面是官方的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</span><br><span class="line">         StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                 .detectDiskReads()</span><br><span class="line">                 .detectDiskWrites()</span><br><span class="line">                 .detectNetwork()   <span class="comment">// or .detectAll() for all detectable problems</span></span><br><span class="line">                 .penaltyLog()</span><br><span class="line">                 .build());</span><br><span class="line">         StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">                 .detectLeakedSqlLiteObjects()</span><br><span class="line">                 .detectLeakedClosableObjects()</span><br><span class="line">                 .penaltyLog()</span><br><span class="line">                 .penaltyDeath()</span><br><span class="line">                 .build());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">super</span>.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12)Custom_Views_and_Performance">12)Custom Views and Performance</h2><p>Android系统有提供超过70多种标准的View，例如TextView，ImageView，Button等等。在某些时候，这些标准的View无法满足我们的需要，那么就需要我们自己来实现一个View，这节会介绍如何优化自定义View的性能。</p>
<p>通常来说，针对自定义View，我们可能犯下面三个错误：</p>
<ul>
<li><strong>Useless calls to onDraw()：</strong>我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。</li>
<li><strong>Useless pixels：</strong>减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。</li>
<li><strong>Wasted CPU cycles：</strong>对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。</li>
</ul>
<p>最后请时刻牢记，尽量提高View的绘制性能，这样才能保证界面的刷新帧率尽量的高。更多关于这部分的内容，可以看<a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">这里</a></p>
<h2 id="13)Batching_Background_Work_Until_Later">13)Batching Background Work Until Later</h2><p>优化性能时大多数时候讨论的都是如何减少不必要的操作，但是选择何时去执行某些操作同样也很重要。在<a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">第1季</a>以及上一期的<a href="http://hukai.me/android-performance-battery/" target="_blank" rel="external">性能优化之电量篇</a>里面，我们有提到过移动蜂窝模块的电量消耗模型。为了避免我们的应用程序过多的频繁消耗电量，我们需要学习如何把后台任务打包批量，并选择一个合适的时机进行触发执行。下图是每个应用程序各自执行后台任务导致的电量消耗示意图：</p>
<p><img src="http://hukai.me/images/android_perf_2_batching_bg_1.png" alt="android_perf_2_batching_bg_1"></p>
<p>因为像上面那样做会导致浪费很多电量，我们需要做的是把部分应用的任务延迟处理，等到一定时机，这些任务一并进行处理。结果如下面的示意图：</p>
<p><img src="http://hukai.me/images/android_perf_2_batching_bg_2.png" alt="android_perf_2_batching_bg_2"></p>
<p>执行延迟任务，通常有下面三种方式：</p>
<h4 id="1)AlarmManager">1)AlarmManager</h4><p>使用AlarmManager设置定时任务，可以选择精确的间隔时间，也可以选择非精确时间作为参数。除非程序有很强烈的需要使用精确的定时唤醒，否者一定要避免使用他，我们应该尽量使用非精确的方式。</p>
<h4 id="2)SyncAdapter">2)SyncAdapter</h4><p>我们可以使用SyncAdapter为应用添加设置账户，这样在手机设置的账户列表里面可以找到我们的应用。这种方式功能更多，但是实现起来比较复杂。我们可以从这里看到官方的培训课程：<a href="http://developer.android.com/training/sync-adapters/index.html" target="_blank" rel="external">http://developer.android.com/training/sync-adapters/index.html</a></p>
<h4 id="3)JobSchedulor">3)JobSchedulor</h4><p>这是最简单高效的方法，我们可以设置任务延迟的间隔，执行条件，还可以增加重试机制。</p>
<h2 id="14)Smaller_Pixel_Formats">14)Smaller Pixel Formats</h2><p>常见的png,jpeg,webp等格式的图片在设置到UI上之前需要经过解码的过程，而解压时可以选择不同的解码率，不同的解码率对内存的占用是有很大差别的。在不影响到画质的前提下尽量减少内存的占用，这能够显著提升应用程序的性能。</p>
<p>Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_pixel_heap_free.png" alt="android_perf_2_pixel_heap_free"></p>
<p>所以为了避免加载一张超大的图片，需要尽量减少这张图片所占用的内存大小，Android为图片提供了4种解码格式，他们分别占用的内存大小如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_pixel_heap_free.png" alt="android_perf_2_pixel_format"></p>
<p>随着解码占用内存大小的降低，清晰度也会有损失。我们需要针对不同的应用场景做不同的处理，大图和小图可以采用不同的解码率。在Android里面可以通过下面的代码来设置解码率：</p>
<p><img src="http://hukai.me/images/android_perf_2_pixel_decode.png" alt="android_perf_2_pixel_decode"></p>
<h2 id="15)Smaller_PNG_Files">15)Smaller PNG Files</h2><p>尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。我们可以通过Google搜索到很多关于PNG压缩的工具，如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_png_tools.png" alt="android_perf_2_png_tools"></p>
<p>这里要介绍一种新的图片格式：Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式。关于Webp的更多细节，请点击<a href="https://developers.google.com/speed/webp/?csw=1" target="_blank" rel="external">这里</a></p>
<h2 id="16)Pre-scaling_Bitmaps">16)Pre-scaling Bitmaps</h2><p>对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()，使用这个方法可以获取到一张经过缩放的图片。</p>
<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_created.png" alt="android_perf_2_sacle_bitmap_created"></p>
<p>上面的方法能够快速的得到一张经过缩放的图片，可是这个方法能够执行的前提是，原图片需要事先加载到内存中，如果原图片过大，很可能导致OOM。下面介绍其他几种缩放图片的方式。</p>
<p>inSampleSize能够等比的缩放显示图片，同时还避免了需要先把原图加载进内存的缺点。我们会使用类似像下面一样的方法来缩放bitmap：</p>
<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_code.png" alt="android_perf_2_sacle_bitmap_code"></p>
<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_insamplesize.png" alt="android_perf_2_sacle_bitmap_insamplesize"></p>
<p>另外，我们还可以使用inScaled，inDensity，inTargetDensity的属性来对解码图片做处理，源码如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_inscale.png" alt="android_perf_2_sacle_bitmap_inscale"></p>
<p>还有一个经常使用到的技巧是inJustDecodeBounds，使用这个属性去尝试解码图片，可以事先获取到图片的大小而不至于占用什么内存。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_sacle_bitmap_injust.png" alt="android_perf_2_sacle_bitmap_injust"></p>
<h2 id="17)Re-using_Bitmaps">17)Re-using Bitmaps</h2><p>我们知道bitmap会占用大量的内存空间，这节会讲解什么是inBitmap属性，如何利用这个属性来提升bitmap的循环效率。前面我们介绍过使用对象池的技术来解决对象频繁创建再回收的效率问题，使用这种方法，bitmap占用的内存空间会差不多是恒定的数值，每次新创建出来的bitmap都会需要占用一块单独的内存区域，如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_inbitmap_old.png" alt="android_perf_2_inbitmap_old"></p>
<p>为了解决上图所示的效率问题，Android在解码图片的时候引进了<strong>inBitmap</strong>属性，使用这个属性可以得到下图所示的效果：</p>
<p><img src="http://hukai.me/images/android_perf_2_inbitmap_new.png" alt="android_perf_2_inbitmap_new"></p>
<p>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。下面是如何使用inBitmap的代码示例：</p>
<p><img src="http://hukai.me/images/android_perf_2_inbitmap_code.png" alt="android_perf_2_inbitmap_code"></p>
<p>使用inBitmap需要注意几个限制条件：</p>
<ul>
<li>在SDK 11 -&gt; 18之间，重用的bitmap大小必须是一致的，例如给inBitmap赋值的图片大小为100-100，那么新申请的bitmap必须也为100-100才能够被重用。从SDK 19开始，新申请的bitmap大小必须小于或者等于已经赋值过的bitmap大小。</li>
<li>新申请的bitmap与旧的bitmap必须有相同的解码格式，例如大家都是8888的，如果前面的bitmap是8888，那么就不能支持4444与565格式的bitmap了。</li>
</ul>
<p>我们可以创建一个包含多种典型可重用bitmap的对象池，这样后续的bitmap创建都能够找到合适的“模板”去进行重用。如下图所示：</p>
<p><img src="http://hukai.me/images/android_perf_2_inbitmap_pool.png" alt="android_perf_2_inbitmap_pool"></p>
<p>Google介绍了一个开源的加载bitmap的库：<a href="https://github.com/bumptech/glide" target="_blank" rel="external">Glide</a>，这里面包含了各种对bitmap的优化技巧。</p>
<h2 id="18)The_Performance_Lifecycle">18)The Performance Lifecycle</h2><p>大多数开发者在没有发现严重性能问题之前是不会特别花精力去关注性能优化的，通常大家关注的都是功能是否实现。当性能问题真的出现的时候，请不要慌乱。我们通常采用下面三个步骤来解决性能问题。</p>
<h4 id="Gather：收集数据">Gather：收集数据</h4><p>我们可以通过Android SDK里面提供的诸多工具来收集CPU，GPU，内存，电量等等性能数据，</p>
<h4 id="Insight：分析数据">Insight：分析数据</h4><p>通过上面的步骤，我们获取到了大量的数据，下一步就是分析这些数据。工具帮我们生成了很多可读性强的表格，我们需要事先了解如何查看表格的数据，每一项代表的含义，这样才能够快速定位问题。如果分析数据之后还是没有找到问题，那么就只能不停的重新收集数据，再进行分析，如此循环。</p>
<h4 id="Action：解决问题">Action：解决问题</h4><p>定位到问题之后，我们需要采取行动来解决问题。解决问题之前一定要先有个计划，评估这个解决方案是否可行，是否能够及时的解决问题。</p>
<h2 id="19)Tools_not_Rules">19)Tools not Rules</h2><p>虽然前面介绍了很多调试的方法，处理技巧，规范建议等等，可是这并不意味着所有的情况都适用，我们还是需要根据当时的情景做特定灵活的处理。</p>
<h2 id="20)Memory_Profiling_101">20)Memory Profiling 101</h2><p>围绕Android生态系统，不仅仅有Phone，还有Wear，TV，Auto等等。对这些不同形态的程序进行性能优化，都离不开内存调试这个步骤。这节中介绍的内容大部分和<a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="external">Android性能优化典范</a>与<a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a>重合，不展开了。</p>
<p>首发于CSDN：<a href="http://www.csdn.net/article/2015-04-29/2824583-android-performance-patterns-season-2" target="_blank" rel="external">Android性能优化典范（二）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://hukai.me/images/android_perf_patterns_season_2.png" alt="android_perf_patterns_season_2"><br>]]>
    
    </summary>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="性能优化" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建-RecyclerView-LayoutManager-Redux]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/recyclerview-layoutmanager-3/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/recyclerview-layoutmanager-3/</id>
    <published>2015-06-05T16:00:00.000Z</published>
    <updated>2015-07-11T10:09:43.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文是这个系列中的 Part 3。<br><a id="more"></a><br>在之前的文章里，我们讨论了怎样对数据集改变和定量滚动<br>提供正确的支持。接下来我们会介绍怎样给 LayoutManager 添加<br>合适的动画效果。</p>
<p>友情提醒：示例中的代码在这里 <a href="https://github.com/devunwired/recyclerview-playground" target="_blank" rel="external">Github</a></p>
</blockquote>
<hr>
<h1 id="The_Problem_With_Free">The Problem With Free</h1><p>上次我们说到了 <code>notifyDataSetChanged()</code> ，但是使用这个方法<br>不会有数据改变的动画效果<a id="1" href="#b1">(1)</a>。<br>RecyclerView 提供了新的 API 让我们可以通知 adapter<br>做出带有动画效果的改变。它们是：</p>
<ul>
<li><code>notifyItemInserted()</code>  和 <code>notifyItemRangeInserted()</code>：<br>  在给定位置/范围插入新item(s)。</li>
<li><code>notifyItemChanged()</code> 和 <code>notifyItemRangeChanged()</code>：<br>  使给定 位置/范围 的 item(s) 无效，数据集并没有结构上的改变。</li>
<li><code>notifyItemRemoved()</code> 和 <code>notifyItemRangeRemoved()</code>：<br>  移除给定 位置/范围 的 item(s)。</li>
<li><code>notifyItemMoved()</code>：<br>  将数据集中的一个 item 重定位到一个新的位置。</li>
</ul>
<p>使用这些方法你的 LayoutManager 会得到一个很简单的默认 item 动画。<br>这些动画是根据当前每一个 view 在改变后是否还存在于 layout 之中生成的。<br>新的 view 渐入，被移除的 view 淡出，其他 view 移动到新的位置。<br>下面是我们 grid layout 示例的动画效果：</p>
<p><img src="https://camo.githubusercontent.com/9cf4639e6186629c70a472945c1f594020044e3b/687474703a2f2f692e656d6265642e6c792f312f646973706c61792f726573697a653f75726c3d6874747025334125324625324677697265736172656f62736f6c6574652e636f6d253246776f7264707265737325324677702d636f6e74656e7425324675706c6f61647325324632303135253246303225324644656661756c7452656379636c6572416e696d6174696f6e73536d616c6c2e6769662667726f773d74727565266b65793d3932623331313032353238353131653161326563343034306433646335633037" alt="img"></p>
<p>不过这里有个问题，一些没有被移除的 item 也淡出了。<br>这是因为它们在父控件 RecyclerView 的边界中不再可见。<br>我们想要这些 view 朝着用户期望的方向滑去，但是框架只知道<br>我们的代码在数据改变后没有显示出这些 item。此外，<br>新加入的 view 是淡入进来的，让他们从预定位置滑入界面会更好。</p>
<p>我们要给 LayoutManager 加点东西才能实现这些。</p>
<hr>
<h1 id="Predictive_Item_Animations">Predictive Item Animations</h1><p>下面的图片展示了我们期望的移除 item 动画效果：<br><img src="https://camo.githubusercontent.com/9cfc3145721cc9c0cd8cdc14ab17df2227fe5898/687474703a2f2f692e656d6265642e6c792f312f646973706c61792f726573697a653f75726c3d6874747025334125324625324677697265736172656f62736f6c6574652e636f6d253246776f7264707265737325324677702d636f6e74656e7425324675706c6f61647325324632303135253246303225324652656379636c65436f6e63657074536d616c6c2e6769662667726f773d74727565266b65793d3932623331313032353238353131653161326563343034306433646335633037266865696768743d343030" alt="img"><br>左侧一列 items 滑到右侧填补空白部分的动画很引人注意。<br>和这个差不多，你可以脑补出在这个位置添加一个 item 时的动画效果。</p>
<p>在第一篇文章里曾提到的，<code>onLayoutChildren()</code> 通常只会<br>在父控件 <code>RecyclerView</code> 初始化布局 或者 数据集的大小(比如 item 的数量)改变时调用一次。<br>Predictive Item Animations<br>这个特性允许我们给 view (基于数据改变产生)的过渡动画<br>提供更多有用的信息。想要使用这个特性，就要告诉<br>框架我们的 <code>LayoutManager</code> 提供了这个附加数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPredictiveItemAnimations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个改动，<code>onLayoutChildren()</code>会在每次数据集改变后被调用两次，<br>一次是”预布局”(pre-layout)阶段，一次是真实布局(real layout)。</p>
<hr>
<h1 id="在_pre-layout_阶段该做些什么">在  pre-layout 阶段该做些什么</h1><p>在<code>onLayoutChildren()</code>的  pre-layout 阶段，<br>你应该运行你的布局逻辑设置动画的<strong>初始状态</strong>。<br>这需要你在动画执行前布局所有 当前可见的 view <strong>和</strong> 在动画后会可见的 view<br>(被称为 <strong>APPEARING</strong> view)。Appearing views 应该被布局在<br>屏幕之外，用户期望它进入的位置。框架会捕获他们的位置，<br>籍此创建更合适的动画效果。</p>
<blockquote>
<p>我们可以使用 <code>RecyclerView.State.isPreLayout()</code> 来检测当前处于哪一阶段</p>
</blockquote>
<p>在 <code>FixedGridLayoutManager</code> 示例中，我们根据数据集的改变<br>使用  pre-layout 决定哪些 view 被移除。被移除的 view<br>在 pre-layout 的 Recycler 中仍然会被返回，所以你不用担心<br>会出现空白位置。如果你想要判断视图是否会被移除，<br>可以使用<code>LayoutParams.isViewRemoved()</code> 这个方法 。<br>我们的示例统计了被移除 view 的数量，让我们<br>对有多少空间会被 appearing views  填充有一个大概的印象。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    SparseIntArray removedCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * During pre-layout, we need to take note of any views that are</span><br><span class="line">     * being removed in order to handle predictive animations</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state.isPreLayout()) &#123;</span><br><span class="line">        removedCache = <span class="keyword">new</span> SparseIntArray(getChildCount());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; getChildCount(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lp.isItemRemoved()) &#123;</span><br><span class="line">                <span class="comment">//Track these view removals as visible</span></span><br><span class="line">                removedCache.put(lp.getViewPosition(), REMOVE_VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fill the grid for the initial layout of views</span></span><br><span class="line">    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler, state.isPreLayout(), removedCache);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：在 pre-layout 期间，RecyclerView 会尝试用 view<br>在 adapter 中的位置匹配它们的”原位置”(数据改变前的位置)。<br>如果你想通过 position 请求一个 view，并且希望这个位置<br>是这个视图初始化时的位置。就不要在 pre-layout 和<br>real-layout 期间改变它们。</p>
</blockquote>
<p>示例代码中最后的变动是对<code>fillGrid()</code>进行修改，在这里给 N<br>个 appearing views  布局，N 是被移除的可见视图个数。<br>这些 view 永远是从右侧进入的，所以他们被安排在最后一列<br>可见 view 的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillGrid</span><span class="params">(<span class="keyword">int</span> direction, <span class="keyword">int</span> emptyLeft, <span class="keyword">int</span> emptyTop, RecyclerView.Recycler recycler,</span><br><span class="line">        <span class="keyword">boolean</span> preLayout, SparseIntArray removedPositions)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVisibleChildCount(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextPosition = positionOfIndex(i);</span><br><span class="line"></span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % mVisibleColumnCount == (mVisibleColumnCount - <span class="number">1</span>)) &#123;</span><br><span class="line">            leftOffset = startLeftOffset;</span><br><span class="line">            topOffset += mDecoratedChildHeight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//During pre-layout, on each column end, apply any additional appearing views</span></span><br><span class="line">            <span class="keyword">if</span> (preLayout) &#123;</span><br><span class="line">                layoutAppearingViews(recycler, view, nextPosition, removedPositions.size(), …);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftOffset += mDecoratedChildWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutAppearingViews</span><span class="params">(RecyclerView.Recycler recycler, View referenceView,</span><br><span class="line">        <span class="keyword">int</span> referencePosition, <span class="keyword">int</span> extraCount, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Nothing to do...</span></span><br><span class="line">    <span class="keyword">if</span> (extraCount &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> extra = <span class="number">1</span>; extra &lt;= extraCount; extra++) &#123;</span><br><span class="line">        <span class="comment">//Grab the next position after the reference</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> extraPosition = referencePosition + extra;</span><br><span class="line">        <span class="keyword">if</span> (extraPosition &lt; <span class="number">0</span> || extraPosition &gt;= getItemCount()) &#123;</span><br><span class="line">            <span class="comment">//Can't do anything with this</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Obtain additional position views that we expect to appear</span><br><span class="line">         * as part of the animation.</span><br><span class="line">         */</span></span><br><span class="line">        View appearing = recycler.getViewForPosition(extraPosition);</span><br><span class="line">        addView(appearing);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Find layout delta from reference position</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newRow = getGlobalRowOfPosition(extraPosition + offset);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rowDelta = newRow - getGlobalRowOfPosition(referencePosition + offset);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newCol = getGlobalColumnOfPosition(extraPosition + offset);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> colDelta = newCol - getGlobalColumnOfPosition(referencePosition + offset);</span><br><span class="line"></span><br><span class="line">        layoutTempChildView(appearing, rowDelta, colDelta, referenceView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>layoutAppearingViews()</code>这个方法里，每一个 appearing view<br>被布局到它的”全局”位置(就是它在这个网格中占据的行/列)。<br>虽然位置在屏幕之外，但是为框架创建滑入 view 动画的起始点提供了<br>必要的数据。</p>
<hr>
<h1 id="Changes_for_the_“Real”_Layout">Changes for the “Real” Layout</h1><p><a href="/blog/recyclerview-layoutmanager-1">part1</a>中我们已经讨论过布局期间的基本工作，<br>然而要想为我们的动画提供支持还要做一些修改。<br>其中之一就是判断有没有 disappearing views。在我们的示例中<br>是通过运行一个普通的布局过程，然后检查 Recycler<br>的 scrap heap 之中有没有剩下的 view。</p>
<blockquote>
<p>注意：我们之所以能以这种方式使用 scrap heap 是因为<br>在每一次布局过程开始前，布局逻辑总是调用了<br><code>detachAndScrapAttachedViews()</code>这个方法。<br>前面说过，这是布局中你需要遵循的最佳实践。</p>
</blockquote>
<hr>
<p>Views still in scrap that aren’t considered removed are<br>disappearing views. We need to lay these views out in<br>their off-screen positions so the animation system<br>can slide them out of view (instead of just fading them out).</p>
<p>仍在 scrap 中没有被移除的视图就是 disappearing views。<br>我们需要把它们放置到屏幕之外的位置，以便动画系统<br>将它们滑出视图(用来取代淡出动画)。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state.isPreLayout() &amp;&amp; !recycler.getScrapList().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;RecyclerView.ViewHolder&gt; scrapList = recycler.getScrapList();</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;View&gt; disappearingViews = <span class="keyword">new</span> HashSet&lt;View&gt;(scrapList.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RecyclerView.ViewHolder holder : scrapList) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = holder.itemView;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (!lp.isItemRemoved()) &#123;</span><br><span class="line">                disappearingViews.add(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (View child : disappearingViews) &#123;</span><br><span class="line">            layoutDisappearingView(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutDisappearingView</span><span class="params">(View disappearingChild)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * LayoutManager has a special method for attaching views that</span><br><span class="line">     * will only be around long enough to animate.</span><br><span class="line">     */</span></span><br><span class="line">    addDisappearingView(disappearingChild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Adjust each disappearing view to its proper place</span></span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = (LayoutParams) disappearingChild.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newRow = getGlobalRowOfPosition(lp.getViewPosition());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> rowDelta = newRow - lp.row;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newCol = getGlobalColumnOfPosition(lp.getViewPosition());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> colDelta = newCol - lp.column;</span><br><span class="line"></span><br><span class="line">    layoutTempChildView(disappearingChild, rowDelta, colDelta, disappearingChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>小心：布局视图(然后将它们加入container)把它们从 scrap 列表中移除。<br>在开始变化前，小心处理你需要从 scrap 中获取的视图，否则你可能会<br>在这个集合上出现并发修改的问题结束运行。</p>
</blockquote>
<p>和之前处理 appearing views  的代码差不多，<code>layoutDisappearingView()</code><br>将所有剩余 view 放在与之对应的”全局”位置作为最终布局位置。<br>给框架提供必要信息创建出适当方向的滑出动画。</p>
<p>下面的图片可以帮你理解<code>FixedGridLayoutManager</code>之中的过程：</p>
<ul>
<li>黑框是 <code>RecyclerView</code> 的可视边界。</li>
<li>Red View：数据集中被移除的 item。</li>
<li>Green View (Appearing View)：开始时没有，在 pre-layout 过程中被布局到屏幕外的item。</li>
<li>Purple Views (Disappearing views)：pre-layout 时期放置在他们的原始位置 ，<br>  real-layout 时期被布局到屏幕之外的位置。</li>
</ul>
<p><img src="https://camo.githubusercontent.com/d8e58642a7c58dce8bd7ad7123a565b86d9bd55c/687474703a2f2f692e656d6265642e6c792f312f646973706c61792f726573697a653f75726c3d6874747025334125324625324677697265736172656f62736f6c6574652e636f6d253246776f7264707265737325324677702d636f6e74656e7425324675706c6f61647325324632303135253246303225324652656379636c6552656d6f76652e6769662667726f773d74727565266b65793d3932623331313032353238353131653161326563343034306433646335633037266865696768743d343030" alt="img"></p>
<hr>
<h1 id="响应屏幕外的变动">响应屏幕外的变动</h1><p>你或许注意到在上一节中我们可以判断可视 views 的移除操作。<br>如果变化出现在可视边界之外会怎样？这取决于你的布局结构，<br>像这样的变化可能需要你调整布局来达到更好的动画效果。</p>
<p>Adapter 会将这个变化 post 给你的 LayoutManager。你可以覆写<br><code>onItemsRemoved()</code>, <code>onItemsMoved()</code>, <code>onItemsAdded()</code> 或者<br><code>onItemsChanged()</code> 响应 item 的这些事件，无论 item<br>在当前布局中是否可见。</p>
<p>如果被移除的范围在可视边界之外， 调用 pre-layout 之前会调用<br><code>onItemRemoved()</code>。我们可以利用它收集和这个变化有关的数据，为<br>这个事件可能触发的  appearing view 改变提供更好的支持。</p>
<p>示例中，我们像之前一样收集被移除的 view，但是将它们标记成不同的类型。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemsRemoved</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> positionStart, <span class="keyword">int</span> itemCount)</span> </span>&#123;</span><br><span class="line">    mFirstChangedPosition = positionStart;</span><br><span class="line">    mChangedPositionCount = itemCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    SparseIntArray removedCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * During pre-layout, we need to take note of any views that are</span><br><span class="line">     * being removed in order to handle predictive animations</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (state.isPreLayout()) &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Track view removals that happened out of bounds (i.e. off-screen)</span></span><br><span class="line">        <span class="keyword">if</span> (removedCache.size() == <span class="number">0</span> &amp;&amp; mChangedPositionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mFirstChangedPosition; i &lt; (mFirstChangedPosition + mChangedPositionCount); i++) &#123;</span><br><span class="line">                removedCache.put(i, REMOVE_INVISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fill the grid for the initial layout of views</span></span><br><span class="line">    fillGrid(DIRECTION_NONE, childLeft, childTop, recycler, state.isPreLayout(), removedCache);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>TIP：如果被移除的 item 是可见的，这个方法在 pre-layout<br>之后还会被调用。这也就是为什么<br>当被移除的可见 views 出现时我们仍要从它们获取数据。</p>
</blockquote>
<p>所有步骤就位，现在我们可以启动这个应用啦。可以看到左边消失的items<br>移到对应行的后面。右边新出现的 items 滑动进入现有的界面。<br>现在，新的动画中只有被移除的 item 是淡出的了。</p>
<p><img src="https://camo.githubusercontent.com/0e305a3451a7bdc3681bf06c34abc95aba0d9f47/687474703a2f2f692e656d6265642e6c792f312f646973706c61792f726573697a653f75726c3d6874747025334125324625324677697265736172656f62736f6c6574652e636f6d253246776f7264707265737325324677702d636f6e74656e7425324675706c6f6164732532463230313525324630322532465072656469637469766552656379636c6572416e696d6174696f6e73536d616c6c2e6769662667726f773d74727565266b65793d3932623331313032353238353131653161326563343034306433646335633037" alt="img"></p>
<hr>
<h1 id="未完待续…">未完待续…</h1><p>我说过…这应该是这系列中的最后一篇。不过，在编写 <code>FixedGridLayoutManager</code><br>动画效果的过程中又出现了些有趣的问题，并不是所有自定义的实现。<br>所以在下一篇文章里(这次真的是最后一篇了)，我会解决这些问题。</p>
<p>特别感谢 <a href="https://plus.google.com/111851968937104436377/posts" target="_blank" rel="external">Yiğit Boyar</a>提供技术支持，帮助完成这篇文章。</p>
<hr>
<ol>
<li>如果你的 adapter 使用了固定的 IDs ，可以提供足够的数据推测哪些 view 被 移除/添加/等等<br> 框架就会尝试 给它添加动画    <a id="b1" href="#1">↩</a></li>
</ol>
<hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://wiresareobsolete.com/2015/02/recyclerview-layoutmanager-3/" target="_blank" rel="external">Building a RecyclerView LayoutManager – Part 3</a></li>
<li>原文作者 : <a href="https://github.com/devunwired" target="_blank" rel="external">Dave Smith</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/tiiime" target="_blank" rel="external">tiiime</a> </li>
<li>校对者:<a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>状态 :   完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文是这个系列中的 Part 3。<br>]]>
    
    </summary>
    
      <category term="SupportLibrary" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/SupportLibrary/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优化android studio编译效率的方法]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/boosting-the-performance-for-gradle-in-your-android-projects/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/boosting-the-performance-for-gradle-in-your-android-projects/</id>
    <published>2015-06-05T16:00:00.000Z</published>
    <updated>2015-07-11T10:01:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>如果你之前用eclipse开发过Android app的化,转到android studio的第一反应也许就是:”编译速度有点慢”. 表现的最明显的一点就是,当我使用eclipse开发的时候,选中了auto building.这个时候<br>我更改了几个字符,eclipse会速度非常快的编译出一个新的apk. 而android studio使用gradle编译,每次编译,即便是更改的代码量很少,也会按照预先设置的task的顺序,依次走完编译的各项流程.所以<br>这点就让人很痛苦. 然而问题总还是要被解决的,作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下). 现在把如何优化gradle编译速度的方法记录在此,希望可以<br>帮助到广大的同行们.<br><a id="more"></a></p>
<h2 id="准备工作">准备工作</h2><p>gradle现在最新的版本是2.4, 相比较之前的版本, 在编译效率上面有了一个非常大的提高,为了确保你的android项目使用的是最新版的gradle版本,有两种方法可以使用,下面依次进行介绍</p>
<h3 id="1、在build-gradle中进行设置">1、在build.gradle中进行设置</h3><p>在你的项目gradle文件内(不是app里面的gradle文件), 添加一个task, 代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">wrapper</span><span class="params">(type: Wrapper)</span> </span>&#123;</span><br><span class="line">    gradleVersion = <span class="string">'2.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开terminal, 输入./gradlew wrapper, 然后gradle就会自动去下载2.4版本,这也是官方推荐的手动设置gradle的方法(<a href="http://gradle.org/docs/current/userguide/gradle_wrapper.html" target="_blank" rel="external">http://gradle.org/docs/current/userguide/gradle_wrapper.html</a>)</p>
<h3 id="2、使用android_studio对gradle版本进行设置">2、使用android studio对gradle版本进行设置</h3><p>这种方法需要你去手动去gradle官网下载一个zip包,解压缩后,打开android studio 设置界面的Project Structure. 然后手动添加你解压缩后的gradle的磁盘路径即可,可以参考如下的图片</p>
<p><img src="https://camo.githubusercontent.com/3a35c7915162657fb87261a367fdbcf20da12b5a/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363034313034393034393033" alt="image"></p>
<p>有一点需要注意的是,这种设置方法仅适用于在你的项目中使用gradle wrapper进行编译打包的操作(就是android studio默认需要的东东).如果你想使用gradle做其他的事情,请出门左转,去gradle官网(<a href="http://gradle.org" target="_blank" rel="external">http://gradle.org</a>)</p>
<h2 id="守护进程,并行编译">守护进程,并行编译</h2><p>通过以上步骤,我们设置好了android studio使用最新的gradle版本,下一步就是正式开启优化之路了. 我们需要将gradle作为守护进程一直在后台运行,这样当我们需要编译的时候,gradle就会立即跑过来然后<br>吭哧吭哧的开始干活.除了设置gradle一直开启之外,当你的工作空间存在多个project的时候,还需要设置gradle对这些projects并行编译,而不是单线的依次进行编译操作.</p>
<p>说了那么多, 那么怎么设置守护进程和并行编译呢?其实非常简单,gradle本身已经有了相关的配置选项,在你电脑的GRADLE_HOME这个环境变量所指的那个文件夹内,有一个<code>.gradle/gradle.properties</code>文件.<br>在这个文件里,放入下面两句话就OK了:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org<span class="class">.gradle</span><span class="class">.daemon</span>=true</span><br><span class="line">org<span class="class">.gradle</span><span class="class">.parallel</span>=true</span><br></pre></td></tr></table></figure>
<p>有一个地方需要注意的是,android studio 本身在编译的时候,已经是使用守护进程中的gradle了,那么这里加上了org.gradle.daemon=true就是保证了你在使用命令行编译apk的时候也是使用的守护进程.</p>
<p>你也可以将上述的配置文件放到你project中的根目录下,以绝对确保在任何情况下,这个project都会使用守护进程进行编译.不过有些特殊的情况下也许你应该注意守护进程的使用,具体的细节参考<a href="http://gradle.org/docs/current/userguide/gradle_daemon.html#when_should_i_not_use_the_gradle_daemon" target="_blank" rel="external">http://gradle.org/docs/current/userguide/gradle_daemon.html#when_should_i_not_use_the_gradle_daemon</a></p>
<p>在使用并行编译的时候必须要注意的就是,你的各个project之间不要有依赖关系,否则的话,很可能因为你的Project A 依赖Project B, 而Project B还没有编译出来的时候,gradle就开始编译Project A 了.最终<br>导致编译失败.具体可以参考<a href="http://gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects。" target="_blank" rel="external">http://gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects。</a></p>
<p>还有一些额外的gradle设置也许会引起你的兴趣,例如你想增加堆内存的空间,或者指定使用哪个jvm虚拟机等等(代码如下)  </p>
<p>org.gradle.jvmargs=-Xmx768m<br>org.gradle.java.home=/path/to/jvm</p>
<p>如果你想详细的了解gradle的配置,请猛戳<a href="http://gradle.org/docs/current/userguide/userguide_single.html#sec:gradle_configuration_properties" target="_blank" rel="external">http://gradle.org/docs/current/userguide/userguide_single.html#sec:gradle_configuration_properties</a></p>
<h2 id="一个实验性的功能">一个实验性的功能</h2><p>最后一个要介绍的是incremental dexing, 这个功能目前还在试验阶段,android studio默认是关闭的, 作者个人是非常推荐的,程序员就是爱折腾啊.</p>
<p>开启incremental dexing也是非常简单的,就是在app级别的buid.gradle文件中加入下面的代码:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dexOptions</span> &#123;</span><br><span class="line">        <span class="title">incremental</span> <span class="built_in">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感性您的阅读,希望这边文章可以对您有所帮助. 如果您有好的建议或者意见请联系我</p>
<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/@erikhellman/boosting-the-performance-for-gradle-in-your-android-projects-6d5f9e4580b6" target="_blank" rel="external">Boosting the performance for Gradle in your Android projects</a></li>
<li>原文作者 : <a href="https://medium.com/@erikhellman" target="_blank" rel="external">Erik Hellman</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/FTExplore" target="_blank" rel="external">FTExplore</a> </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="引言">引言</h2><p>如果你之前用eclipse开发过Android app的化,转到android studio的第一反应也许就是:”编译速度有点慢”. 表现的最明显的一点就是,当我使用eclipse开发的时候,选中了auto building.这个时候<br>我更改了几个字符,eclipse会速度非常快的编译出一个新的apk. 而android studio使用gradle编译,每次编译,即便是更改的代码量很少,也会按照预先设置的task的顺序,依次走完编译的各项流程.所以<br>这点就让人很痛苦. 然而问题总还是要被解决的,作者曾经亲眼看到过使用android studio仅仅用了2.5秒就编译完毕(在代码更改很少的情况下). 现在把如何优化gradle编译速度的方法记录在此,希望可以<br>帮助到广大的同行们.<br>]]>
    
    </summary>
    
      <category term="AndroidStudio" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/AndroidStudio/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="AndroidIDE" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/AndroidIDE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建-RecyclerView-LayoutManager-Redux]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/recyclerview-layoutmanager-redux/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/recyclerview-layoutmanager-redux/</id>
    <published>2015-06-05T16:00:00.000Z</published>
    <updated>2015-07-11T10:07:59.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章是RecyclerView系列文章的结尾篇。<br>当我在写这个系列的最后一篇文章，也就是关于predictIve animation的讨论时，我突然想到几个很有意思的点，并且很有讨论价值。这个系列文章以调查RecyclerView是否能够以简单的方式满足竖向、横向滚动的布局需求以及开发者要定制一个LayoutManager的难度有多大开始。这篇文章中我选择了一个基本的网格布局作为自定义layoutManager的示例。<br><a id="more"></a><br>下面这幅图展示了运用这个自定义LayoutManager到RecyclerView的滚动效果。       </p>
<p><img src="https://camo.githubusercontent.com/3595391f951510c51bc3201d2686eb3e279f8cc7/687474703a2f2f692e656d6265642e6c792f312f646973706c61792f726573697a653f75726c3d6874747025334125324625324677697265736172656f62736f6c6574652e636f6d253246776f7264707265737325324677702d636f6e74656e7425324675706c6f6164732532463230313525324630322532464772696457696e646f772e6769662667726f773d74727565266b65793d3932623331313032353238353131653161326563343034306433646335633037266865696768743d343030" alt=""></p>
<h2 id="打破常规设计">打破常规设计</h2><p>无论你打算如何组织Adapter的位置（从左到右，上到下等等）,内容视图的视角都是显示部分不连贯数据集的区域。更确切地说，在第一个和最后一个可视位置之间的Adapter区域的数据项也会在可视区域view的外面。 </p>
<p>这是一个很重要的点，因为它与在单轴上滚动的布局大相径庭（从而导致与当前框架下提供的默认布局背道而驰）。这些标准小工具显示，数据集是在一个连接块范围内—从第一个到最后一个可视位置之间不间断。</p>
<p>RecyclerView LayoutManager API会假定有一个可见的数据集合，RecyclerView LayoutManager只会显示数据集合中某个范围内可见的数据项，然后产生一个像上述所展示的网格布局一样的布局效果，这稍微有那么点挑战。在predictive animation里没有什么比这部分更加明显了。为了便于扩展，我感觉在这里指出这些毛病是非常必要的。</p>
<h2 id="假设1_：_从不可见区域移除一个数据项不会影响当前可见的View">假设1 ： 从不可见区域移除一个数据项不会影响当前可见的View</h2><p>当你考虑到一个Adapter移除一个数据项时LinearLayoutManager或者GridLayoutManager会做何反应时，这两个LayoutManager实际上都处理得非常好。如果被移除的数据项是可见的，一个可用的区域将会空置出来，此时就需要一个周边的View进行填充。这意味着周边显示的View必须被布局到这个位置以填补缺口。然而，并没有一个示例表明当一个移除操作执行时会发送一个隐藏视图的操作，唯一被隐藏的视图是那些被显式移除的。如果被移除的View在可见区域之外，那么对于可见区域的布局不会产生影响。在这个情况之下，你不会看到任何动画，它可能做出的修改是数据项被移到其他位置。</p>
<p>从上述的情况看，这与文章开头我们提到的一样，LayoutManager显示的是一个不连续的数据项。然而，这一可视区域的不连续本质使得数据项在屏幕外从可视区域内移除！换种说法，它们的位置处于第一个和最后一个位置之间，但是目前数据项view并不在布局中。这导致的结果就是，屏幕外发生的数据项移除可以并且会影响我们在布局动画处理时view的生成和消失。</p>
<p>在有机会对view的生成进行布局时，预布局是RecyclerView动画的关键阶段。RecyclerView通过其初始位置值将view返回，据此我们可以将内容布局在其初始状态。但是，当view移除与可视区域不相交时。RecyclerView就会通过其最终位置值将view返回。这样一来，在没有附加记账的情况下处理view的生成就变得困难得多。不过话说回来，难是难，也还是可以做到。</p>
<p>在上一篇文章中我们看到的FixedGridLayoutManager，我们不仅要解析可视view，还要听从onItemsRemoved()的回调来找到移除点，并妥当处理所有生成的view案例。RecyclerView确保我们在需要时，该回调会在预布局之前出现（屏幕外案例），但相反情况下会在预布局之后出现。RecyclerView这么做是为了避免这些事件与你的布局产生冲突—其时间点对我们来说只是一个美丽的意外。</p>
<p>我们还需要追踪的一个事实就是，可视移除会以一种我们意料之中的方式偏移view的位置，而屏幕外移除则不会。这也是为什么移除会被冠以不同类型的原因。上一篇文章忽略的一点表明，在屏幕外进行移除时，我们会对view生成逻辑提供一个手动偏移。。。所以当移除可视时，位置之间会相互匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillGrid</span><span class="params">(<span class="keyword">int</span> direction, <span class="keyword">int</span> emptyLeft, <span class="keyword">int</span> emptyTop, RecyclerView.Recycler recycler,</span><br><span class="line">        <span class="keyword">boolean</span> preLayout, SparseIntArray removedPositions)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVisibleChildCount(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextPosition = positionOfIndex(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * When a removal happens out of bounds, the pre-layout positions of items</span><br><span class="line">         * after the removal are shifted to their final positions ahead of schedule.</span><br><span class="line">         * We have to track off-screen removals and shift those positions back</span><br><span class="line">         * so we can properly lay out all current (and appearing) views in their</span><br><span class="line">         * initial locations.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">int</span> offsetPositionDelta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (preLayout) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetPosition = nextPosition;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; removedPositions.size(); offset++) &#123;</span><br><span class="line">                <span class="comment">//Look for off-screen removals that are less-than this</span></span><br><span class="line">                <span class="keyword">if</span> (removedPositions.valueAt(offset) == REMOVE_INVISIBLE</span><br><span class="line">                        &amp;&amp; removedPositions.keyAt(offset) &lt; nextPosition) &#123;</span><br><span class="line">                    <span class="comment">//Offset position to match</span></span><br><span class="line">                    offsetPosition--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            offsetPositionDelta = nextPosition - offsetPosition;</span><br><span class="line">            nextPosition = offsetPosition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextPosition &lt; <span class="number">0</span> || nextPosition &gt;= getItemCount()) &#123;</span><br><span class="line">            <span class="comment">//Item space beyond the data set, don't attempt to add a view</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % mVisibleColumnCount == (mVisibleColumnCount - <span class="number">1</span>)) &#123;</span><br><span class="line">            leftOffset = startLeftOffset;</span><br><span class="line">            topOffset += mDecoratedChildHeight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//During pre-layout, on each column end, apply any additional appearing views</span></span><br><span class="line">            <span class="keyword">if</span> (preLayout) &#123;</span><br><span class="line">                layoutAppearingViews(recycler, view, nextPosition, removedPositions.size(), offsetPositionDelta);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftOffset += mDecoratedChildWidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后offsetPositionDelta值会作为我们在预布局中使用到的行/列位置的全局偏移被传递到layoutAppearingViews()。如果不是出于附加记账要求，这一偏移完全可以不必存在。</p>
<h2 id="假设#2：添加新的数据项只会导致同级view的消失，而不是生成。">假设#2：添加新的数据项只会导致同级view的消失，而不是生成。</h2><p>添加了新的数据项之后，反面为真。如果在添加时数据项为可视，那么标准布局管理器会在屏幕外推开不可视的view以便腾出空间。之前没有出现过关于这种行为会同时触发一个或多个同级view滑向可视子类位置的案例。移除也是同样的道理，在可视区域外添加数据项并不会影响可视view，所以通常来说动画也不会起作用。</p>
<p>对于FixedGridLayoutManager或其他任何非连贯区域的布局，在可视区域内还是可视区域外进行添加并没有多大差别。两种情况中我们都需要管理可能出现的view生成和消失。而我们在移除中使用的方案在这里则不可行，因为onItemsAdded()总是在预布局之后被调用。。。这一次我们就没那么幸运地再一次能够碰到美丽的意外了。</p>
<p>缺少了那次回调，关于添加数据项，我们实际上在预布局时就没有多少可做的了。这样一来就变成了布局额外的view以备不时之需，而不布局一定量的额外view就会损害性能这两种情况之间的妥协。FixedGridLayoutManager在添加数据项时不支持预测view生成。</p>
<h2 id="一切才刚刚开始">一切才刚刚开始</h2><p>RecyclerView APIs是一个新生事物，现有案例中还有非常多的地方需要改进的。同时，它也非常复杂，想要做对并不容易。表面上看起来RecyclerView要求大家付出的努力，背后可能大家要花10倍的精力才能实现。而且这些类型越到后面可能月蛋疼。希望正在尝试这种做法的各位同仁可以视本文为一个预警，不要盲目浪费时间，但同时我们也期待这这个框架的日渐成熟。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://wiresareobsolete.com/2015/02/recyclerview-layoutmanager-redux/" target="_blank" rel="external">Building A RecyclerView LayoutManager – Redux</a></li>
<li>原文作者 : <a href="https://github.com/devunwired" target="_blank" rel="external">Dave Smith</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a> </li>
<li>校对者: <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a>  </li>
<li>状态 :  完成 </li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章是RecyclerView系列文章的结尾篇。<br>当我在写这个系列的最后一篇文章，也就是关于predictIve animation的讨论时，我突然想到几个很有意思的点，并且很有讨论价值。这个系列文章以调查RecyclerView是否能够以简单的方式满足竖向、横向滚动的布局需求以及开发者要定制一个LayoutManager的难度有多大开始。这篇文章中我选择了一个基本的网格布局作为自定义layoutManager的示例。<br>]]>
    
    </summary>
    
      <category term="SupportLibrary" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/SupportLibrary/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/%E8%BF%9E%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 进行单元测试难在哪-终]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/what-ive-learned-from-trying-to-make-an-android-app-unit-testable/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/what-ive-learned-from-trying-to-make-an-android-app-unit-testable/</id>
    <published>2015-06-05T16:00:00.000Z</published>
    <updated>2015-07-11T09:55:36.000Z</updated>
    <content type="html"><![CDATA[<p>在前面的博文中，我给大家介绍并展示了要怎么使用 Square 大法架构 Android 应用，事实上，Square 开发新的 Android 应用架构本意只是增强应用的可测试性。正如我在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-8/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-%E5%BA%8F.md" target="_blank" rel="external">Android 进行单元测试难在哪-序</a>中所说，要在 Android 中进行单元测试在大多数情况下都很费时，尝试一些奇技淫巧或者第三方库情况可能会好一些。为了实现高效且不依赖第三方库的测试单元，Square 大法应运而生。<br><a id="more"></a><br>此外，我们在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-9/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part1.md" target="_blank" rel="external"> Android 进行单元测试难在哪-part1</a>和<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-11/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part3.md" target="_blank" rel="external"> Android 进行单元测试难在哪-part3</a>两篇博文就这个问题进行了研究，最后成功地通过 Square 大法为 Android 应用实现了测试单元，这篇文章则是对 Square 大法进行评估，我将从下面三个方面进行：</p>
<ol>
<li><p>为 Android 应用实现高效的测试单元并不需要移除所有对 Android SDK 的编译时依赖。（事实上这样做有些不切实际。）</p>
</li>
<li><p>加入我们重新设计 Square 大法，使 Square 大法的使用不需要移除所有对 Android SDK 的编译时依赖，尝试将 Square 大法运营到项目中唯一会发生的问题是：实现一大堆模板代码。幸运的是，许多诸如此类的模板代码都可以通过 Android Studio 自动生成。</p>
</li>
<li><p>依赖注入确实是让 Square 大法成为应用可测试性治病良方的好办法。</p>
</li>
</ol>
<h2 id="移除所有对_Android_SDK_的编译时依赖既不必要也不切合实际">移除所有对 Android SDK 的编译时依赖既不必要也不切合实际</h2><p>完成这个系列博文的最初愿望就是通过让 Android 应用栈变成下图那样，增强应用的可测试性：</p>
<p><img src="https://camo.githubusercontent.com/c143440dd1cc02efcde454313ff365c05c8cd4fa/687474703a2f2f69322e77702e636f6d2f7777772e7068696c6f736f70686963616c6861636b65722e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031352f30342f616e64726f6964737461636b2d30322e706e673f726573697a653d323739253243313732" alt=""></p>
<p>接下来我将告诉大家，这个想法一直误导着我们。要使应用的可测试性增强，我们还需要利用依赖注入的其它特性，而不仅仅是用它将业务逻辑代码和 Android SDK 解耦。最初的原因是对象的 Android 依赖可以通过类似 Mockito 的东西模拟出来，而且如果我们无法单独通过 Mocktio 完全控制测试单元的预测试状态的话，我们还可以用具有 mock 实现的接口代替这些 Android 依赖。而这也正是我们在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-12/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part4.md" target="_blank" rel="external"> Android 进行单元测试难在哪-part4</a>中重构 SessionRepositoryManager 的办法。</p>
<p>移除依赖不仅是不必要的，将它完全与 Android SDK 解耦也是不切实际的，问题在于：当你尝试完成这个目标时，不妨回顾你已经完成的工作，你会很明显地感觉这是不必要的，所以我只打算在此简要地陈述个中因由。</p>
<p>要移除移除应用中所有对 Android SDK 的编译时依赖可能会导致下面的问题：</p>
<ol>
<li><p>应用必须为此定义许多方法和类。</p>
</li>
<li><p>添加的接口和已有的 Android 接口几乎一样。</p>
</li>
<li><p>由于有些情况下，对象需要被注入；有些情况下，对象不需要被注入，带有依赖的类构造器会因此变得很臃肿。</p>
</li>
</ol>
<p>虽然 Square 大法存在一些问题，但这并不影响我在之前的博文中有关 Square 的讲解，Square 的这些特性依旧是实用，值得尝试的。由于 Android SDK 供予我们使用的应用组件类都没有被依赖注入，我们要在 Android 应用中进行单元测试确实很困难，但有了 Square 大法后，只要我们将业务逻辑交给被依赖注入的纯 Java 对象，就能轻易地对 Android 应用进行单元测试。尽管 Square 大法减小了移除 Android SDK 依赖的需求，但 Square 大法仍然是增强应用可测试性的屠龙宝刀。但我个人还是希望对 Square 大法进行优化，使得 Square 大法能无视这个需求，换句话说，我希望能够找到一种不需要我们移除所有对 Android SDK 依赖的架构方法，</p>
<h2 id="乏味的模板代码是阻碍应用变得可测试的绊脚石">乏味的模板代码是阻碍应用变得可测试的绊脚石</h2><p>如果我们对 Square 大法进行优化，使其不再要求我们移除对 Android SDK的依赖，Square 大法看起来真的是天下第一的神功了。委以业务逻辑的纯 Java 对象将被应用组件类引用，使它们能够访问所有组件类内的属性和回调。因此，将业务逻辑转移到进行了依赖注入的纯 Java 对象，不应该将那些拥有履行自身职责的数据的对象排除在外。</p>
<p>如果这是正确的，那么唯一阻止我们使用 Square 大法的就是实现乏味的模板代码。幸运的是，Android Studio 为我们提供了过渡到 Square 大法的重构选项——the Extract Delegate option。利用这个选项，可以自动地将类的方法和实例变量转移到一个委托类中，并让原始类通过调用委托类处理逻辑，而不用依赖类自身的方法。</p>
<p>这个<a href="www.youtube.com/embed/N0F7w4wEnQ8">视频</a>向我们展示了如何利用 <code>the Extract Delegate option</code> 完成重构 SessionDetailActivity 的 onStop() 并使之能够进行单元测试必要的操作。我曾在之前的博文中给大家解释过进行这样的重构为什么是必要的，很显然，手动操作无法涵盖所有情况，而且你需要为此不断重复实现代码语句块中分离 Activity View 和数据的方法，这样重复而又没有意义的工作无异于浪费生命，因此这个选项真的非常实用。</p>
<h2 id="依赖注入是_Square_大法的精髓">依赖注入是 Square 大法的精髓</h2><p><a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-11/Android%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-part3.md" target="_blank" rel="external">Android 进行单元测试难在哪-part3</a>的秘密在于：<strong>依赖注入</strong>。</p>
<p>— Chris Arriola (@arriolachris) <a href="https://twitter.com/arriolachris/status/599232312492982273" target="_blank" rel="external">May 15, 2015</a></p>
<p>Square 大法之所以能解决 Android 的单元测试问题，是因为它允许我们对持有业务逻辑的类进行真正的依赖注入，我之所以强调 Square 允许我们进行的是<strong>真正的</strong>依赖注入，是因为依赖注入这个概念在 Dagger 库中也被提到过，然而，Dagger 并不能真正简化 Android 应用进行单元测试的代码。</p>
<p>这是因为 Dagger 就像它介绍的那样，确实是一个 Service 定位库，正是如此，Dagger 强迫我们实现一个模块，使之为我们想要进行单元测试的对象提供 mock 依赖。为了能利用这些模块，我们还要确保由这些 mock 提供者模块构建的对象图与我们尝试进行单元测试的对象使用的对象图相同。</p>
<p>而正是这样的操作使得 Dagger 的依赖注入不如 Square 大法中真正的依赖注入那样简便，解释为什么 Dagger 不能简化对 Android 应用进行单元测试的过程完全可以写一篇博文，所以现在，我唯一能做的就是先指出这个问题，如果我们理解<a href="http://martinfowler.com/articles/injection.html#InversionOfControl" target="_blank" rel="external"> Martin Fowler 对依赖注入的定义</a>（这篇博文确实值得一读，因为他创建了一个新的术语），就会发现 Dagger 确实只是一个 Service 定位库，而且 Google 官方有关测试的博客也有<a href="http://martinfowler.com/articles/injection.html#InversionOfControl" target="_blank" rel="external">一篇博文</a>对此作出解释。</p>
<h2 id="结论">结论</h2><p>如果想让 Android 应用可以进行单元测试，那就用 Square 大法吧，当然了，如果有其他解决办法的话我也会支持的。在这里友情提示一下哈：我只是列出我了解的几种办法，我可没有说 Square 大法天下第一无人可敌，事实上增强应用可测试性应该还会有其他办法的。</p>
<p>这篇博文的发布也预示着这系列博文走向终结啦，我非常感谢每一个关注本系列博文的 Android 开发者的支持，感谢每一个人对我的鼓励、转发以及大家在社交媒体上对我的褒奖，我感恩这一切。这些积极的反馈使我认识到讨论和思考对 Android 应用进行测试的重要性，正是完成这个系列博文给我带来的启示使我决定：我要在未来花费更多的时间在博客中研究 Android 测试方面的知识。我会在每个周五更新博客，希望能学习更多有关测试的知识，和大家一起进步。</p>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.philosophicalhacker.com/2015/05/22/what-ive-learned-from-trying-to-make-an-android-app-unit-testable/" target="_blank" rel="external">WHAT I’VE LEARNED FROM TRYING TO MAKE AN ANDROID APP UNIT TESTABLE</a></li>
<li>原文作者 : <a href="http://philosophicalhacker.com/" target="_blank" rel="external">Matthew Dupree</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a> </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在前面的博文中，我给大家介绍并展示了要怎么使用 Square 大法架构 Android 应用，事实上，Square 开发新的 Android 应用架构本意只是增强应用的可测试性。正如我在<a href="https://github.com/bboyfeiyu/android-tech-frontier/blob/master/issue-8/Android%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9A%BE%E5%9C%A8%E5%93%AA-%E5%BA%8F.md">Android 进行单元测试难在哪-序</a>中所说，要在 Android 中进行单元测试在大多数情况下都很费时，尝试一些奇技淫巧或者第三方库情况可能会好一些。为了实现高效且不依赖第三方库的测试单元，Square 大法应运而生。<br>]]>
    
    </summary>
    
      <category term="测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="单元测试" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Square：从今天开始抛弃Fragment吧！]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/advocating-against-android-fragments/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/06/06/advocating-against-android-fragments/</id>
    <published>2015-06-05T16:00:00.000Z</published>
    <updated>2015-07-11T10:02:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近我在 Droidcon Paris 上进行了<a href="http://fr.droidcon.com/2014/agenda/detail?title=D%C3%A9fragmentez+vos+apps+avec+Mortar+%21" target="_blank" rel="external">一个技术相关的演讲</a>，我在这次演讲中给大家展示了 Square 使用 Fragment 进行开发时遇到的种种问题，以及其他 Android 开发者是怎么避免在项目中使用 Fragment 的。</p>
<p>在 2011 年那会，由于下面的原因我们决定使用 Fragment：</p>
<ul>
<li><p>在那会，虽然我们很想让应用能在平板设备上被使用，但我们确实没能为平板提供平台支持。而 Fragment 能帮助我们完成这项愿望，建立响应式 UI 界面。</p>
</li>
<li><p>Fragment 是视图控制器，它们能够将一大块耦合严重的业务逻辑模块解耦，并使得解耦后的业务逻辑能够被测试。</p>
</li>
<li><p>Fragment 的 API 能够进行回退栈管理（例如，它能反射某个 Activity 内 Activity 栈的具体操作）</p>
</li>
<li><p>因为 Fragment 处于视图层的顶层，而为 View 设置动画并不麻烦，使得 Fragment 为设置页面切换的过渡效果提供了更好的支持。</p>
</li>
<li><p>Google 建议我们使用 Fragment，而我们作为开发者都想让自己的代码符合标准。</p>
</li>
</ul>
<p>在 2011年之后，我们在为 Square 进行开发的过程中发现了比使用 Fragment 更好的方法。<br><a id="more"></a></p>
<h1 id="关于_Fragment_你不知道的事">关于 Fragment 你不知道的事</h1><h2 id="The_lolcycle">The lolcycle</h2><p>在 Android 中，Context 就像一个<a href="http://en.wikipedia.org/wiki/God_object" target="_blank" rel="external">上帝对象</a>，因为在 Context 类中涵盖了太多 Android 系统的信息和相关的操作，使得 Context 在 Android 系统中相当于一个全知全能的上帝，而 Activity 就是为 Context 添加了生命周期的子类。不过让上帝具有生命周期还是有些讽刺的。虽然 Fragment 不是上帝对象，但 Fragment 为了能够完成 Activity 中能完成的各种操作，使 Fragment 自身的生命周期变得异常复杂。</p>
<p>Steve Pomeroy 做了一张<a href="https://github.com/xxv/android-lifecycle" target="_blank" rel="external"> Fragment 的完整生命周期图</a>，我相信任谁看到这张图都不会好受：</p>
<p><img src="https://camo.githubusercontent.com/ee85363da203d14de689d8df8f9059aed70df00b/68747470733a2f2f636f726e65722e73717561726575702e636f6d2f696d616765732f6e6f2d667261676d656e74732f6c6966656379636c652e706e67" alt=""></p>
<p>这张图由 Steve Pomeroy 完成，图中移除了 Activity 的生命周期，分享这张图需要获得 <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="external">CC BY-SA 4.0</a> 许可。</p>
<p>整个 Fragment 的生命周期让你很头疼要怎样使用这些回调方法，它们是同步调用的呢，还是只是一次性全部调用呢，还是其它情况……？</p>
<h2 id="难于调试">难于调试</h2><p>当你的应用出现 Bug，你得用调试工具一步一步地执行代码才能知道到底发生了什么，虽说一般情况下这样做 Bug 都能解决，但如果你在调试的时候发现 Bug 和 FragmentManagerImpl 类存在某种联系，那么我可要好好恭喜你即将中大奖了！</p>
<p>因为要跟踪 FragmentManagerImpl 类内代码的执行顺序，并进行调试是很困难的，这也使得修复应用中相关的 Bug 也变得异常困难：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (f.mState) &#123;</span><br><span class="line">    <span class="keyword">case</span> Fragment.INITIALIZING:</span><br><span class="line">        <span class="keyword">if</span> (f.mSavedFragmentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray(</span><br><span class="line">                    FragmentManagerImpl.VIEW_STATE_TAG);</span><br><span class="line">            f.mTarget = getFragment(f.mSavedFragmentState,</span><br><span class="line">                    FragmentManagerImpl.TARGET_STATE_TAG);</span><br><span class="line">            <span class="keyword">if</span> (f.mTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                f.mTargetRequestCode = f.mSavedFragmentState.getInt(</span><br><span class="line">                        FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            f.mUserVisibleHint = f.mSavedFragmentState.getBoolean(</span><br><span class="line">                    FragmentManagerImpl.USER_VISIBLE_HINT_TAG, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!f.mUserVisibleHint) &#123;</span><br><span class="line">                f.mDeferStart = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (newState &gt; Fragment.STOPPED) &#123;</span><br><span class="line">                    newState = Fragment.STOPPED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你曾经需要解决应用旋转后产生一个与旋转前 UI 相同（方向发生变化）的独立的 Fragment 的需求，我想你应该懂我在说什么。（别给我提嵌套使用的 Fragment！）</p>
<p>我想下面这张图很好地诠释了这类代码给程序员带来的伤害（由于版权问题我得放出这张图的出处哈：<a href="http://www.osnews.com/story/19266/WTFs_m" target="_blank" rel="external">this cartoon</a>）：</p>
<p><img src="https://camo.githubusercontent.com/b9f1bca6508010b61a8e246299d2e8c24c41e3a8/68747470733a2f2f636f726e65722e73717561726575702e636f6d2f696d616765732f6e6f2d667261676d656e74732f636f64652d7175616c6974792e706e67" alt=""></p>
<p>在多年的深度分析中我得出结论：操蛋程度/调试耗费的时间 = 2^m，m 为 Fragment 的个数。</p>
<h2 id="Fragment_是视图控制器？想太多">Fragment 是视图控制器？想太多</h2><p>因为 Fragment 需要创建、绑定和配置 View，它们包含了许多与 View 关联的结点，这就意味着 View 类代码中的业务逻辑并没有真正地被解耦，正是这个原因使得我们要为 Fragment 实现测试单元将会变得很困难。</p>
<h2 id="Fragment_transactions">Fragment transactions</h2><p>Fragment 的 transaction 允许你执行一系列的 Fragment 操作，但不幸的是，提交 transaction 是异步操作，并且在 UI 线程的 Handler 队列的队尾被提交。这会在接收多个点击事件或配置发生改变时让你的 App 处在未知的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackStackRecord</span> <span class="keyword">extends</span> <span class="title">FragmentTransaction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommitted)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">        mCommitted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">            mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIndex = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">        <span class="keyword">return</span> mIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建_Fragment_可能带来的问题">创建 Fragment 可能带来的问题</h2><p>Fragment 的实例能够通过 Fragment Manager 创建，例如下面的代码看起来没有什么问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DialogFragment dialogFragment = <span class="keyword">new</span> DialogFragment() &#123;</span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Dialog <span class="title">onCreateDialog</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">dialogFragment.show(fragmentManager, tag);</span><br></pre></td></tr></table></figure>
<p>然而，当我们需要存储 Activity 实例的状态时，Fragment Manager 可能会通过反射机制重新创建该 Fragment 的实例，又因为这是一个匿名内部类，该类有一个隐藏的构造器的参数正是外部类的引用，如果大家有看过<a href="http://blog.csdn.net/u012403246/article/details/45666369" target="_blank" rel="external">这篇博文</a>的话就会知道，拥有外部引用可能会带来内存泄漏的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android.support.v4.app.Fragment$InstantiationException:</span><br><span class="line">    Unable to instantiate fragment com.squareup.MyActivity$<span class="number">1</span>:</span><br><span class="line">    make sure <span class="class"><span class="keyword">class</span> <span class="title">name</span> <span class="title">exists</span>, <span class="title">is</span> <span class="title">public</span>, <span class="title">and</span> <span class="title">has</span> <span class="title">an</span> <span class="title">empty</span></span><br><span class="line">    <span class="title">constructor</span> <span class="title">that</span> <span class="title">is</span> <span class="title">public</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Fragment_教给我们的思想">Fragment 教给我们的思想</h2><p>尽管 Fragment 有着上面提到的缺点，但也是 Fragment 教给我们许多代码架构的思想：</p>
<ul>
<li><p>独立的 Activity 接口：实际上我们并不需要为每一个页面创建一个 Activity，我们大可以将应用切分成许多解耦的视图组件，按照我们的实际需求把它们组装成我们想要的界面。这样做也能简化生命周期和动画设置，因为我们还能将视图组件切分为 view 组件和控制器组件。</p>
</li>
<li><p>回退栈不是 Activity 的特有概念，也就意味着你能在 Activity 内部实现回退栈。</p>
</li>
<li><p>不需要添加新的 API，我们需要的只是 Activity，View 和 LayoutInflater。</p>
</li>
</ul>
<h1 id="响应式_UI：Fragment_VS_Custom_View">响应式 UI：Fragment VS Custom View</h1><h2 id="Fragment">Fragment</h2><p>我们不妨先来看看一个 Fragment 的<a href="http://developer.android.com/shareables/training/FragmentBasics.zip" target="_blank" rel="external">范例</a>，界面中显示了一个 list。</p>
<p>HeadlinesFragment 就是显示 List 的简单 Fragment：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadlinesFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">  OnHeadlineSelectedListener mCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnHeadlineSelectedListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setListAdapter(</span><br><span class="line">        <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(getActivity(),</span><br><span class="line">            R.layout.fragment_list,</span><br><span class="line">            Ipsum.Headlines));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    mCallback = (OnHeadlineSelectedListener) activity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    mCallback.onArticleSelected(position);</span><br><span class="line">    getListView().setItemChecked(position, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有趣的事情来了：ListFragmentActivity 必须控制 list 是否处于同一个页面中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFragmentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title">HeadlinesFragment</span>.<span class="title">OnHeadlineSelectedListener</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.news_articles);</span><br><span class="line">    <span class="keyword">if</span> (findViewById(R.id.fragment_container) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      HeadlinesFragment firstFragment = <span class="keyword">new</span> HeadlinesFragment();</span><br><span class="line">      firstFragment.setArguments(getIntent().getExtras());</span><br><span class="line">      getFragmentManager()</span><br><span class="line">          .beginTransaction()</span><br><span class="line">          .add(R.id.fragment_container, firstFragment)</span><br><span class="line">          .commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    ArticleFragment articleFrag =</span><br><span class="line">        (ArticleFragment) getFragmentManager()</span><br><span class="line">            .findFragmentById(R.id.article_fragment);</span><br><span class="line">    <span class="keyword">if</span> (articleFrag != <span class="keyword">null</span>) &#123;</span><br><span class="line">      articleFrag.updateArticleView(position);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ArticleFragment newFragment = <span class="keyword">new</span> ArticleFragment();</span><br><span class="line">      Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">      args.putInt(ArticleFragment.ARG_POSITION, position);</span><br><span class="line">      newFragment.setArguments(args);</span><br><span class="line">      getFragmentManager()</span><br><span class="line">          .beginTransaction()</span><br><span class="line">          .replace(R.id.fragment_container, newFragment)</span><br><span class="line">          .addToBackStack(<span class="keyword">null</span>)</span><br><span class="line">          .commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义_View">自定义 View</h2><p>我们不妨重新实现一个简化版的只使用了 View 的代码</p>
<p>首先，我们会引入一个叫作“容器”的概念，“容器”的作用是帮助我们展示一项内容并处理后退操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showItem</span><span class="params">(String item)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Acitivity 将假设始终存在容器，并且几乎不会将业务交给容器处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Container container;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.main_activity);</span><br><span class="line">    container = (Container) findViewById(R.id.container);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Container <span class="title">getContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = container.onBackPressed();</span><br><span class="line">    <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">      finish();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要显示的 List 也只是个平凡的 List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ItemListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    <span class="keyword">final</span> MyListAdapter adapter = <span class="keyword">new</span> MyListAdapter();</span><br><span class="line">    setAdapter(adapter);</span><br><span class="line">    setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">      <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view,</span><br><span class="line">            <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        String item = adapter.getItem(position);</span><br><span class="line">        MainActivity activity = (MainActivity) getContext();</span><br><span class="line">        Container container = activity.getContainer();</span><br><span class="line">        container.showItem(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处是：能够基于资源文件夹在不同的 XML 布局文件</p>
<p><code>res/layout/main_activity.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">com.squareup.view.SinglePaneContainer</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/container"</span></span><br><span class="line">    &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">com.squareup.view.ItemListView</span></span><br><span class="line">      <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">      <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">      /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">com.squareup.view.SinglePaneContainer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>res/layout-land/main_activity.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">com.squareup.view.DualPaneContainer</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"horizontal"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/container"</span></span><br><span class="line">    &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">com.squareup.view.ItemListView</span></span><br><span class="line">      <span class="attribute">android:layout_width</span>=<span class="value">"0dp"</span></span><br><span class="line">      <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">      <span class="attribute">android:layout_weight</span>=<span class="value">"0.2"</span></span><br><span class="line">      /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">include</span> <span class="attribute">layout</span>=<span class="value">"@layout/detail"</span></span><br><span class="line">      <span class="attribute">android:layout_width</span>=<span class="value">"0dp"</span></span><br><span class="line">      <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">      <span class="attribute">android:layout_weight</span>=<span class="value">"0.8"</span></span><br><span class="line">      /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">com.squareup.view.DualPaneContainer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是这些容器类的简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DualPaneContainer</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MyDetailView detailView;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DualPaneContainer</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    detailView = (MyDetailView) getChildAt(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItem</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    detailView.setItem(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglePaneContainer</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ItemListView listView;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SinglePaneContainer</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    listView = (ItemListView) getChildAt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!listViewAttached()) &#123;</span><br><span class="line">      removeViewAt(<span class="number">0</span>);</span><br><span class="line">      addView(listView);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItem</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listViewAttached()) &#123;</span><br><span class="line">      removeViewAt(<span class="number">0</span>);</span><br><span class="line">      View.inflate(getContext(), R.layout.detail, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    MyDetailView detailView = (MyDetailView) getChildAt(<span class="number">0</span>);</span><br><span class="line">    detailView.setItem(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">listViewAttached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listView.getParent() != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难想象：将容器类抽象，并用这种的方式开发 App，不但不需要 Fragment，还能架构出容易理解的代码。</p>
<h2 id="View_和_Presenter">View 和 Presenter</h2><p>自定义 View 在应用中非常有用，但我们希望将业务逻辑从 View 中剥离，转交给特定的控制器处理，也就是接下来我们所说的 Presenter，引入 Presenter 能提高代码的可读性和可测试性。如果你不信的话，不妨看看重构后的 MyDetailView：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDetailView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">  TextView textView;</span><br><span class="line">  DetailPresenter presenter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyDetailView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    presenter = <span class="keyword">new</span> DetailPresenter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    presenter.setView(<span class="keyword">this</span>);</span><br><span class="line">    textView = (TextView) findViewById(R.id.text);</span><br><span class="line">    findViewById(R.id.button).setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">      <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        presenter.buttonClicked();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItem</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    textView.setText(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 Square 注册界面中编辑账户的页面吧！</p>
<p><img src="https://camo.githubusercontent.com/976d3e840e060ae6f04aafbf66ebb59d84affb81/68747470733a2f2f636f726e65722e73717561726575702e636f6d2f696d616765732f6e6f2d667261676d656e74732f656469742d646973636f756e74732e706e67" alt=""></p>
<p>Presenter 将在更高层级中操控 View：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditDiscountPresenter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EditDiscountView view = getView();</span><br><span class="line">    String name = view.getName();</span><br><span class="line">    <span class="keyword">if</span> (isBlank(name)) &#123;</span><br><span class="line">      view.showNameRequiredWarning();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNewDiscount()) &#123;</span><br><span class="line">      createNewDiscountAsync(name, view.getAmount(), view.isPercentage());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      updateNewDiscountAsync(discountId, name, view.getAmount(),</span><br><span class="line">        view.isPercentage());</span><br><span class="line">    &#125;</span><br><span class="line">    close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以看到，为这个 Presenter 实现测试单元犹如一缕春风拂面来，甚是舒心爽快呐～</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cannot_save_discount_with_empty_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  startEditingLoadedPercentageDiscount();</span><br><span class="line">  when(view.getName()).thenReturn(<span class="string">""</span>);</span><br><span class="line">  presenter.saveDiscount();</span><br><span class="line">  verify(view).showNameRequiredWarning();</span><br><span class="line">  assertThat(isSavingInBackground()).isFalse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回退栈管理">回退栈管理</h2><p>通过异步处理来管理回退栈实在是牛刀杀鸡，大材小用了……我们只需要用一个超轻量级库——Flow，就可以达到目的。有关 Flow 的介绍 Ray Ryan 已经写过博客了，我就不在此赘述啦。</p>
<h2 id="我把_UI_相关的代码全都写在_Fragment_里了咋办呀，在线等，急！！！">我把 UI 相关的代码全都写在 Fragment 里了咋办呀，在线等，急！！！</h2><p>别理你的 Fragment，你就一点一点地把 View 相关的代码移到自定义 View 里，然后把涉及到的业务逻辑交给能够与 View 进行交互的 Presenter，然后你就会发现 Fragment 沦为空壳，只有一些初始化自定义 View 和连接 View 和 Presenter 的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater,</span><br><span class="line">    ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflater.inflate(R.layout.my_detail_view, container, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上到了这一步你已经可以抛弃 Fragment 了。</p>
<p>抛弃 Fragment 确实得花很大的功夫，但我们已经做到了，感谢<a href="https://twitter.com/dnkoutso" target="_blank" rel="external"> Dimitris Koutsogiorgas </a>和<a href="https://twitter.com/rjrjr" target="_blank" rel="external"> Ray Ryan </a>的伟大贡献！</p>
<h2 id="Dagger_和_Mortar_是什么？">Dagger 和 Mortar 是什么？</h2><p>Dagger &amp; Mortar 与 Fragment 成正交关系，换句话说，两者间各自的变化不会影响对方，使用 Dagger &amp; Mortar 既可以用 Fragment，也可以不用 Fragment。</p>
<p><a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a> 能帮你将应用模块化为一张由解耦组件构成的图，它考虑了所有类间的连接关系并简化了抽取依赖的操作，并实现一个与此相关的单例对象。</p>
<p><a href="https://github.com/square/mortar" target="_blank" rel="external">Mortar</a> 在 Dagger 的顶层进行操作，主要优势有如下两点：</p>
<ul>
<li><p>Mortar 为被注入组件提供简单的生命周期回调，使你能实现不会因旋转被销毁的单例 Presenter，不过需要注意的是，Mortar 将当前界面元素的状态储存在 Bundle 中，使数据不会随进程的结束而被清除。</p>
</li>
<li><p>Mortar 为你管理 Dagger 的子图，并帮你将它们与 Activity 的生命周期关联在一起，这种功能让你能有效地实现“域”：当一个 View 被添加进来，它的 Presenter 和依赖都会作为子图被创建；当 View 被移除，你能轻易地销毁“域”，并让垃圾回收机制去完成它的工作。</p>
</li>
</ul>
<h2 id="结论">结论</h2><p>我们曾为 Fragment 的诞生满心欢喜，幻想着 Fragment 能为我们带来种种便利，然而这一切不过是场虚空大梦，我们最后发现骑着白马的 Fragment 既不是王子也不是唐僧，只不过是人品爆发捡了只白马的乞丐罢了：</p>
<ul>
<li><p>我们遇到的大多数难以解决的 Bug 都与 Fragment 的生命周期有关。</p>
</li>
<li><p>我们只需要 View 创建响应式 UI，实现回退栈以及屏幕事件的处理，不用 Fragment 也能满足实际开发的需求。</p>
</li>
</ul>
<blockquote>
<ul>
<li>原文链接 : <a href="https://corner.squareup.com/2014/10/advocating-against-android-fragments.html" target="_blank" rel="external">Advocating Against Android Fragments</a></li>
<li>原文作者 : <a href="http://twitter.com/Piwai" target="_blank" rel="external">Pierre-Yves Ricau</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/chaossss" target="_blank" rel="external">chaossss</a> </li>
<li>校对者: <a href="www.belial.me">Belial</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近我在 Droidcon Paris 上进行了<a href="http://fr.droidcon.com/2014/agenda/detail?title=D%C3%A9fragmentez+vos+apps+avec+Mortar+%21">一个技术相关的演讲</a>，我在这次演讲中给大家展示了 Square 使用 Fragment 进行开发时遇到的种种问题，以及其他 Android 开发者是怎么避免在项目中使用 Fragment 的。</p>
<p>在 2011 年那会，由于下面的原因我们决定使用 Fragment：</p>
<ul>
<li><p>在那会，虽然我们很想让应用能在平板设备上被使用，但我们确实没能为平板提供平台支持。而 Fragment 能帮助我们完成这项愿望，建立响应式 UI 界面。</p>
</li>
<li><p>Fragment 是视图控制器，它们能够将一大块耦合严重的业务逻辑模块解耦，并使得解耦后的业务逻辑能够被测试。</p>
</li>
<li><p>Fragment 的 API 能够进行回退栈管理（例如，它能反射某个 Activity 内 Activity 栈的具体操作）</p>
</li>
<li><p>因为 Fragment 处于视图层的顶层，而为 View 设置动画并不麻烦，使得 Fragment 为设置页面切换的过渡效果提供了更好的支持。</p>
</li>
<li><p>Google 建议我们使用 Fragment，而我们作为开发者都想让自己的代码符合标准。</p>
</li>
</ul>
<p>在 2011年之后，我们在为 Square 进行开发的过程中发现了比使用 Fragment 更好的方法。<br>]]>
    
    </summary>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>