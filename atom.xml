<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Android博客]]></title>
  <subtitle><![CDATA[读万卷书]]></subtitle>
  <link href="http://likebamboo.com/AndroidBlog/atom.xml" rel="self"/>
  <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//"/>
  <updated>2015-06-30T13:57:53.000Z</updated>
  <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog//</id>
  
  <author>
    <name><![CDATA[likebamboo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之HoloGraphLibrary 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project_analysis_holographlibrary/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project_analysis_holographlibrary/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>HoloGraphLibrary 是一个可用于绘制图表的项目，支持绘制线状图、柱状图、饼状图。  </p>
<p>优点：图形设计友好，使用方便。<br><a id="more"></a></p>
<h3 id="2-_总体设计">2. 总体设计</h3><p>本项目较为简单，总体设计请参考<code>4.1类关系图</code>。 </p>
<h3 id="3-_流程图">3. 流程图</h3><p>本项目的每个控件的流程较为类似，可以抽象成一个流程图来理解。<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/holographlibrary/image/holographflow.png" alt="">  </p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/holographlibrary/image/uml.png" alt=""><br>其中<code>LineGraph</code>、<code>BarGraph</code>、<code>PieGraph</code>分别对应线状图、柱状图、饼状图控件。<br>其他除 View 以外的类都表示封装的数据。  </p>
<h4 id="4-2_核心类功能介绍">4.2 核心类功能介绍</h4><h5 id="4-2-1_柱状图：">4.2.1 柱状图：</h5><p><code>Bar.java</code>：用于表现一个柱体，构成柱状图的基本元素。封装了颜色，名字，<code>BarStackSegment</code>（下文将会涉及）数组等属性。若需要对<code>Bar</code>的每一个片段进行控制，改变<code>BarStackSegment</code>数组属性即可。  </p>
<p><code>BarStackSegment.java</code>：一般来说，一个柱体用于展示一个类型的数据，而<code>BarStackSegment</code>是作为柱体的扩展部分，用在同一个柱体上不同区间展示不同数据。  </p>
<p><code>BarGraph.java</code>：继承<code>View</code>类，表示柱状图控件，通过数据绘制负责柱状图。  </p>
<p>(1). onDraw 流程图<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/holographlibrary/image/bargraphflow.png" alt="">  </p>
<p>(2). onDraw 源码分析<br>a. 绘制的样式定义（柱体颜色、宽度大小等属性）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas ca)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 柱体的样式定义</span></span><br><span class="line">    <span class="keyword">float</span> maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> padding = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> selectPadding = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">float</span> bottomPadding = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义绘制柱体的区间</span></span><br><span class="line">    <span class="keyword">float</span> usableHeight;</span><br><span class="line">    <span class="keyword">if</span> (showBarText) &#123;</span><br><span class="line">        <span class="keyword">this</span>.p.setTextSize(<span class="number">40</span>);</span><br><span class="line">        <span class="keyword">this</span>.p.getTextBounds(unit, <span class="number">0</span>, <span class="number">1</span>, r3);</span><br><span class="line">        usableHeight = getHeight() - bottomPadding - Math.abs(r3.top - r3.bottom) - <span class="number">26</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usableHeight = getHeight() - bottomPadding;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...                    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制柱体</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Bar p : points) &#123;</span><br><span class="line">        <span class="comment">// 绘制每个柱体里的自定义区间</span></span><br><span class="line">        <span class="keyword">if</span>(p.getStackedBar())&#123;</span><br><span class="line">                 ...</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若没有自定义区间，则正常绘制</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>b. 绘制计算过程（详细看源码）<br>1）绘制 X 轴<br>2）确定柱体的数量<br>3）计算柱体所需的宽度<br>4）如果使用动画，柱体最大值（影响绘画的高度）使用动态计算的最大值<br>5）计算 X 轴上标签的字体的大小（不考虑动画状态，否则会导致字体抖动）<br>6）设置柱体边界<br>7）绘制柱体<br>8）创建选择区域<br>9）绘制标签<br>10）绘制柱体顶部的文字<br>11）限制总体宽度，防止弹出<br>12）若有使用后，设置监听，对进行动画更新  </p>
<h5 id="4-2-2_饼状图">4.2.2 饼状图</h5><p><code>PieSlice.java</code>：扇形，构成饼状图的基本元素。封装了颜色，值，标题，路径以及区域等属性。  </p>
<p><code>PieGraph.java</code>：：继承<code>View</code>类，表示饼状图控件，通过数据绘制负责饼状图。  </p>
<p>(1). onDraw 流程图<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/holographlibrary/image/piegraphflow.png" alt="">  </p>
<p>(2). 绘制计算过程（详细看源码）<br>1）若有背景图片，设置背景图片<br>2）设置扇形的开始的位置，大小，圆心<br>3）计算不同的扇形的大小，从上次结束的位置进行绘制，记录好该扇形结束的位置。重复此步骤，直到所有扇形绘制完成  </p>
<h5 id="4-2-3_折线图：">4.2.3 折线图：</h5><p><code>LinePoint.java</code>：折线的最基本元素，两点构成一条直线，属性包括二维坐标，路径以及区域等属性。  </p>
<p><code>Line.java</code>：由点构成线，里面封装了一个包含<code>LinePoint</code>的数组。  </p>
<p><code>LineGraph.java</code>：：继承<code>View</code>类，表示折线图控件，通过数据绘制负责折线图。<br>(1). onDraw 流程图<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/holographlibrary/image/linegraphflow.png" alt="">  </p>
<p>(2). 绘制计算过程（详细看源码）<br>1）若需要填充，先对整个绘制范围内进行直线绘制，然后擦除折线以上的直线<br>2）绘制 X 轴<br>3）绘制折线<br>4）绘制折点  </p>
<h4 id="5-_杂谈">5. 杂谈</h4><p>其实，这个项目的代码并不是写的很好，但无碍我们的使用，有兴趣的同学可以重构一下，也有开发者 fork 之后扩展得更加有趣。<a href="https://bitbucket.org/danielnadeau/holographlibrary" target="_blank" rel="external">-&gt;链接</a>。对于控件类的开源库，可以把重点放在绘制以及事件处理上。  </p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 HoloGraphLibrary 部分<br>项目地址：<a href="https://github.com/Androguide/HoloGraphLibrary" target="_blank" rel="external">HoloGraphLibrary</a>，分析的版本：<a href="https://github.com/Androguide/HoloGraphLibrary/commit/028cd2ae6916308bbb96472aafa9ecd8b1343d5c" title="Commit id is 028cd2ae6916308bbb96472aafa9ecd8b1343d5c" target="_blank" rel="external">028cd2a</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/holo-graph-library-demo" target="_blank" rel="external">HoloGraphLibrary Demo</a><br>分析者：<a href="https://github.com/AaronPlay" target="_blank" rel="external">AaronPlay</a>，校对者：<a href="https://github.com/lightSky" target="_blank" rel="external">lightSky</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>HoloGraphLibrary 是一个可用于绘制图表的项目，支持绘制线状图、柱状图、饼状图。  </p>
<p>优点：图形设计友好，使用方便。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之EventBus 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_event-bus/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_event-bus/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:42.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_EventBus">1.1 EventBus</h4><p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。<br>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。<br><a id="more"></a></p>
<h4 id="1-2_概念">1.2 概念</h4><p><strong>事件(Event)：</strong>又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。<code>事件类型(EventType)</code>指事件所属的 Class。<br>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件。  </p>
<p><strong>订阅者(Subscriber)：</strong>订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫<code>事件响应函数</code>。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。  </p>
<p><strong>发布者(Publisher)：</strong>发布某事件的对象，通过 post 接口发布事件。  </p>
<h3 id="2-_总体设计">2. 总体设计</h3><p>本项目较为简单，总体设计请参考<code>3.1 订阅者、发布者、EventBus 关系图</code>及<code>4.1 类关系图</code>。  </p>
<h3 id="3-_流程图">3. 流程图</h3><h4 id="3-1_订阅者、发布者、EventBus_关系图">3.1 订阅者、发布者、EventBus 关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/event-bus/image/relation-flow-chart.png" alt="eventbus img"><br>EventBus 负责存储订阅者、事件相关信息，订阅者和发布者都只和 EventBus 关联。  </p>
<h4 id="3-2_事件响应流程">3.2 事件响应流程</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/event-bus/image/event-response-flow-chart.png" alt="eventbus img"><br>订阅者首先调用 EventBus 的 register 接口订阅某种类型的事件，当发布者通过 post 接口发布该类型的事件时，EventBus 执行调用者的事件响应函数。 </p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/event-bus/image/class-relation.png" alt="eventbus img"><br>以上是 EventBus 主要类的关系图，从中我们也可以看出大部分类都与 EventBus 直接关联。上部分主要是订阅者相关信息，中间是 EventBus 类，下面是 发布者发布事件后的调用，具体类的功能请看下面的详细介绍。  </p>
<h4 id="4-2_类详细介绍">4.2 类详细介绍</h4><h5 id="4-2-1_EventBus-java">4.2.1 EventBus.java</h5><p>EventBus 类负责所有对外暴露的 API，其中的 register、post、unregister 函数配合上自定义的 EventType 及事件响应函数即可完成核心功能，见 3.2 图。<br>EventBus 默认可通过静态函数 getDefault 获取单例，当然有需要也可以通过 EventBusBuilder 或 构造函数新建一个 EventBus，每个新建的 EventBus 发布和订阅事件都是相互隔离的，即一个 EventBus 对象中的发布者发布事件，另一个 EventBus 对象中的订阅者不会收到该订阅。<br>EventBus 中对外 API，主要包括两类：<br><strong>(1) register 和 unregister</strong><br>分别表示订阅事件和取消订阅。register 最底层函数有三个参数，分别为订阅者对象、是否是 Sticky 事件、优先级。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> priority)</span></span></span><br></pre></td></tr></table></figure></p>
<p>PS：在此之前的版本 EventBus 还允许自定义事件响应函数名称，这版本中此功能已经被去除。<br>register 函数流程图如下：<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/event-bus/image/register-flow-chart.png" alt="eventbus img"><br>register 函数中会先根据订阅者类名去<code>subscriberMethodFinder</code>中查找当前订阅者所有事件响应函数，然后循环每一个事件响应函数，依次执行下面的 subscribe 函数：  </p>
<p><strong>(2) subscribe</strong><br>subscribe 函数分三步<br>第一步：通过<code>subscriptionsByEventType</code>得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列<code>subscriptionsByEventType</code>中；<br>第二步：在<code>typesBySubscriber</code>中得到当前订阅者订阅的所有事件队列，将此事件保存到队列<code>typesBySubscriber</code>中，用于后续取消订阅；<br>第三步：检查这个事件是否是 Sticky 事件，如果是则从<code>stickyEvents</code>事件保存队列中取出该事件类型最后一个事件发送给当前订阅者。  </p>
<p><strong>(3) post、cancel 、removeStickyEvent</strong><br>post 函数用于发布事件，cancel 函数用于取消某订阅者订阅的所有事件类型、removeStickyEvent 函数用于删除 sticky 事件。<br>post 函数流程图如下：<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/event-bus/image/post-flow-chart.png" alt="eventbus img"><br>post 函数会首先得到当前线程的 post 信息<code>PostingThreadState</code>，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用 postSingleEvent 函数发布队列中的每个事件。  </p>
<p>postSingleEvent 函数会先去<code>eventTypesCache</code>得到该事件对应类型的的父类及接口类型，没有缓存则查找并插入缓存。循环得到的每个类型和接口，调用 postSingleEventForEventType 函数发布每个事件到每个订阅者。  </p>
<p>postSingleEventForEventType 函数在<code>subscriptionsByEventType</code>查找该事件订阅者订阅者队列，调用 postToSubscription 函数向每个订阅者发布事件。  </p>
<p>postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。ThreadMode共有四类：  </p>
<ol>
<li><code>PostThread</code>：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：<strong>对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作</strong>；  </li>
<li><code>MainThread</code>：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，<code>MainThread</code>类的方法也不能有耗时操作，以避免卡主线程。适用场景：<strong>必须在主线程执行的操作</strong>；  </li>
<li><code>BackgroundThread</code>：在后台线程中执行响应方法。如果发布线程<strong>不是</strong>主线程，则直接调用订阅者的事件响应函数，否则启动<strong>唯一的</strong>后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有<code>PostThread</code>类和<code>MainThread</code>类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：<em>操作轻微耗时且不会过于频繁</em>，即一般的耗时操作都可以放在这里；  </li>
<li><code>Async</code>：不论发布线程是否为主线程，都使用一个空闲线程来处理。和<code>BackgroundThread</code>不同的是，<code>Async</code>类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。  </li>
</ol>
<p><strong>(4) 主要成员变量含义</strong><br>1.<code>defaultInstance</code>默认的 EventBus 实例，根据<code>EventBus.getDefault()</code>函数得到。<br>2.<code>DEFAULT_BUILDER</code>默认的 EventBus Builder。<br>3.<code>eventTypesCache</code>事件对应类型及其父类和实现的接口的缓存，以 eventType 为 key，元素为 Object 的 ArrayList 为 Value，Object 对象为 eventType 的父类或接口。<br>4.<code>subscriptionsByEventType</code>事件订阅者的保存队列，以 eventType 为 key，元素为<code>Subscription</code>的 ArrayList 为 Value，其中<code>Subscription</code>为订阅者信息，由 subscriber, subscriberMethod, priority 构成。<br>5.<code>typesBySubscriber</code>订阅者订阅的事件的保存队列，以 subscriber 为 key，元素为 eventType 的 ArrayList 为 Value。<br>6.<code>stickyEvents</code>Sticky 事件保存队列，以 eventType 为 key，event 为元素，由此可以看出对于同一个 eventType 最多只会有一个 event 存在。<br>7.<code>currentPostingThreadState</code>当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消。<br>8.<code>mainThreadPoster</code>、<code>backgroundPoster</code>、<code>asyncPoster</code>事件主线程处理者、事件 Background 处理者、事件异步处理者。<br>9.<code>subscriberMethodFinder</code>订阅者响应函数信息存储和查找类。<br>10.<code>executorService</code>异步和 BackGround 处理方式的线程池。<br>11.<code>throwSubscriberException</code>当调用事件处理函数异常时是否抛出异常，默认为 false，建议通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.builder().throwSubscriberException(<span class="keyword">true</span>).installDefaultEventBus()</span><br></pre></td></tr></table></figure></p>
<p>打开。<br>12.<code>logSubscriberExceptions</code>当调用事件处理函数异常时是否打印异常信息，默认为 true。<br>13.<code>logNoSubscriberMessages</code>当没有订阅者订阅该事件时是否打印日志，默认为 true。<br>14.<code>sendSubscriberExceptionEvent</code>当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件，若此开关打开，订阅者可通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(SubscriberExceptionEvent event)</span> </span><br><span class="line">```  </span><br><span class="line">订阅该事件进行处理，默认为 <span class="keyword">true</span>。 </span><br><span class="line">15.`sendNoSubscriberEvent`当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件，若此开关打开，订阅者可通过</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(NoSubscriberEvent event)</span></span></span><br></pre></td></tr></table></figure></p>
<p>订阅该事件进行处理，默认为 true。<br>16.<code>eventInheritance</code>是否支持事件继承，默认为 true。  </p>
<h5 id="4-2-2_EventBusBuilder-java">4.2.2 EventBusBuilder.java</h5><p>跟一般 Builder 类似，用于在需要设置参数过多时构造 EventBus。包含的属性也是 EventBus 的一些设置参数，意义见<code>4.2.1 EventBus.java</code>的介绍，build 函数用于新建 EventBus 对象，installDefaultEventBus 函数将当前设置应用于 Default EventBus。  </p>
<h5 id="4-2-3_SubscriberMethodFinder-java">4.2.3 SubscriberMethodFinder.java</h5><p>订阅者响应函数信息存储和查找类，由 HashMap 缓存，以 ${subscriberClassName} 为 key，SubscriberMethod 对象为元素的 ArrayList 为 value。findSubscriberMethods 函数用于查找订阅者响应函数，如果不在缓存中，则遍历自己的每个函数并递归父类查找，查找成功后保存到缓存中。遍历及查找规则为：<br>a. 遍历 subscriberClass 每个方法；<br>b. 该方法不以<code>java.</code>、<code>javax.</code>、<code>android.</code>这些 SDK 函数开头，并以<code>onEvent</code>开头，表示可能是事件响应函数继续，否则检查下一个方法；<br>c. 该方法是否是 public 的，并且不是 ABSTRACT、STATIC、BRIDGE、SYNTHETIC 修饰的，满足条件则继续。其中 BRIDGE、SYNTHETIC 为编译器生成的一些函数修饰符；<br>d. 该方法是否只有 1 个参数，满足条件则继续；<br>e. 该方法名为 <code>onEvent</code> 则 threadMode 为<code>ThreadMode.PostThread</code>；<br>该方法名为 <code>onEventMainThread</code> 则 threadMode 为<code>ThreadMode.MainThread</code>；<br>该方法名为 <code>onEventBackgroundThread</code> 则 threadMode 为<code>ThreadMode.BackgroundThread</code>；<br>该方法名为 <code>onEventAsync</code> 则 threadMode 为<code>ThreadMode.Async</code>；<br>其他情况且不在忽略名单 (skipMethodVerificationForClasses) 中则抛出异常。<br>f. 得到该方法唯一的参数即事件类型 eventType，将这个方法、threadMode、eventType 一起构造 SubscriberMethod 对象放到 ArrayList 中。<br>g. 回到 b 遍历 subscriberClass 的下一个方法，若方法遍历结束到 h；<br>h. 回到 a 遍历自己的父类，若父类遍历结束回到 i；<br>i. 若 ArrayList 依然为空则抛出异常，否则会将 ArrayList 做为 value，${subscriberClassName} 做为 key 放到缓存 HashMap 中。<br>对于事件函数的查找有两个小的性能优化点：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 第一次查找后保存到了缓存中，即上面介绍的 HashMap  </span><br><span class="line">b. 遇到 java. javax. android. 开头的类会自动停止查找</span><br></pre></td></tr></table></figure></p>
<p>类中的 skipMethodVerificationForClasses 属性表示跳过哪些类中非法以 <code>onEvent</code> 开头的函数检查，若不跳过则会抛出异常。<br>PS：在此之前的版本 EventBus 允许自定义事件响应函数名称，缓存的 HashMap key 为 ${subscriberClassName}.${eventMethodName}，这版本中此功能已经被去除。  </p>
<h5 id="4-2-4_SubscriberMethod-java">4.2.4 SubscriberMethod.java</h5><p>订阅者事件响应函数信息，包括响应方法、线程 Mode、事件类型以及一个用来比较 SubscriberMethod 是否相等的特征值 methodString 共四个变量，其中 methodString 为 ${methodClassName}#${methodName}(${eventTypeClassName}。  </p>
<h5 id="4-2-5_Subscription-java">4.2.5 Subscription.java</h5><p>订阅者信息，包括 subscriber 对象、事件响应方法 SubscriberMethod、优先级 priority。  </p>
<h5 id="4-2-6_HandlerPoster-jva">4.2.6 HandlerPoster.jva</h5><p>事件主线程处理，对应<code>ThreadMode.MainThread</code>。继承自 Handler，enqueue 函数将事件放到队列中，并利用 handler 发送 message，handleMessage 函数从队列中取事件，invoke 事件响应函数处理。  </p>
<h5 id="4-2-7_AsyncPoster-java">4.2.7 AsyncPoster.java</h5><p>事件异步线程处理，对应<code>ThreadMode.Async</code>，继承自 Runnable。enqueue 函数将事件放到队列中，并调用线程池执行当前任务，在 run  函数从队列中取事件，invoke 事件响应函数处理。  </p>
<h5 id="4-2-8_BackgroundPoster-java">4.2.8 BackgroundPoster.java</h5><p>事件 Background 处理，对应<code>ThreadMode.BackgroundThread</code>，继承自 Runnable。enqueue 函数将事件放到队列中，并调用线程池执行当前任务，在 run  函数从队列中取事件，invoke 事件响应函数处理。与 AsyncPoster.java 不同的是，BackgroundPoster中的任务只在同一个线程中依次执行，而不是并发执行。  </p>
<h5 id="4-2-9_PendingPost-java">4.2.9 PendingPost.java</h5><p>订阅者和事件信息实体类，并含有同一队列中指向下一个对象的指针。通过缓存存储不用的对象，减少下次创建的性能消耗。  </p>
<h5 id="4-2-10_PendingPostQueue-java">4.2.10 PendingPostQueue.java</h5><p>通过 head 和 tail 指针维护一个<code>PendingPost</code>队列。HandlerPoster、AsyncPoster、BackgroundPoster 都包含一个此队列实例，表示各自的订阅者及事件信息队列，在事件到来时进入队列，处理时从队列中取出一个元素进行处理。  </p>
<h5 id="4-2-11_SubscriberExceptionEvent-java">4.2.11 SubscriberExceptionEvent.java</h5><p>当调用事件处理函数异常时发送的 EventBus 内部自定义事件，通过 post 发送，订阅者可自行订阅这类事件进行处理。  </p>
<h5 id="4-2-12_NoSubscriberEvent-java">4.2.12 NoSubscriberEvent.java</h5><p>当没有事件处理函数对事件处理时发送的 EventBus 内部自定义事件，通过 post 发送，订阅者可自行订阅这类事件进行处理。  </p>
<h5 id="4-2-13_EventBusException-java">4.2.13 EventBusException.java</h5><p>封装于 RuntimeException 之上的 Exception，只是覆盖构造函数，相当于一个标记，标记是属于 EventBus 的 Exception。  </p>
<h5 id="4-2-14_ThreadMode-java">4.2.14 ThreadMode.java</h5><p>线程 Mode 枚举类，表示事件响应函数执行线程信息，包括<code>ThreadMode.PostThread</code>、<code>ThreadMode.MainThread</code>、<code>ThreadMode.BackgroundThread</code>、<code>ThreadMode.Async</code>四种。  </p>
<h3 id="5-_与_Otto_对比等_Otto_分析完成">5. 与 Otto 对比等 Otto 分析完成</h3><blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 EventBus 部分<br>项目地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a>，分析的版本：<a href="https://github.com/greenrobot/EventBus/commit/ccc2771199f958a34bd4ea6c90d0a8c671c2e70a" title="Commit id is ccc2771199f958a34bd4ea6c90d0a8c671c2e70a" target="_blank" rel="external">ccc2771</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/event-bus-demo" target="_blank" rel="external">EventBus Demo</a><br>分析者：<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对者：<a href="https://github.com/rengwuxian" target="_blank" rel="external">扔物线</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_EventBus">1.1 EventBus</h4><p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。<br>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Instagram是如何提升TextView渲染性能的]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/improving-comment-rendering-on-android/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/improving-comment-rendering-on-android/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="[译]Instagram是如何提升TextView渲染性能的">[译]Instagram是如何提升TextView渲染性能的</h1><blockquote>
<p>原文链接: <a href="http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android" target="_blank" rel="external">Improving Comment Rendering on Android</a></p>
</blockquote>
<p>上周，成千上万来自全世界的IG用户齐聚在社区组织的先下聚会 Worldwide InstaMeet11上。WWIM11 是历史上最大，最具地域多样性的Instagram聚会，从Muscat到Bushwick，成千上万用户分享了大约10万张照片。</p>
<p>每月世界上有超过3亿用户每月使用IG，其中65%来自美国以外的国家，无论用户在哪，我们一致致力于让IG更快，更容易使用。自从去年夏天IG重新设计后，我们在继续努力提升性能。</p>
<p>我们最近的一项改进是关于渲染庞大复杂的文本以及如何通过改进它优化IG的feed滚动。我们希望你可以从我们的经验中找到提升自己app速度的方法。<br><a id="more"></a></p>
<h1 id="产品需求和性能问题">产品需求和性能问题</h1><p>在IG中，feed是由图片，视频和文字组成的。对于每个图片和视频，我们需要展示对应的图片说明和5条最近的评论。由于用户通常通过图片说明来讲书图片背后的故事，这些图片说明通常是大段复杂的文字，甚至可能包含链接和emoji表情。<br><img src="http://codethink.me/images/how-ig-impove-textview-rendering-1.png" alt=""><br>渲染这种复杂文本的主要问题在于它滚动时对性能的影响。在Android中，文本的渲染是很慢的。即使在一个像Nexus 5这样的新设备上，一段有十几行复杂文本的图片说明的初始绘制时间可能会达到50ms，而其文本的measure阶段就需要30ms。这些都发生在UI线程，在滚动时会导致app跳帧。</p>
<h1 id="使用text-Layout，缓存text-Layout">使用text.Layout，缓存text.Layout</h1><p>Android有很多用于文字展示的控件，但实际上，他们都用text.Layout进行渲染。例如，TextView会将String转化为一个text.Layout对象，并通过canvas API将它绘制到屏幕上。</p>
<p>由于text.Layout需要在构造函数中测量文本的高度，因此它的创建效率不高。缓存text.Layout和复用text.Layout实例可以节省这部分时间。Android的TextView控件并没有提供设置TextLayout的方法，但是添加一个这样的方法并不困难：</p>
<p><img src="http://codethink.me/images/how-ig-impove-textview-rendering-2.png" alt=""></p>
<p>使用自定义的view来手动绘制text.Layout会提升其性能：TextView是一个包含大量特性的通用控件。如果我们只需要在屏幕上渲染静态的，可点击的文本，事情就简单多了：</p>
<ul>
<li><p>我们可以不用从SpannableStringBuilder转化到String。根据你的文本中是否包含链接，底层的TextView可能会复制一份你的字符串，这需要分配一些内存。</p>
</li>
<li><p>我们可以一直使用StaticLayout，这比DynamicLayout要稍微快一些。</p>
</li>
<li><p>我们可以避免使用TexView中其他的逻辑： 监听文本修改的逻辑，展示嵌入drawable的逻辑，绘制编辑器的逻辑以及弹出下拉列表的逻辑。</p>
</li>
</ul>
<p>通过使用TextLayoutView，我们可以缓存和复用text.Layout，从而避免了每次调用TextView的setText(CharSequence c)方法时都要花费20ms来创建它。</p>
<h1 id="下载feed后准备好Layout缓存">下载feed后准备好Layout缓存</h1><p>由于我们确定会在下载评论后展示他们，一个简单的改进是在下载它们后就准备好text.Layout的缓存。<br><img src="http://codethink.me/images/how-ig-impove-textview-rendering-3.png" alt=""></p>
<h1 id="停止滚动后准备好TextLayoutCache">停止滚动后准备好TextLayoutCache</h1><p>在可以设置text.Layout缓存后，我们的到来常数级的测量（measure）和绑定（binding）时间。但是初次绘制的时间仍然很长。50ms的绘制时间可能会导致明显的卡顿。</p>
<p>这50ms中的大部分被用于测量文本高度以及产生文字符号。这些都是CPU操作。为了提升文本渲染速度，Android在ICS中引入了TextLayoutCache用于缓存这些中间结果。TextLayoutCache是一个LRU缓存，缓存的key是文本。如果查询缓存时命中，文本的绘制速度会有很大提升。</p>
<p>在我们的测试中，这种缓存可以将绘制时间从30ms-50ms减少到2ms-6ms。<br><img src="http://codethink.me/images/how-ig-impove-textview-rendering-4.png" alt=""><br>为了更好的提升绘制性能，我们可以在绘制文本到屏幕前准备好这个缓存。我们的思路是在一块屏幕外的canvas上虚拟的绘制这些文本。这样在我们绘制文本到屏幕前，TextLayoutCache就已经在一个背景线程中被准备好了。<br><img src="http://codethink.me/images/how-ig-impove-textview-rendering-5.png" alt=""><br>默认情况下，TextLayoutCache的大小为0.5M，这足以缓存十几张图片的评论。我们决定在用户停止滑动时准备缓存，我们向用户滑动的方向提前缓存5个图片的评论。在任何时候，我们都至少在任何一个方向上缓存了5个图片的评论。<br><img src="http://codethink.me/images/how-ig-impove-textview-rendering-6.png" alt=""></p>
<p>在应用了所有的这些优化后，掉帧情况减少了60%，而卡顿的情况减少了50%。我们希望这些能帮助你提升你app的速度和性能。告诉我们你的想法吧，我们期待听到你的经验。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="[译]Instagram是如何提升TextView渲染性能的">[译]Instagram是如何提升TextView渲染性能的</h1><blockquote>
<p>原文链接: <a href="http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android">Improving Comment Rendering on Android</a></p>
</blockquote>
<p>上周，成千上万来自全世界的IG用户齐聚在社区组织的先下聚会 Worldwide InstaMeet11上。WWIM11 是历史上最大，最具地域多样性的Instagram聚会，从Muscat到Bushwick，成千上万用户分享了大约10万张照片。</p>
<p>每月世界上有超过3亿用户每月使用IG，其中65%来自美国以外的国家，无论用户在哪，我们一致致力于让IG更快，更容易使用。自从去年夏天IG重新设计后，我们在继续努力提升性能。</p>
<p>我们最近的一项改进是关于渲染庞大复杂的文本以及如何通过改进它优化IG的feed滚动。我们希望你可以从我们的经验中找到提升自己app速度的方法。<br>]]>
    
    </summary>
    
      <category term="基础" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="翻译" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之CircularFloatingActionMenu 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_circular-floating-action-menu/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_circular-floating-action-menu/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>一个与著名应用 <a href="https://play.google.com/store/apps/details?id=com.path" target="_blank" rel="external">Path</a> 菜单类似的圆形弹出菜单，可方便的定制菜单以及动画。<br>菜单可能是非完整圆形，本文统称为<code>圆形菜单</code>。<br><a id="more"></a></p>
<h4 id="1-1_特点">1.1 特点</h4><p>可自定义动画、菜单、角度范围、半径等。  </p>
<h4 id="1-2_概念">1.2 概念</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/circular-floating-action-menu/image/menu-demo.jpeg" alt="Menu Demo"><br>以上是简单的圆形弹出菜单示例，更详细的示例图见：<a href="https://github.com/android-cn/android-open-project-demo/blob/master/circular-floating-actionmenu-demo/README.md#2-screenshot" target="_blank" rel="external">Screenshot</a>。<br><strong>菜单按钮(Event)：</strong>点击会弹出圆形菜单的控件，如上图的 + 对应控件，对应代码中的<code>FloatingActionButton.java</code>。  </p>
<p><strong>子菜单按钮(Event)：</strong>圆形菜单中的控件，如上图的定位、视频、相机、文本对应的控件，对应代码中的<code>SubActionButton.java</code>。  </p>
<p><strong>菜单：</strong>整个菜单，包含上面的<code>菜单按钮</code>和<code>子菜单按钮</code>，对应代码中的<code>FloatingActionMenu.java</code>。  </p>
<p><strong>菜单动画回调：</strong>点击<code>菜单按钮</code>弹出<code>子菜单按钮</code>的动画设置的抽象类，对应代码中的<code>MenuAnimationHandler.java</code>。  </p>
<h3 id="2-_总体设计">2. 总体设计</h3><p>本项目较为简单，总体设计省略。  </p>
<h3 id="3-_流程图">3. 流程图</h3><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/circular-floating-action-menu/image/circlemenu.jpg" alt="设计流程图" title="流程图"><br>流程图如上图所示，中间最复杂的可能是计算<code>子菜单按钮</code>位置的地方。</p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/circular-floating-action-menu/image/menu_uml.jpg" alt="uml" title="uml"><br>以上是<code>CircularFloatingActionMenu</code>主要类的关系图。  </p>
<p><code>FloatingActionButton</code>、<code>SubActionButton</code>都是继承自<code>FrameLayout</code>的自定义控件，可支持以其他 View 为内容，如<code>ImageView</code>、<code>TextView</code>。  </p>
<p><code>FloatingActionMenu</code>由<code>FloatingActionButton</code>、<code>SubActionButton</code>以及<code>MenuAnimationHandler</code>等构成。  </p>
<h4 id="4-2_类功能介绍">4.2 类功能介绍</h4><p><code>CircularFloatingActionMenu</code>源码主要分成两部分，一部分是构成菜单的 View 部分，另一部分是动画的操作类。  </p>
<p>View 部分包含我们上面提到的菜单按钮<code>FloatingActionButton.java</code>、子菜单按钮<code>SubActionButton.java</code>、菜单<code>FloatingActionMenu.java</code>。 </p>
<p>动画部分包含菜单动画回调抽象类<code>MenuAnimationHandler.java</code>以及它默认的实现<code>DefaultAnimationHandler.java</code>。  </p>
<h5 id="4-2-1_SubActionButton-java">4.2.1 SubActionButton.java</h5><p>子菜单按钮，即按菜单键弹出来的选项按钮。这个类继承自<code>FrameLayout</code>，实现一个自定义图标的功能。<br>可以根据构造函数传进来的参数来选择不同风格的图案底纹，然后将其传给<code>FloatingActionMenu</code>以便控制。<br>首先是构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubActionButton</span><span class="params">(Activity activity, LayoutParams layoutParams, <span class="keyword">int</span> theme, Drawable backgroundDrawable, View contentView, LayoutParams contentParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(activity);</span><br><span class="line">        setLayoutParams(layoutParams);</span><br><span class="line">        <span class="comment">// If no custom backgroundDrawable is specified, use the background drawable of the theme.</span></span><br><span class="line">        <span class="keyword">if</span>(backgroundDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(theme == THEME_LIGHT) &#123;</span><br><span class="line">                backgroundDrawable = activity.getResources().getDrawable(R.drawable.button_sub_action_selector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(theme == THEME_DARK) &#123;</span><br><span class="line">                backgroundDrawable = activity.getResources().getDrawable(R.drawable.button_sub_action_dark_selector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(theme == THEME_LIGHTER) &#123;</span><br><span class="line">                backgroundDrawable = activity.getResources().getDrawable(R.drawable.button_action_selector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(theme == THEME_DARKER) &#123;</span><br><span class="line">                backgroundDrawable = activity.getResources().getDrawable(R.drawable.button_action_dark_selector);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown SubActionButton theme: "</span> + theme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过mutate()方法解决Drawable共用一个内存空间的问题</span></span><br><span class="line">            backgroundDrawable = backgroundDrawable.mutate().getConstantState().newDrawable();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置背景（考虑版本问题）</span></span><br><span class="line">        setBackgroundResource(backgroundDrawable);</span><br><span class="line">        <span class="keyword">if</span>(contentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加view(即菜单的选项视图)</span></span><br><span class="line">            setContentView(contentView, contentParams);</span><br><span class="line">        &#125;</span><br><span class="line">        setClickable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从构造函数可以看的出来，选项按钮有四个主题可以选择，分别是下面的四种颜色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THEME_LIGHT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THEME_DARK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THEME_LIGHTER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THEME_DARKER = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>之后是设定 ImageView 到这个按钮上，并且设定与父 View 的距离。（通过 setMargins()）<br>这个我们在创建 subActionButton 时就要调用。核心函数是 addView(contentView, params)。这个方法能够在视图上再添加一个 view，作为子视图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sets a content view with custom LayoutParams that will be displayed inside this SubActionButton.</span><br><span class="line"> * <span class="doctag">@param</span> contentView</span><br><span class="line"> * <span class="doctag">@param</span> params</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View contentView, LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(params == <span class="keyword">null</span>) &#123;</span><br><span class="line">        params = <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> margin = getResources().getDimensionPixelSize(R.dimen.sub_action_button_content_margin);</span><br><span class="line">        params.setMargins(margin, margin, margin, margin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contentView.setClickable(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.addView(contentView, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后就是一个建造器了，专门生成用于生成该类的建造器，静态全局<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A builder for &#123;<span class="doctag">@link</span> com.cpacm.library.SubActionButton&#125; in conventional Java Builder format</span><br><span class="line"> * 菜单选项的建造器</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> SubActionButton <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubActionButton(activity,</span><br><span class="line">                layoutParams,</span><br><span class="line">                theme,</span><br><span class="line">                backgroundDrawable,</span><br><span class="line">                contentView,</span><br><span class="line">                contentParams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传入 activity，视图特性配置，主题的 id，背景图，imageview（子视图），imageview（子视图）的特性配置。用这些来配置选项按钮。</p>
<h5 id="4-2-2_FloatingActionButton-java">4.2.2 FloatingActionButton.java</h5><p>菜单按钮，点击会弹出圆形菜单的控件。   </p>
<p>这个类跟<code>SubActionButton</code>基本相似，同样可以通过内部自定义的<code>build</code>构造器来定制自己的按钮。<br>菜单按钮其实跟选项按钮的代码模式差不多，也是由设定子视图和一个建造器组成。<br>不过它多了几个方法：<br>设定位置，如左下，右下等方位<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Sets the position of the button by calculating its Gravity from the position parameter</span><br><span class="line"> * <span class="doctag">@param</span> position one of 8 specified positions.</span><br><span class="line"> * <span class="doctag">@param</span> layoutParams</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">int</span> position, FrameLayout.LayoutParams layoutParams)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gravity;</span><br><span class="line">    <span class="keyword">switch</span>(position) &#123;</span><br><span class="line">        ...<span class="comment">//具体代码请自行查看源代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    layoutParams.gravity = gravity;</span><br><span class="line">    setLayoutParams(layoutParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将视图绑定到 activity 的主视图中。这样我们就能在 activity 的主视图中操作这个 view 了。<br>FloatingActionButton的建造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A builder for &#123;<span class="doctag">@link</span> com.cpacm.library.FloatingActionButton&#125; in conventional Java Builder format</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FloatingActionButton <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FloatingActionButton(activity,</span><br><span class="line">                                           layoutParams,</span><br><span class="line">                                           theme,</span><br><span class="line">                                           backgroundDrawable,</span><br><span class="line">                                           position,</span><br><span class="line">                                           contentView,</span><br><span class="line">                                           contentParams);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比 SubActionButton 多了一个位置的属性。</p>
<h5 id="4-2-3_FloatingActionMenu-java">4.2.3 FloatingActionMenu.java</h5><p>那么最重要的类来了，<code>FloatingActionMenu</code>表示整个菜单，它存放着所有的按钮以及动画操作。  </p>
<p>基本结构图如下：<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/circular-floating-action-menu/image/menu.jpg" alt="Alt text" title="menu"><br>这个类也是由一个建造器生成，那么我们从建造器开始说起<br>我们先看看生成 Menu 的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FloatingActionMenu rightLowerMenu = <span class="keyword">new</span> FloatingActionMenu.Builder(<span class="keyword">this</span>)</span><br><span class="line">                .addSubActionView(rLSubBuilder.setContentView(rlIcon1).build())</span><br><span class="line">                .addSubActionView(rLSubBuilder.setContentView(rlIcon2).build())</span><br><span class="line">                .addSubActionView(rLSubBuilder.setContentView(rlIcon3).build())</span><br><span class="line">                .addSubActionView(rLSubBuilder.setContentView(rlIcon4).build())</span><br><span class="line">                .setAnimationHandler(<span class="keyword">new</span> SliderAnimationHandler())</span><br><span class="line">                .attachTo(rightLowerButton)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Builder(this) 将 activity 传入 menu 中</li>
<li>addSubActionView 添加选项按钮到 activity 的视图中。在 FloatingActionMenu中管理 SubActionView 是一个 Item 的 list 集合，每次加一个按钮就往里面添加。Item 是一个辅助类，里面包括一个视图，x 坐标，y 坐标，长度，宽度。</li>
<li>setAnimationHandler 则是设定动画。</li>
<li>attachTo 是将 menu 与 activity 的视图绑定。（即把菜单按钮的视图添加到 activity 的视图中）  </li>
</ul>
<p>FloatingActionMenu 类主要是管理菜单按钮和选项按钮的位置和状态（开和关）<br>（1）首先是通过 view 的 onClick 监听器来控制状态  </p>
<p>（2）开关主要是两种状态，开的时候会获得菜单按钮的中心位置 center（getActionViewCenter()）和计算 item 的位置（calculateItemPositions()）。然后发送动画的请求到 AnimationHandler 中（animationHandler.animateMenuOpening(center)）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Simply opens the menu by doing necessary calculations.</span><br><span class="line"> * <span class="doctag">@param</span> animated if true, this action is executed by the current &#123;<span class="doctag">@link</span> MenuAnimationHandler&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">boolean</span> animated)</span> </span>&#123;</span><br><span class="line">    ...<span class="comment">//具体代码请自行查看源代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 item 的 x，y 是记录视图的终点位置，然后经过动画把 view 移到 x，y 的位置上。  </p>
<p>stateChangeListener 为状态变化的监听器，开关都会响应相应的方法。主要在 AnimationHandler 中添加具体方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A listener to listen open/closed state changes of the Menu</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">MenuStateChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMenuOpened</span><span class="params">(FloatingActionMenu menu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMenuClosed</span><span class="params">(FloatingActionMenu menu)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）计算位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Calculates the desired positions of all items.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateItemPositions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...<span class="comment">//具体代码请自行查看源代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4-2-4_MenuAnimationHandler-java">4.2.4 MenuAnimationHandler.java</h5><p>这是是所有动画类的父类，它主要定义了菜单打开，关闭，以及运行结束后状态的保存的方法。  </p>
<pre><code><span class="function"><span class="title">animateMenuOpening</span><span class="params">(Point center)</span></span>
<span class="function"><span class="title">animateMenuClosing</span><span class="params">(Point center)</span></span>   
<span class="function"><span class="title">restoreSubActionViewAfterAnimation</span><span class="params">(FloatingActionMenu.Item subActionItem, ActionType actionType)</span></span>
</code></pre><h5 id="4-2-5_DefaultAnimationHandler-java">4.2.5 DefaultAnimationHandler.java</h5><p>这一个默认的动画类，当我们不对动画做修改时就会默认使用这个类里面的动画效果。我们也可以参考这个类来进行设计新的动画效果。<br>动画效果主要是通过<code>ObjectAnimator.ofPropertyValuesHolder(menu.getSubActionItems().get(i).view, pvhX, pvhY, pvhR, pvhsX, pvhsY, pvhA)</code>来实现。<br>动画实现的主要类，继承自 MenuAnimationHandler<br>主要通过 Animator 来实现属性动画。<br>里面有一个 restoreSubActionViewAfterAnimation 的方法，它主要是恢复选项按钮到未打开的状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Restores the specified sub action view to its final state, accoding to the current actionType</span><br><span class="line"> * Should be called after an animation finishes.</span><br><span class="line"> * <span class="doctag">@param</span> subActionItem</span><br><span class="line"> * <span class="doctag">@param</span> actionType</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">restoreSubActionViewAfterAnimation</span><span class="params">(FloatingActionMenu.Item subActionItem, ActionType actionType)</span> </span>&#123;</span><br><span class="line">    ...<span class="comment">//具体代码请自行查看源代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Animator属性动画以及其他动画的实现请参考我写的博客<br><a href="http://www.cnblogs.com/cpacm/p/4067283.html" target="_blank" rel="external">Android的动画效果</a></p>
<h4 id="4-3_如何使用">4.3 如何使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up the white button on the lower right corner</span></span><br><span class="line"><span class="comment">// more or less with default parameter</span></span><br><span class="line">ImageView fabIconNew = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">fabIconNew.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_new_light));</span><br><span class="line">FloatingActionButton rightLowerButton = <span class="keyword">new</span> FloatingActionButton.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .setContentView(fabIconNew)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">SubActionButton.Builder rLSubBuilder = <span class="keyword">new</span> SubActionButton.Builder(<span class="keyword">this</span>);</span><br><span class="line">ImageView rlIcon1 = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">ImageView rlIcon2 = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">ImageView rlIcon3 = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line">ImageView rlIcon4 = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">rlIcon1.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_chat_light));</span><br><span class="line">rlIcon2.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_camera_light));</span><br><span class="line">rlIcon3.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_video_light));</span><br><span class="line">rlIcon4.setImageDrawable(getResources().getDrawable(R.drawable.ic_action_place_light));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build the menu with default options: light theme, 90 degrees, 72dp radius.</span></span><br><span class="line"><span class="comment">// Set 4 default SubActionButtons</span></span><br><span class="line">FloatingActionMenu rightLowerMenu = <span class="keyword">new</span> FloatingActionMenu.Builder(<span class="keyword">this</span>)</span><br><span class="line">        .addSubActionView(rLSubBuilder.setContentView(rlIcon1).build())</span><br><span class="line">        .addSubActionView(rLSubBuilder.setContentView(rlIcon2).build())</span><br><span class="line">        .addSubActionView(rLSubBuilder.setContentView(rlIcon3).build())</span><br><span class="line">        .addSubActionView(rLSubBuilder.setContentView(rlIcon4).build())</span><br><span class="line">        .setAnimationHandler(<span class="keyword">new</span> SliderAnimationHandler())</span><br><span class="line">        .attachTo(rightLowerButton)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>如以上代码所示  </p>
<p>（1）先建立一个 view 来作为一个总容器，设置好图片，然后作为菜单的按钮  </p>
<p>（2）建立好选项菜单的视图，添加属性后，添加到 FloatingActionMenu 中的 ArrayList<item> 数组中，并同时绑定上面的菜单按钮。  </item></p>
<p>（3）如果使用自己定义的动画，setAnimationHandler(new SliderAnimationHandler())。  </p>
<p>这样子，一个简单的案例就做好了</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/circular-floating-action-menu/image/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="流程图" title="流程图"></p>
<h3 id="5-_杂谈">5. 杂谈</h3><p>动画的类型有点少，以及在屏幕尺寸异常的机子上测试时（如 mx3 的 1800x1080）会出现子选项偏离中心菜单键的问题，原因出在 view 的位置计算上，它没有考虑到一些特殊机型的机子。</p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 circular-foating-action-menu 部分<br>项目地址：<a href="https://github.com/oguzbilgener/CircularFloatingActionMenu" target="_blank" rel="external">CircularFloatingActionMenu</a>，分析的版本：<a href="https://github.com/oguzbilgener/CircularFloatingActionMenu/commit/8efb1aab2b361ed9019fa4af6e5d43e77777bcb6" target="_blank" rel="external">8efb1aa</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/circular-floating-actionmenu-demo" target="_blank" rel="external">CFAMenu-demo</a><br>分析者：<a href="https://github.com/cpacm" target="_blank" rel="external">cpacm</a>，校对者：<a href="https://github.com/dkmeteor" target="_blank" rel="external">dkmeteor</a>、<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对状态：进行中   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>一个与著名应用 <a href="https://play.google.com/store/apps/details?id=com.path">Path</a> 菜单类似的圆形弹出菜单，可方便的定制菜单以及动画。<br>菜单可能是非完整圆形，本文统称为<code>圆形菜单</code>。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之Dagger 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_dagger/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_dagger/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_Dagger">1.1 Dagger</h4><p>Dagger 是一款 Java 平台的依赖注入库，关于依赖注入，详细见 <a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection" target="_blank" rel="external">依赖注入简介</a>。<br><a id="more"></a><br>Java 的依赖注入库中，最有名的应该属 Google 的 Guice，Spring 也很有名，不过是专注于 J2EE 开发。Guice 的功能非常强大，但它是通过在运行时读取注解来实现依赖注入的，依赖的生成和注入需要依靠 Java 的反射机制，这对于对性能非常敏感的 Android 来说是一个硬伤。基于此，Dagger 应运而生。  </p>
<p>Dagger 同样使用注解来实现依赖注入，但它利用 APT(Annotation Process Tool) 在编译时生成辅助类，这些类继承特定父类或实现特定接口，程序在运行时 Dagger 加载这些辅助类，调用相应接口完成依赖生成和注入。Dagger 对于程序的性能影响非常小，因此更加适用于 Android 应用的开发。</p>
<h4 id="1-2_依赖注入相关概念">1.2 依赖注入相关概念</h4><p><strong>依赖(Dependency)：</strong>如果在 Class A 中，有个属性是 Class B 的实例，则称 Class B 是 Class A 的依赖，本文中我们将 Class A 称为宿主(Host)，并且全文用 Host 表示；Class B 称为依赖(Dependency)，并且全文用 Dependency 表示。一个 Host 可能是另外一个类的 Dependency。  </p>
<p><strong>宿主(Host)：</strong>如果 Class B 是 Class A 的 Dependency，则称 Class A 是 Class B 的宿主(Host)。  </p>
<p><strong>依赖注入：</strong>如果 Class B 是 Class A 的 Dependency，B 的赋值不是写死在了类或构造函数中，而是通过构造函数或其他函数的参数传入，这种赋值方式我们称之为依赖注入。  </p>
<p>更详细介绍可见 <a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection" target="_blank" rel="external">依赖注入简介</a>。  </p>
<h4 id="1-3_Dagger_基本使用">1.3 Dagger 基本使用</h4><p>本文将以一个简单的“老板和程序员” App 为例。  </p>
<p>Activity 中有一个 Boss 类属性，现在你想把一个 Boss 对象注入到这个 Activity 中，那么有两个问题需要解决：Boss 对象应该怎样被生成 以及 Boss 对象怎样被设置到 Activity 中。  </p>
<h5 id="(1)-_Boss_对象怎样生成">(1). Boss 对象怎样生成</h5><p>在 Boss 类的构造函数前添加一个 @Inject 注解，Dagger 就会在需要获取 Boss 对象时，调用这个被标记的构造函数，从而生成一个 Boss 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>需要注意的是，如果构造函数含有参数，Dagger 会在调用构造对象的时候先去获取这些参数(不然谁来传参？)，所以你要保证它的参数也提供可被 Dagger 调用到的生成函数。Dagger 可调用的对象生成方式有两种：一种是用 @Inject 修饰的构造函数，上面就是这种方式。另外一种是用 @Provides 修饰的函数，下面会讲到。</em>  </p>
<h5 id="(2)-_Boss_对象怎样被设置到_Activity_中">(2). Boss 对象怎样被设置到 Activity 中</h5><p>通过 @Inject 注解了构造函数之后，在 Activity 中的 Boss 属性声明之前也添加 @Inject 注解。像这种在属性前添加的 @Inject 注解的目的是告诉 Dagger 哪些属性需要被注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Inject</span> Boss boss;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们在合适的位置(例如 onCreate() 函数中)调用 ObjectGraph.inject() 函数，Dagger 就会自动调用上面 (1) 中的生成方法生成依赖的实例，并注入到当前对象(MainActivity)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Inject</span> Boss boss;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ObjectGraph.create(AppModule.class).inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体怎么注入即设置的过程后面会详细介绍，这里简单透露下，APT 会在 MainActivity 所在 package 下生成一个辅助类 MainActivity$$InjectAdapter，这个类有个 injectMembers() 函数，代码类似：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(MainActivity paramMainActivity)</span> </span>&#123;</span><br><span class="line">    paramMainActivity.boss = ((Boss)boss.get());</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们已经通过 ObjectGraph.inject() 函数传入了 paramMainActivity，并且 boss 属性是 package 权限，所以 Dagger 只需要调用这个辅助类的 injectMembers() 函数即可完成依赖注入，这里的 boss.get() 会调用 Boss 的生成函数。<br>到此为止，使用 Dagger 的 @Inject 方式将一个 Boss 对象注入到 MainActivity 的流程就完成了。  </p>
<h5 id="(3)-_ObjectGraph-create(AppModule-class)_函数简介">(3). ObjectGraph.create(AppModule.class) 函数简介</h5><p>上面 onCreate() 函数中出现了两个类：ObjectGraph 和 AppModule。其中 ObjectGraph 是由 Dagger 提供的类，可以简单理解为一个依赖管理类，它的 create() 函数的参数是一个数组，为所有需要用到的 Module(例如本例中的 AppModule)。AppModule 是一个自定义类，在 Dagger 中称为<code>Module</code>，通过 @Module 注解进行标记，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span>(injects = MainActivity.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，AppModule 是一个空类，除了一行注解外没有任何代码。<br>@Module 注解表示这个类是一个<code>Module</code>，Module 的作用是提供信息，让 ObjectGraph 知道哪些类对象需要被依赖注入，以及该怎么生成某些依赖(这在下面会具体介绍)。例如，上面这段代码中声明了需要依赖注入的类为 MainActivity。<br>需要在 Module 类中显式声明这些信息看起来很麻烦，多此一举的方式和 Dagger 的原理有关，下面会讲到。  </p>
<h4 id="1-4_自定义依赖生成方式">1.4 自定义依赖生成方式</h4><h5 id="(1)-_@Provides_修饰的生成函数">(1). @Provides 修饰的生成函数</h5><p>对构造函数进行注解是很好用的依赖对象生成方式，然而它并不适用于所有情况。例如：  </p>
<ul>
<li>接口(Interface)是没有构造函数的，当然就不能对构造函数进行注解</li>
<li>第三方库提供的类，我们无法修改源码，因此也不能注解它们的构造函数</li>
<li>有些类需要提供统一的生成函数(一般会同时私有化构造函数)或需要动态选择初始化的配置，而不是使用一个单一的构造函数  </li>
</ul>
<p>对于以上三种情况，可以使用 @Provides 注解来标记自定义的生成函数，从而被 Dagger 调用。形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Provides</span></span><br><span class="line"><span class="function">Coder <span class="title">provideCoder</span><span class="params">(Boss boss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Coder(boss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>和构造函数一样，@Provides 注解修饰的函数如果含有参数，它的所有参数也需要提供可被 Dagger 调用到的生成函数。</em><br>需要注意的是，所有 @Provides 注解的生成函数都需要在<code>Module</code>中定义实现，这就是上面提到的 Module 的作用之一——让 ObjectGraph 知道怎么生成某些依赖。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Provides</span></span><br><span class="line">    <span class="function">Coder <span class="title">provideCoder</span><span class="params">(Boss boss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Coder(boss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="(2)-_@Inject_和_@Provide_两种依赖生成方式区别">(2). @Inject 和 @Provide 两种依赖生成方式区别</h5><p>a. @Inject 用于注入可实例化的类，@Provides 可用于注入所有类<br>b. @Inject 可用于修饰属性和构造函数，可用于任何非 Module 类，@Provides 只可用于用于修饰非构造函数，并且该函数必须在某个<code>Module</code>内部<br>c. @Inject 修饰的函数只能是构造函数，@Provides 修饰的函数必须以 provide 开头  </p>
<h4 id="1-5_单例">1.5 单例</h4><p>Dagger 支持单例(事实上单例也是依赖注入最常用的场景)，使用方式也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Inject 注解构造函数的单例模式</span></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Provides 注解函数的单例模式</span></span><br><span class="line"><span class="annotation">@Provides</span></span><br><span class="line"><span class="annotation">@Singleton</span></span><br><span class="line"><span class="function">Coder <span class="title">provideCoder</span><span class="params">(Boss boss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Coder(boss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相应函数添加 @Singleton 注解，依赖的对象就只会被初始化一次，之后的每次都会被直接注入相同的对象。</p>
<h4 id="1-6_Qualifier(限定符)">1.6 Qualifier(限定符)</h4><p>如果有两类程序员，他们的能力值 power 分别是 5 和 1000，应该怎样让 Dagger 对他们做出区分呢？使用 @Qualifier 注解即可。</p>
<p>(1). 创建一个 @Qualifier 注解，用于区分两类程序员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Qualifier</span></span><br><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Level &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2). 为这两类程序员分别设置 @Provides 函数，并使用 @Qualifier 注解对他们做出不同的标记：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Provides</span> <span class="annotation">@Level</span>(<span class="string">"low"</span>) <span class="function">Coder <span class="title">provideLowLevelCoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Coder coder = <span class="keyword">new</span> Coder();</span><br><span class="line">    coder.setName(<span class="string">"战五渣"</span>);</span><br><span class="line">    coder.setPower(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> coder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Provides</span> <span class="annotation">@Level</span>(<span class="string">"high"</span>) <span class="function">Coder <span class="title">provideHighLevelCoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Coder coder = <span class="keyword">new</span> Coder();</span><br><span class="line">    coder.setName(<span class="string">"大神"</span>);</span><br><span class="line">    coder.setPower(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3). 在声明 @Inject 对象的时候，加上对应的 @Qualifier 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Inject</span> <span class="annotation">@Level</span>(<span class="string">"low"</span>) Coder lowLevelCoder;</span><br><span class="line"><span class="annotation">@Inject</span> <span class="annotation">@Level</span>(<span class="string">"high"</span>) Coder highLevelCoder;</span><br></pre></td></tr></table></figure>
<h4 id="1-7_编译时检查">1.7 编译时检查</h4><p>实质上，Dagger 会在编译时对代码进行检查，并在检查不通过的时候报编译错误，具体原因请看下面的详细原理介绍。检查内容主要有三点：<br><strong>(1)</strong>. 所有需要依赖注入的类，需要被显式声明在相应的<code>Module</code>中。<br><strong>(2)</strong>. 一个<code>Module</code>中所有 @Provides 函数的参数都必须在这个 Module 中提供相应的被 @Provides 修饰的函数，或者在 @Module 注解后添加 “complete = false” 注明这是一个不完整 Module，表示它依赖不属于这个 Module 的其他 Denpendency。<br><strong>(3)</strong>. 一个<code>Module</code>中所有的 @Provides 函数都要被它声明的注入对象所使用，或者在 @Module 注解后添加 “library = ture” 注明它含有对外的 Denpendency，可能被其他<code>Module</code>依赖。  </p>
<h4 id="1-8_Dagger_相关概念">1.8 Dagger 相关概念</h4><p><strong>Module：</strong>也叫 ModuleClass，指被 @Module 注解修饰的类，为 Dagger 提供需要依赖注入的 Host 信息及一些 Dependency 的生成方式。  </p>
<p><strong>ModuleAdapter：</strong>指由 APT 根据 @Module 注解自动生成的类，父类是 Dagger 的 ModuleAdapter.java，与 ModuleClass 对应，以 ModuleClass 的 ClassName 加上 $$ModuleAdapter 命名，在 ModuleClass 的同一个 package 下。  </p>
<p><strong>Binding：</strong>指由 APT 根据 @Inject 注解和 @Provides 注解自动生成，最终继承自 Binding.java 的类。为下面介绍的 DAG 图中的一个节点，每个 Host 及依赖都是一个 Binding。  </p>
<p><strong>InjectAdapter：</strong>每个属性或构造函数被 @Inject 修饰的类都会生成一个 继承自 Binding.java 的子类，生成类以修饰类的 ClassName 加上 $$InjectAdapter 命名，在该类的同一个 package 下。  </p>
<p><strong>ProvidesAdapter：</strong>每个被 @Provides 修饰的生成函数都会生成一个继承自 ProvidesBinding.java 的子类，ProvidesBinding.java 继承自 Binding.java，生成类以 Provide 函数名首字母大写加上 ProvidesAdapter 命名，是 Provide 函数所在 Module 对应生成的<code>ModuleAdapter</code>中的静态内部类。<br>Binding 更具体信息在下面会介绍。  </p>
<p><strong>Binding 安装：</strong>指将 Binding 添加到 Binding 库中。对 Dagger Linker.java 代码来说是将 Binding 添加到 Linker.bindings 属性中，Linker.bindings 属性表示某个 ObjectGraph 已安装的所有 Binding。对于下面的 DAG 图来说是将节点放到图中，但尚未跟其他任何节点连接起来。  </p>
<p><strong>Binding 连接：</strong>把当前 Binding 和它内部依赖的 Binding 进行连接，即初始化这个 Binding 内部的所有 Binding，使它们可用。对 DAG 的角度说，就是把某个节点与其所依赖的各个节点连接起来。  </p>
<h3 id="2-_总体设计">2. 总体设计</h3><h4 id="2-1_概述">2.1 概述</h4><p>事实上，Dagger 这个库的取名不仅仅来自它的本意“匕首”，同时也暗示了它的原理。Jake Wharton 在对 Dagger 的介绍中指出，Dagger 即 DAG-er，这里的 DAG 即数据结构中的 DAG——有向无环图(Directed Acyclic Graph)。也就是说，Dagger 是一个<strong>基于有向无环图结构的依赖注入库。</strong></p>
<h4 id="2-2_DAG(有向无环图)">2.2 DAG(有向无环图)</h4><p>已经了解 DAG 的可以跳过这节。<br>DAG 是数据结构的一种。在一组节点中，每一个节点指向一个或多个节点，但不存在一条正向的链最终重新指向自己(即不存在环)，这样的结构称为有向无环图，即 DAG。</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/dagger/images/dag.png" alt="DAG"></p>
<p>上图中的数据结构就是一个有向无环图。图中一共存在 6 个节点和 7 个箭头，但任何一个节点都无法从自己发射出的箭头通过某条回路重新指向自己。</p>
<h4 id="2-3_Dagger_中依赖注入与_DAG_的关系">2.3 Dagger 中依赖注入与 DAG 的关系</h4><p>Dagger 的运作机制，是运用 <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/" target="_blank" rel="external">APT(Annotation Process Tool)</a> 在编译时生成一些用于设定规则的代码，然后在运行时将这些规则进行动态组合 // TODO 不太理解意思，生成一个(或多个)DAG，然后由 DAG 来完成所有依赖的获取，实现依赖注入。关于 DAG 究竟是怎样一步步生成的，后面再讲，这里先说一下在 Dagger 中依赖注入与 DAG 的关系。</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/dagger/images/dag-di.png" alt="DAG-DI"></p>
<p>我把前面那张图的每个节点重新命名，得到了上图。上图代表了某个应用程序内的一整套依赖关系，其中每个箭头都表示两个类之间依赖关系，Host 和 Dependency 都是其中的一个节点。  </p>
<p>可以看出，一个程序中的整套依赖关系其实就是一个 DAG。而实际上，Dagger 也是这么做的：<strong>预先建立一个 DAG，然后在需要获取对象的时候通过这个依赖关系图来获取到对象并返回，若获取失败则进行查找，查找到后再补充到 DAG 中。</strong></p>
<p>Dagger 是支持传递依赖的。例如在上图中，当需要获取一个 CustomView，会首先获取一个 DataHelper 作为获取 CustomView 的必要参数；此时如果 DataHelper 还未初始化，则还要分别拿到 HttpHelper 和 Database 用来初始化 DataHelper；以此类推。</p>
<p>Dagger 不支持循环依赖，即依赖关系图中不能出现环。原因很简单，如果鸡依赖蛋，蛋依赖鸡，谁来创造世界？总有一个要先产生的。</p>
<h4 id="2-4_工作流程">2.4 工作流程</h4><p><strong>(1)</strong>. 编译时，通过 APT 查看所有 java 文件，并根据注解生成一些新的 java 文件，即<code>InjectAdapter</code>、<code>ProvidesAdapter</code>、<code>ModuleAdapter</code>，这些文件用于运行时辅助 DAG 的创建和完善。然后，将这些新生成的 java 文件和项目原有的 java 文件一并编译成 class 文件。<br><strong>(2)</strong>. 运行时，在 Application 或某个具体模块的初始化处，使用<code>ObjectGraph</code>类来加载部分依赖(实质上是利用编译时生成的<code>ModuleAdapters</code>加载了所有的<code>ProvidesBinding</code>，后面会讲到)，形成一个不完整的依赖关系图。<br><strong>(3)</strong>. 这个不完整的依赖关系图生成之后，就可以调用<code>ObjectGraph</code>的相应函数来获取实例和注入依赖了。实现依赖注入的函数有两个：<code>ObjectGraph.get(Class&lt;T&gt; type)</code>函数，用于直接获取对象；<code>ObjectGraph.inject(T instance)</code>函数，用于对指定对象进行属性的注入。在这些获取实例和注入依赖的过程中，如果用到了还未加载的依赖，程序会自动对它们进行加载(实质上是加载的编译时生成的<code>InjectAdapter</code>)。在此过程中，内存中的 DAG 也被补充地越来越完整。</p>
<h3 id="3-_流程图">3. 流程图</h3><h4 id="3-1_编译时：">3.1 编译时：</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/dagger/images/dagger_flow_chart_compile.png" alt="dagger_flow_chart_compile">  </p>
<h4 id="3-2_运行时(初始化后)：">3.2 运行时(初始化后)：</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/dagger/images/dagger_flow_chart_runtime.png" alt="dagger_flow_chart_runtime">  </p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/dagger/images/uml_types.png" alt="uml_types">  </p>
<p>上图是 Dagger 整体框架最简类关系图。大致原理可以描述为：<code>Linker</code>通过<code>Loader</code>加载需要的<code>Binding</code>并把它们拼装成合理的依赖关系图 ObjectGraph，由<code>ObjectGraph</code>(其子类<code>DaggerObjectGraph</code>)最终实现依赖注入的管理。<br>ObjectGraph 是个抽象类，DaggerObjectGraph 是它目前唯一的子类，对 Dagger 的调用实际都是对 DaggerObjectGraph 的调用。  </p>
<h4 id="4-2_类功能详细介绍">4.2 类功能详细介绍</h4><h5 id="4-2-1_Binding-java_——_节点">4.2.1 Binding.java —— 节点</h5><p>Binding 是一个泛型抽象类，相当于依赖关系 DAG 图中的节点，依赖关系 DAG 图中得每一个节点都有一个由 APT 生成的继承自 Binding 的类与之对应，而依赖关系 DAG 图中的每一个节点与<code>Host</code>和<code>Dependency</code>一一对应，所以每个<code>Host</code>或<code>Dependency</code>必然有一个由 APT 生成的继承自 Binding 的子类与之对应，我们先简单的将这些生成类分为<code>HostBinding</code>和<code>DependencyBinding</code>。  </p>
<h5 id="(1)-_Binding-java_实现的接口">(1). Binding.java 实现的接口</h5><p>Binding.java 实现了两个接口，第一个是 javax 的<code>Provider</code>接口，此接口提供了 get() 函数用于返回一个<code>Dependency</code>实例，当然也可以是<code>Host</code>实例。<br>第二个接口是 Dagger 中的<code>MembersInjector</code>接口，此接口提供了 injectMembers() 用来向<code>Host</code>对象中注入(即设置)<code>Dependency</code>。<br>单纯的<code>DependencyBinding</code>只要实现<code>Provider</code>接口，在 get() 函数中返回自己的实例即可。单纯的<code>HostBinding</code>只要实现<code>MembersInjector</code>，在 injectMembers() 函数中调用<code>DependencyBinding</code>的 get() 函数得到依赖，然后对自己的依赖进行注入即可。如果一个类既是<code>Host</code>又是<code>Dependency</code>，则与它对应的<code>Binding</code>这两个接口都需要实现。 </p>
<h5 id="(2)-_生成的_Binding_代码示例">(2). 生成的 Binding 代码示例</h5><p>如下的 Host 和 Dependency 类  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Inject</span> Dependency dependency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 APT 生成的 Binding 应该类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span>$$<span class="title">InjectAdapter</span> <span class="keyword">extends</span> <span class="title">Binding</span>&lt;<span class="title">Host</span>&gt; <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">Host</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Binding&lt;Dependency&gt; dependencyBinding;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Linker linker)</span> </span>&#123;</span><br><span class="line">        dependencyBinding = (Dependency$$InjectAdapter)linker.requestBinding(……);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        host.dependency = (Dependency)dependencyBinding.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span>$$<span class="title">InjectAdapter</span> <span class="keyword">extends</span> <span class="title">Binding</span>&lt;<span class="title">Dependency</span>&gt; <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">Dependency</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dependency <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dependency();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HostBinding</code>指的是生成类 Host$$InjectAdapter，<code>DependencyBinding</code>指的是生成类 Dependency$$InjectAdapter，我们可以看到<code>HostBinding</code>的 attach 方法用于得到<code>DependencyBinding</code>的实例，然后在 injectMembers() 函数中通过调用这个实例的 get() 函数注入 Dependency，<code>DependencyBinding</code> 的 get() 函数就是调用<code>Dependency</code>的生成方法。  </p>
<h5 id="(3)-_Binding_分类">(3). Binding 分类</h5><p>上面我们将生成的 Binding 子类简单分为了<code>HostBinding</code>和<code>DependencyBinding</code>，实际根据前面的注入方式我们知道依赖的生成方式有 @Inject 和 @Provides 两种，对这两种方式，Dagger 生成 Binding 子类的规则不同。  </p>
<p>对于 @Inject 方式的注入，APT 会在<code>Dependency</code>同一个 package 下以<code>Dependency</code>的 ClassName 加上 $$InjectAdapter 为类名生成一个 Binding 子类。<br>对于 @Provides 方式的注入，@Provides 的生成函数必须写在某个<code>Module</code>内部，与此 Module 对应的<code>ModuleAdapter</code>(Module$$ModuleAdapter)内部会有一个此 @Provides 方式对应的 Binding 子类，继承自 Binding 的子类 ProvidesBinding，以 @Provides 函数名首字母大写加上 ProvidesAdapter 命名。  </p>
<p>所以实际自动生成的 Binding 子类我们可以分为三种：<br>第一种是<code>Host</code>对应的 Binding，本文中我们统一称为<code>HostBinding</code>。这些<code>HostBinding</code>和被 @Module 修饰的<code>Module</code> injects 值中每个元素一一对应，他们提供 get()、injectMembers()、attach() 函数。  </p>
<p>第二种是 Inject Dependecy 对应的 Binding 子类，本文中我们统一称为<code>InjectBinding</code>。这些<code>InjectBinding</code>和所有含有 @Inject 修饰的构造函数的类一一对应，他们提供 get() 函数，不提供 injectMembers() 函数。如果它同时是个<code>Host</code>，也会提供 injectMembers() 函数。  </p>
<p>第三种是 Provide Dependecy 对应的 Binding 子类，本文中我们统一称为<code>ProvidesBinding</code>。<code>ProvidesBinding</code> 和 @Module 类中的被 @Provides 修饰的函数一一对应，他们只提供 get() 函数，不提供 injectMembers() 函数。<br>上面三种 Binding 中，第一、二种会在 ObjectGraph.create 时加载进来，第三种在用的时候才会被动态加载。<code>InjectBinding</code>和<code>ProvidesBinding</code>统称为<code>DependencyBinding</code>。  </p>
<p><strong>Binding.java 的主要函数：</strong>  </p>
<h5 id="(1)-_get()">(1). get()</h5><p>表示得到此 Binding 对应的<code>Dependency</code>。<code>InjectBinding</code>会在 get() 中调用被 @Inject 修饰的构造函数，<code>ProvidesBinding</code>会在 get() 函数中调用被 @Provides 修饰的生成函数。  </p>
<h5 id="(2)-_injectMembers(T_t)">(2). injectMembers(T t)</h5><p>表示向此 Binding 对应<code>Host</code>对象中注入依赖，这个函数的实现一般就是对被 @Inject 修饰的属性进行赋值，值为<code>DependencyBinding</code>的 get() 函数返回值。  </p>
<h5 id="(3)-_attach(Linker_linker)">(3). attach(Linker linker)</h5><p>表示<code>HostBinding</code>获取依赖的 Binding 即<code>DependencyBinding</code>对象，对于 DAG 图来说相当于把图中两个节点连接起来。对于<code>DependencyBinding</code>此函数为空。  </p>
<h5 id="(4)-_getDependencies(…)">(4). getDependencies(…)</h5><p>表示<code>HostBinding</code>得到依赖的<code>DependencyBinding</code>)，这个函数在对 DAG 图进行问题检测，比如循环依赖检测时用到。  </p>
<p><strong>Binding.java 的主要属性：</strong>  </p>
<h5 id="(1)-_provideKey">(1). provideKey</h5><p>表示 Binding 所属 Host 或 Dependency 的类名，是 Binding 唯一的 key，在 Linker 管理 Binding 时会用到，作为存储所有 Binding 的 Map 的 key。对<code>HostBinding</code>值为 HostClassName.toString()，<code>DependencyBinding</code>值为 DependencyClassName.toString()。  </p>
<h5 id="(2)-_membersKey">(2). membersKey</h5><p>// TODO。对<code>HostBinding</code>值为 members/ 加上 HostClassName.toString()，<code>InjectBinding</code>值为  members/ 加上 DependencyClassName.toString()，<code>ProvidesBinding</code>值为 null。<code>ProvidesBinding</code>值为 null，因为它默认就连接好了。  </p>
<h5 id="(3)-_requiredBy">(3). requiredBy</h5><p>表示这个 Binding 属于谁，对<code>HostBinding</code>值为 HostClass.class，<code>InjectBinding</code>值为 DependencyClass.class，<code>ProvidesBinding</code>值为 ProvideMethodName.toString()。  </p>
<h5 id="(4)-_bits">(4). bits</h5><p>表示 Binding 特性的标志位，如是是否是单例(SINGLETON)、是否已连接(LINKED)，是否被访问(VISITING)、是否是可被其他 Module 依赖的 Library(LIBRARY)、是否依赖其他 Module 的 Binding(DEPENDED_ON)、是否不存在循环依赖(CYCLE_FREE)。  </p>
<h5 id="4-2-2_Linker-java_——_拼装者">4.2.2 Linker.java —— 拼装者</h5><p>Linker 是 Dagger 最核心的大脑部分，它负责调用 Loader 加载 Binding，存储并管理所有 Binding、调用 attach 方法初始化依赖的 DependencyBinding。对于 DAG 图来说，Linker 就相当于一个管家，负责调用加载器加载节点到图中、存储并管理图中所有的节点，连接图中有依赖关系的节点，也就是 DAG 图的拼装。<br>Dagger 在运行时维护一个或多个<code>Linker</code>，Linker 与 ObjectGraph 一一对应。  </p>
<p><strong>Linker.java 的主要属性：</strong>  </p>
<h5 id="(1)-_bindings">(1).  bindings</h5><p>本文称为 ObjectGraph 的 Binding 库，表示 ObjectGraph 已安装的所有 Binding，包括尚未连接的 Binding，对于 DAG 图来说就是所有在图中的节点，包括尚未跟其他任何节点连接起来的节点。<br>bindings 数据结构为 HashMap，value 就是具体的 Binding，key 是用来唯一确定 Binding 的字符串，为 Binding.java 中的 provideKey 和 membersKey，具体形式是类名加上一个用于区分同类型的前缀。这些 Binding 不仅包含已连接的，也包含未连接的。  </p>
<h5 id="(2)-_toLink">(2). toLink</h5><p>表示待连接的 Binding 队列，包含了所有待连接的 Binding。对于 DAG 图来说就是所有在图中但未和任何节点连接的节点。  </p>
<p>连接(Link)：从 DAG 的角度说，就是把某个节点与其所依赖的各个节点连接起来。而对于 Binding 来说，就是把当前 Binding 和它依赖的 Binding (<code>ProvidesBinding</code>)进行连接，即初始化这个 Binding 依赖的所有 Binding，使它们可用。  </p>
<h5 id="(3)-_attachSuccess">(3). attachSuccess</h5><p>一个标志，对于某个 Binding，在获取它依赖的<code>DependencyBinding</code>时，如果他所有的<code>DependencyBinding</code>都已经添加到<code>Binding</code>库中，attachSuccess 则为 true，否则为 false。如果为 false ，表示该 Binding 尚未连接，添加到待连接队列中，否则标记为已连接。  </p>
<h5 id="(4)-_linkedBindings">(4). linkedBindings</h5><p>默认为 null，只有在 linkAll() 函数被调用后才有效，用于存储所有已经连接的 Binding，同时也是一个标记，表示这个 ObjectGraph 已经不能被改变。  </p>
<h5 id="(5)-_Loader_plugin">(5). Loader plugin</h5><p>Loader 负责加载类，主要是加载 APT 生成的辅助类(InjectAdapter、ModuleAdapter)。  </p>
<h5 id="(6)-_errors">(6). errors</h5><p>Linker.linkRequested() 运行过程中积累的 errors。  </p>
<p><strong>Linker.java 的主要函数：</strong>  </p>
<h5 id="(1)-_requestBinding(String_key_……)">(1). requestBinding(String key ……)</h5><p>根据传入的 key 返回一个 Binding。首先，会尝试从 Bindings 变量(Binding 库)中查找这个 key，如果找到了，就将找到的 Binding 返回(如果找到后发现这个 Binding 还未连接，还需要它放进 toLink 中)；如果找不到，说明需要的 Binding 是一个<code>InjectBinding</code>(因为另一种 Binding——ProvidesBinding 在初始化时就已经加载完毕了)，就生成一个包含了这个 key 的<code>DeferredBinding</code>，并把它添加到 toLink(等待稍后载入)后返回 null。  </p>
<h5 id="(2)-_linkRequested()">(2). linkRequested()</h5><p>循环取出 toLink 中的 Binding：<br>如果是个<code>DeferredBinding</code>载入相应的<code>InjectAdapter</code>后添加到<code>toLink</code>和<code>bindings</code>中，等待下次循环。<br>否则调用 attach 函数进行连接，对于<code>DependencyBinding</code>连接完成。对于<code>HostBinding</code>利用 attach() 函数获取依赖的 Binding 即<code>DependencyBinding</code>对象，在获取<code>DependencyBinding</code>的过程中调用 requestBinding() 函数查找 Binding，不存在或未连接会继续添加到 toLink 队列中，如此循环。<br>直到所有依赖<code>DependencyBinding</code>被初始化结束。<br>对 DAG 图来说就是一次广度优先遍历。  </p>
<h5 id="(3)-_installBindings(BindingsGroup_toInstall)">(3). installBindings(BindingsGroup toInstall)</h5><p>安装 Bindings，表示将 Binding 添加到 ObjectGraph 中，但尚未连接。对 DAG 图来说就是就是将节点放到图中，但尚未和任何其他节点连接。  </p>
<h5 id="(4)-_linkAll()">(4). linkAll()</h5><p>将 Binding 库中所有未连接的 Binding 添加到 toLink 中，调用 linkRequested() 进行连接。  </p>
<h5 id="(5)-_fullyLinkedBindings()">(5). fullyLinkedBindings()</h5><p>返回已经全部连接的 Binding，如果没有调用过 linkAll() 则返回 null</p>
<h5 id="4-2-3_Loader-java_——_类加载器及对象生成器">4.2.3 Loader.java —— 类加载器及对象生成器</h5><p>Loader 是一个纯工具类，它通过 ClassLoader 加载 APT 生成的<code>ModuleAdapter</code>类和<code>InjectAdapter</code>类，并初始化一个该类对象返回。另外，Loader 是一个抽象类，在运行时，Dagger 使用的是 Loader 的子类<code>FailoverLoader</code>。</p>
<p><strong>Loader.java 的主要函数：</strong>  </p>
<h5 id="(1)-_loadClass(ClassLoader_classLoader,_String_name)">(1). loadClass(ClassLoader classLoader, String name)</h5><p>用指定的 ClassLoader 根据类名得到类，并缓存起来。  </p>
<h5 id="(2)-_instantiate(String_name,_ClassLoader_classLoader)">(2). instantiate(String name, ClassLoader classLoader)</h5><p>用指定的 ClassLoader 根据类名获取类的实例。  </p>
<h5 id="(3)-_getModuleAdapter(Class_moduleClass)">(3). getModuleAdapter(Class<t> moduleClass)</t></h5><p>获取指定的 Module 类所对应的 ModuleAdapter 实例。  </p>
<h5 id="(4)-_getAtInjectBinding(String_key……)">(4). getAtInjectBinding(String key……)</h5><p>根据 key 获取 Inject Dependecy 对应的 InjectAdapter 实例。  </p>
<h5 id="(5)-_getStaticInjection(Class&lt;?&gt;_injectedClass)">(5). getStaticInjection(Class&lt;?&gt; injectedClass)</h5><p>根据被注入的 Class 获取对应的 StaticInjection 实例。  </p>
<p><strong>Loader.java 的主要变量：</strong>  </p>
<h5 id="(1)-_Memoizer&gt;&gt;_caches">(1). Memoizer<classloader, memoizer<string,="" class<?="">&gt;&gt; caches</classloader,></h5><p>用来缓存被初始化过的对象，是一个嵌套的 Memoizer 结构，<code>Memoizer</code>具体可看后面介绍，简单理解就是嵌套的 HashMap，第一层 Key 是 ClassLoader，第二层 Key 是 ClassName，Value 是 Class 对象。  </p>
<h5 id="4-2-4_FailoverLoader-java">4.2.4 FailoverLoader.java</h5><p>FailoverLoader 是 Loader 的一个子类，它加载类的策略是首先查找 APT 生成的类，如果查找失败，则直接使用反射查找和初始化。<br><strong>FailoverLoader.java 的主要函数：</strong>  </p>
<h5 id="(1)-_getModuleAdapter(Class_moduleClass)">(1). getModuleAdapter(Class<t> moduleClass)</t></h5><p>获取指定的 Module 类所对应的 ModuleAdapter 实例，如果在生成类中查找失败，则会调用 ReflectiveAtInjectBinding.create(type, mustHaveInjections) 通过反射直接初始化对象。  </p>
<h5 id="(2)-_getAtInjectBinding(String_key……)">(2). getAtInjectBinding(String key……)</h5><p>根据 key 获取 Inject Dependecy 对应的 InjectAdapter 实例。如果在生成类中查找失败，则会调用 ReflectiveStaticInjection.create(injectedClass) 通过反射直接初始化对象。  </p>
<h5 id="(3)-_getStaticInjection(Class&lt;?&gt;_injectedClass)">(3). getStaticInjection(Class&lt;?&gt; injectedClass)</h5><p>根据被注入的 Class 获取对应的 StaticInjection 实例。  </p>
<p><strong>FailoverLoader.java 的主要变量：</strong>  </p>
<h5 id="(1)-_Memoizer,_ModuleAdapter&lt;?&gt;&gt;_loadedAdapters">(1). Memoizer<class<?>, ModuleAdapter&lt;?&gt;&gt; loadedAdapters</class<?></h5><p>用来缓存初始化过的 ModuleAdapter 对象，是一个嵌套的 Memoizer 结构，具体可看下面介绍，简单理解就是嵌套的 HashMap，第一层 Key 是 ClassLoader，第二层 Key 是 ClassName，Value 是 Class 对象。  </p>
<h5 id="4-2-5_ObjectGraph_——_管理者">4.2.5 ObjectGraph —— 管理者</h5><p>ObjectGraph 是个抽象类，负责 Dagger 所有的业务逻辑，Dagger 最关键流程都是从这个类发起的，包括依赖关系图创建、实例(依赖或宿主)获取、依赖注入。<br><strong>ObjectGraph 主要函数有：</strong>  </p>
<h5 id="(1)-_create(Object…_modules)">(1). create(Object… modules)</h5><p>这是个静态的构造函数，用于返回一个 ObjectGraph 的实例，是使用 Dagger 调用的第一个函数。参数为 ModuleClass 对象，函数作用是根据 ModuleClass 构建一个依赖关系图。此函数实现会直接调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DaggerObjectGraph.makeGraph(<span class="keyword">null</span>, <span class="keyword">new</span> FailoverLoader(), modules)</span><br></pre></td></tr></table></figure></p>
<p>返回一个<code>DaggerObjectGraph</code>对象，我们会在下面<code>DaggerObjectGraph</code>介绍中具体介绍实现过程。  </p>
<h5 id="(2)-_inject(T_instance)">(2). inject(T instance)</h5><p>抽象函数，表示向某个 Host 对象中注入依赖。  </p>
<h5 id="(3)-_injectStatics()">(3). injectStatics()</h5><p>抽象函数，表示向 ObjectGraph 中相关的 Host 注入静态属性。  </p>
<h5 id="(4)-_get(Class_type)">(4). get(Class<t> type)</t></h5><p>抽象函数，表示得到某个对象的实例，多用于得到依赖的实例。  </p>
<h5 id="(5)-_plus(Object…_modules)">(5). plus(Object… modules)</h5><p>抽象函数，表示返回一个新的包含当前 ObjectGraph 中所有 Binding 的 ObjectGraph。  </p>
<h5 id="(6)-_validate()">(6). validate()</h5><p>抽象函数，表示对当前 ObjectGraph 做检查。  </p>
<h5 id="4-2-6_DaggerObjectGraph">4.2.6 DaggerObjectGraph</h5><p>DaggerObjectGraph 是 ObjectGraph 的静态内部类，也是 ObjectGraph 目前唯一的子类。因为 ObjectGraph 的 create() 函数直接返回了 DaggerObjectGraph 对象，所以对 Dagger 的调用实际都是对 DaggerObjectGraph 的调用。<br><strong>DaggerObjectGraph 主要属性有：</strong>  </p>
<h5 id="(1)-_Map_injectableTypes">(1). Map injectableTypes</h5><p>记录了所有需要被依赖注入的 Host 类型，以 Host 的 ClassName 加上一定规则前缀(// TODO)做为 key，以其所对应的 Module 为 value。</p>
<h5 id="(2)-_Map_staticInjections">(2). Map staticInjections</h5><p>记录了所有需要被静态依赖注入的 Host 类型，以 Host 的 ClassName 加上一定规则前缀(// TODO)做为 key，以其所对应的 Module 为 value。</p>
<h5 id="(3)-_Linker_linker">(3). Linker linker</h5><p>Linker 是 负责调用 Loader 加载 Binding，存储并管理所有 Binding、调用 attach 方法初始化依赖的 DependencyBinding。具体见上面<code>Linker.java</code>介绍。  </p>
<h5 id="(4)-_Loader_plugin">(4). Loader plugin</h5><p>Loader 负责通过 ClassLoader 加载 APT 生成的ModuleAdapter类和InjectAdapter类。<br>PS：这个变量名叫 plugin，实际也说明了 Dagger 的一大优势，就是它是支持 ClassLoader，这样通过 Dagger 实现依赖注入的 Android 应用，插件化时 Dagger 不会对其产生影响，而截止这个分析文档完成时，轻量级的 ButterKnife 都不支持多个 ClassLoader。<br><strong>DaggerObjectGraph 主要函数有：</strong>  </p>
<h5 id="(1)-_makeGraph_函数">(1). makeGraph 函数</h5><p>makeGraph 函数首先会通过 Modules.loadModules 函数得到所有的 ModuleAdapter；<br>然后遍历所有 ModuleAdapter，将其中需要依赖注入的 Host 类型(injectableTypes)、需要静态静态注入的 Host 类型(staticInjections)、所有的 Binding(这里是ProvidesBinding)都保存下来，做为新的 DaggerObjectGraph 对象构造入参。另一种 Binding —— InjectBinding 会在需要用到的时候进行动态载入；<br>第三步新建 Linker 保存上面的 Binding；<br>最后用这些变量一起构建新的 DaggerObjectGraph 对象。  </p>
<h5 id="(2)-_inject(T_instance)-1">(2). inject(T instance)</h5><p>表示向某个 Host 对象中注入依赖。首先根据下面的 getInjectableTypeBinding() 函数查找到 Host 对应的 InjectBinding，然后调用 injectMembers() 函数注入依赖，将依赖注入结束的 Host 返回。  </p>
<h5 id="(3)-_injectStatics()-1">(3). injectStatics()</h5><p>表示向 ObjectGraph 中相关的 Host 注入静态属性。  </p>
<h5 id="(4)-_get(Class_type)-1">(4). get(Class<t> type)</t></h5><p>表示得到某个对象的实例，多用于得到 Denpendency 的实例。首先根据下面的 getInjectableTypeBinding() 函数查找到 Denpendency 对应的 Binding，然后调用 get() 返回该 Denpendency 实例。  </p>
<h5 id="(5)-_plus(Object…_modules)-1">(5). plus(Object… modules)</h5><p>抽象函数，表示返回一个新的包含当前 ObjectGraph 中所有对象的 ObjectGraph。  </p>
<h5 id="(6)-_validate()-1">(6). validate()</h5><p>表示对当前 ObjectGraph 做检查，首先会利用 Linker 查找到所有节点并连接起来，然后调用 ProblemDetector 进行检查。ProblemDetector 会在后面解释作用。  </p>
<h5 id="(7)-_getInjectableTypeBinding(ClassLoader_classLoader,_String_injectableKey,_String_key)">(7). getInjectableTypeBinding(ClassLoader classLoader, String injectableKey, String key)</h5><p>表示根据 key 得到某个 Binding。首先会从 ObjectGraph.injectableTypes 中得到其对应的 Module，然后通过 linker.requestBinding 查找其对应的 Binding，若未查找到的 Binding 或是尚未连接，则调用 linker.linkRequested() 得到 InjectBindng 并将其添加到 ObjectGraph 中，此时再次通过 linker.requestBinding 即可查找到其对应的 Binding，返回即可。  </p>
<h5 id="(8)-_linkInjectableTypes()">(8). linkInjectableTypes()</h5><p>查找 injectableTypes 记录的所有需要被依赖注入的 Host 类型对应的<code>HostBinding</code>。  </p>
<h5 id="(9)-_linkStaticInjections()">(9). linkStaticInjections()</h5><p>查找 staticInjections 记录的所有需要被静态依赖注入的 Host 类型对应的<code>HostBinding</code>。  </p>
<h5 id="(10)_linkEverything()">(10) linkEverything()</h5><p>首先检查是否连接过，没有的话，则先调用 linkInjectableTypes() 和 linkStaticInjections() 将所有 HostBinding 添加到 Linker 中，然后调用 linker.linkAll() 进行全部 Binding 的依赖关联。  </p>
<h5 id="4-2-7_BindingsGroup-java">4.2.7 BindingsGroup.java</h5><p>内部主要一个 LinkedHashMap 变量，key 为需要需要依赖注入的类类全名，value 为其对应的 Binding 对象。  </p>
<h5 id="4-2-8_DeferredBinding-java">4.2.8 DeferredBinding.java</h5><p>DeferredBinding 是 Binding 的一个子类，实际就是一个标记，在 linker.requestBinding 时候如果某个 Binding 不存在，则生成一个 DeferredBinding 添加到 toLink 队列中，在 linker.linkRequested 如果碰到 DeferredBinding 则根据 key 获得真正的 Binding 添加到 toLink 队列中。  </p>
<h5 id="4-2-9_Keys-java">4.2.9 Keys.java</h5><p>这是个 Key 相关的工具类。<br><code>getMembersKey(Class&lt;?&gt; key)</code> 用于返回以 “members/“ + keyClassName 的字符串。  </p>
<h5 id="(1)-_boxIfPrimitive(Type_type)_函数用于将原始类型转换为复杂类型">(1). boxIfPrimitive(Type type) 函数用于将原始类型转换为复杂类型</h5><p>// TODO 其他函数作用  </p>
<h5 id="4-2-10_Memoizer-java">4.2.10 Memoizer.java</h5><p>一个小的缓存抽象类，内部主要是一个用于存储数据的 HashMap 属性和两个读写重入锁。<br><strong>Memoizer 主要函数有：</strong>  </p>
<h5 id="(1)-_create(K_key)">(1). create(K key)</h5><p>需要子类实现的抽象函数，表示创建 Value 的方式。  </p>
<h5 id="(2)-_get(K_key)">(2). get(K key)</h5><p>表示根据 key 从缓存中得到 value，value 如果已经存在则直接返回，否则调用 create(K key) 函数新建 value，存入缓存并返回。<br>Memoizer 主要用在 Loader 中，Loder 中包含一个嵌套的 Memoizer 变量，内外分别作为类和 ClassLoader 的缓存。  </p>
<h5 id="4-2-11_ModuleAdapter-java">4.2.11 ModuleAdapter.java</h5><p>抽象类，APT 会为每一个被 @Module 修饰的类自动生成一个继承自这个 ModuleAdapter 的子类。该子类会以 ModuleClass 的 ClassName 加上 $$ModuleAdapter 命名，在 ModuleClass 的同一个 package 下。<br><strong>ModuleAdapter 主要属性有：</strong>  </p>
<h5 id="(1)-_Class_moduleClass">(1). Class moduleClass</h5><p>表示 ModuleAdapter 对应的 ModuleClass。  </p>
<h5 id="(2)-_injectableTypes">(2). injectableTypes</h5><p>String 数组，存储需要依赖注入的类类名。为 @Module 注解的 injects 属性值。  </p>
<h5 id="(3)-_staticInjections">(3). staticInjections</h5><p>Class 数组，存储有静态属性依赖需要注入的类。  </p>
<h5 id="(4)-_boolean_overrides">(4). boolean overrides</h5><p>表示某个 Module 的 @Provides 函数可以覆盖其他 Module，建议只在测试以及开发模式使用。  </p>
<h5 id="(5)-_includes">(5). includes</h5><p>表示 Module 由哪些其他类组成。  </p>
<h5 id="(6)-_boolean_complete">(6). boolean complete</h5><p>表示这个 Module 需要的所有 Binding 是否可以互相提供依赖，即是否能组成一个完整的 DAG。True 表示可以，False 表示不可以。如果一个 Module 有外部依赖的 Bindings 则为 False。  </p>
<h5 id="(7)-_boolean_library">(7). boolean library</h5><p>表示这个 Module 是否提供对外的<code>DenpendencyBinding</code>，True 表示是，False 表示所有 Binding 仅被自己用到。  </p>
<h5 id="4-2-12_Modules-java">4.2.12 Modules.java</h5><p>Modules.java 对外只有一个静态的 loadModules 函数，作用是返回一组 Module 类所对应的一组 ModuleAdapter 实例。<br>该函数入参为 Loader 和一个 ModuleClass 对象数组 seedModulesOrClasses，函数返回一个 HashMap，key 为 ModuleAdapter 对象，Value 为类似入参的 ModuleClass 对象，返回结果不仅包含入参 ModuleClass 及其对应的ModuleAdapter，也包含入参 ModuleClass 嵌套的 ModuleClass 及其对应的ModuleAdapter。  </p>
<p>loadModules 的逻辑比较简单，先通过 Loader.getModuleAdapter() 函数依次得到入参 seedModulesOrClasses 对应的 ModuleAdapter，然后查找得到的 ModuleAdapter 嵌套的 ModuleClass 对应的 ModuleAdapter，ModuleAdapter 嵌套的 ModuleClass 都存放在 ModuleAdapter 的 includes 对象中，由 APT 在编译时解析生成。  </p>
<h5 id="4-2-13_ProblemDetector-java">4.2.13 ProblemDetector.java</h5><p>Binding 问题检测。<br><strong>ProblemDetector 主要函数有：</strong>  </p>
<h5 id="(1)-_detectCircularDependencies(Collection_bindings)">(1). detectCircularDependencies(Collection bindings)</h5><p>检测一组 Binding 是否存在循环依赖。  </p>
<h5 id="(2)-_detectUnusedBinding(Collection_bindings)">(2). detectUnusedBinding(Collection bindings)</h5><p>检测一组 Binding 中是否存在无用的 Binding，即既不依赖其他 Binding 也不被其他 Binding 依赖，对于 DAG 图来说就是孤立的节点。  </p>
<h5 id="(3)-_detectProblems(Collection_values)">(3). detectProblems(Collection values)</h5><p>检测一组 Binding 是否存在问题，直接调用上面两个函数检测。这个函数会被 DaggerObjectGraph.validate() 调用进行检测。  </p>
<h5 id="4-2-14_BuiltInBinding-java">4.2.14 BuiltInBinding.java</h5><p>ProvidesBinding 是 Binding 的子类，它的作用是在 attach 时就已经得到了最终的 Binding，get() 调用时直接返回即可。</p>
<h5 id="4-2-15_LazyBinding-java">4.2.15 LazyBinding.java</h5><p>LazyBinding 是 Binding 的子类，它的作用是延迟实例化 Binding，调用它的 get() 函数时只是返回一个 Lazy 匿名内部类对象，只有调用这个对象的 get() 函数时才会 返回真正的 Dependency。  </p>
<p>这样做的一个好处就是如果，真正的 Binding 的生成很耗费性能，则可以在最开始时只生成轻量级的 LazyBinding，真正要使用时才初始化真正的 Binding。  </p>
<h5 id="4-2-16_ProvidesBinding-java">4.2.16 ProvidesBinding.java</h5><p>ProvidesBinding 是 Binding 的子类，对于 Provide 方式的注入，APT 会一个继承自 ProvidesBinding.java 的子类，该生成类以 Provide 函数名首字母大写加上 ProvidesAdapter 命名，是 Provide 函数所在 Module 对应生成的ModuleAdapter中的静态内部类。<br><strong>ProvidesBinding 主要属性有：</strong>  </p>
<h5 id="(1)-_moduleClass">(1). moduleClass</h5><p>表示被 @Provides 修饰的函数所在的 Module 类名。  </p>
<h5 id="(2)-_methodName">(2). methodName</h5><p>表示被 @Provides 修饰的函数函数名。  </p>
<h5 id="4-2-17_SetBinding-java">4.2.17 SetBinding.java</h5><p>SetBinding 是 Binding 的子类，它的不同处在于保存了父 Binding，这样就形成了一个链表。  </p>
<h5 id="4-2-18_StaticInjection-java">4.2.18 StaticInjection.java</h5><p>抽象类，APT 会为每一个被 @Inject 修饰的静态属性自动生成一个继承自这个 StaticInjection 的子类。该子类会以属性类的 ClassName 加上 $$StaticInjection 命名，在属性类的同一个 package 下。  </p>
<h5 id="4-2-19_Lazy-java">4.2.19 Lazy.java</h5><p>Lazy 是一个接口，用来标记表示可以通过 get() 函数得到真正的对象。</p>
<h5 id="4-2-20_MembersInjector-java">4.2.20 MembersInjector.java</h5><p>MembersInjector 是一个接口，提供了 injectMembers() 用来向<code>Host</code>对象中注入(即设置)<code>Dependency</code>，<code>HostDependency</code>需要实现此接口。  </p>
<h5 id="4-2-21_Module-java">4.2.21 Module.java</h5><p>Module 是一个运行时注解，可以用来修饰类、接口、Enum。用来为 Dagger 提供需要依赖注入的 Host 信息及一些 Dependency 的生成方式。Module 的属性都在<code>ModuleAdapter.java</code>中介绍过，唯一没有介绍过的 addsTo 表示 Module 可以作为哪些类的依赖。  </p>
<p>被 @Module 注解修饰类(ModuleClass)，APT 会生成一个以 ModuleClass 的 ClassName 加上 $$ModuleAdapter 命名，在 ModuleClass 的同一个 package 下的子类。  </p>
<h5 id="4-2-22_Provides-java">4.2.22 Provides.java</h5><p>Provides 是一个注解，只可以用来修饰函数。<br>每个被 @Provides 修饰的生成函数都会生成一个继承自 ProvidesBinding.java 的子类，ProvidesBinding.java 继承自 Binding.java，生成类以 Provide 函数名首字母大写加上 ProvidesAdapter 命名，是 Provide 函数所在 Module 对应生成的ModuleAdapter中的静态内部类。<br>Binding 更具体信息在下面会介绍。  </p>
<h5 id="4-2-23_ErrorHandler_Interface">4.2.23 ErrorHandler Interface</h5><p>位于 Linker.java 内部，表示处理 Linker.linkRequested() 运行过程中的 error。  </p>
<h5 id="4-2-24_ThrowingErrorHandler-java">4.2.24 ThrowingErrorHandler.java</h5><p>上面 ErrorHandler Interface 的实现类，将 errors 汇总后以 IllegalStateException 抛出，为 Linker.linkRequested() 运行过程中积累的 errors 的默认处理方式。  </p>
<h3 id="5-_聊聊_Dagger_本身">5. 聊聊 Dagger 本身</h3><p>Dagger 由于其自身的复杂性，其实是一个上手难度颇高的库，难学会、难用好。但从功能上来讲，它又是一个实用价值非常高的库。而且即将发布的 Dagger 2.0 已经被 Square 转手交给了 Google 来开发和维护，从今以后它就是 Google 的官方库了，那么不论从官方支持方面还是从流行度上面， Dagger 都将会有一个很大的提升。关于 Dagger 的功能和用法，我会写一篇文章详细讲述。在本文的最后，列两个可能比较多人会问的问题和简单的回答：</p>
<h4 id="(1)-_Dagger_适合什么样的项目">(1). Dagger 适合什么样的项目</h4><p>Dagger 是一个依赖注入库，而依赖注入是一种优秀的编程思想，它可以通过解耦项目来提升项目的可阅读性、可扩展性和可维护性，并使得单元测试更为方便。因此，<strong>Dagger 适用于所有项目</strong>。</p>
<h4 id="(2)-_Dagger_适合什么样的个人和团队">(2). Dagger 适合什么样的个人和团队</h4><p>Dagger 适合<strong>有学习能力并且愿意学习</strong>的个人和团队。这里要注意，如果你是开发团队的负责人，在决定启用 Dagger 之前一定要确认你的所有队员(起码是大部分队员)都符合这样的条件，否则 Dagger 可能会起反作用，毕竟——它不是 ButterKnife。</p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 Dagger 部分<br>项目地址：<a href="https://github.com/square/dagger" target="_blank" rel="external">Dagger</a>，分析的版本：<a href="https://github.com/square/dagger/commit/2f9579c48e887ffa316f329c12c2fa2abbec27b1" title="Commit id is 2f9579c48e887ffa316f329c12c2fa2abbec27b1" target="_blank" rel="external">2f9579c</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/dagger-demo" target="_blank" rel="external">Dagger Demo</a><br>分析者：<a href="https://github.com/rengwuxian" target="_blank" rel="external">扔物线</a>，校对者：<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_Dagger">1.1 Dagger</h4><p>Dagger 是一款 Java 平台的依赖注入库，关于依赖注入，详细见 <a href="https://github.com/android-cn/blog/tree/master/java/dependency-injection">依赖注入简介</a>。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之Android Lock Pattern 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_android-lockpattern/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_android-lockpattern/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_介绍">1. 介绍</h3><h4 id="1-1_关于">1.1 关于</h4><p>Android 的图案密码解锁，通过手势连接 3 * 3 的点矩阵绘制图案表示解锁密码。基于 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/com/android/internal/widget/LockPatternView.java" target="_blank" rel="external">Android Source Code</a>。<br><a id="more"></a></p>
<h4 id="1-2_特点">1.2 特点</h4><ul>
<li>支持: Android 1.6+ (API 4+)。</li>
<li>无特殊依赖。</li>
<li>支持手机与平板的布局。</li>
<li>Stealth mode (invisible pattern)。</li>
<li>包含 5 种主题：<ul>
<li>Dark/Light</li>
<li>Light with dark action bar (API 14+)</li>
<li>Dark/Light dialogs</li>
</ul>
</li>
<li>有验证码模式。</li>
</ul>
<h4 id="1-3_使用">1.3 使用</h4><h5 id="1-3-1_Manifest_配置">1.3.1 Manifest 配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"com.haibison.android.lockpattern.LockPatternActivity"</span></span><br><span class="line">    <span class="attribute">android:theme</span>=<span class="value">"@style/Alp.42447968.Theme.Dark"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-2_创建图形锁模式">1.3.2 创建图形锁模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQ_CREATE_PATTERN = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(LockPatternActivity.ACTION_CREATE_PATTERN, <span class="keyword">null</span>, your-context, LockPatternActivity.class);</span><br><span class="line">startActivityForResult(intent, REQ_CREATE_PATTERN);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span><br><span class="line">        Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQ_CREATE_PATTERN: &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] pattern = data.getCharArrayExtra(</span><br><span class="line">                        LockPatternActivity.EXTRA_PATTERN);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-3_验证图形锁">1.3.3 验证图形锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQ_ENTER_PATTERN = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] savedPattern = ...</span><br><span class="line"></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(LockPatternActivity.ACTION_COMPARE_PATTERN, <span class="keyword">null</span>,</span><br><span class="line">        your-context, LockPatternActivity.class);</span><br><span class="line">intent.putExtra(LockPatternActivity.EXTRA_PATTERN, savedPattern);</span><br><span class="line">startActivityForResult(intent, REQ_ENTER_PATTERN);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span><br><span class="line">        Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQ_ENTER_PATTERN: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">switch</span> (resultCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> RESULT_OK:</span><br><span class="line">                <span class="comment">// The user passed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESULT_CANCELED:</span><br><span class="line">                <span class="comment">// The user cancelled the task</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LockPatternActivity.RESULT_FAILED:</span><br><span class="line">                <span class="comment">// The user failed to enter the pattern</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LockPatternActivity.RESULT_FORGOT_PATTERN:</span><br><span class="line">                <span class="comment">// The user forgot the pattern and invoked your recovery Activity.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> retryCount = data.getIntExtra(</span><br><span class="line">                    LockPatternActivity.EXTRA_RETRY_COUNT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_总体设计">2. 总体设计</h3><p>本项目较为简单，总体设计略过，具体实现请参考下面的分析。  </p>
<h3 id="3-_流程图">3. 流程图</h3><h4 id="3-1_创建解锁图案流程图">3.1 创建解锁图案流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/android-lockpattern/image/CreatePattern.png" alt="Create Pattern">  </p>
<h4 id="3-2_验证解锁图案流程图">3.2 验证解锁图案流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/android-lockpattern/image/ComparePattern.png" alt="Compare Pattern">  </p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/android-lockpattern/image/Main.png" alt="Class Diagraph">  </p>
<h4 id="4-2_核心类功能介绍">4.2 核心类功能介绍</h4><h5 id="4-2-1_LockPatternActivity-java">4.2.1 LockPatternActivity.java</h5><p><code>LockPatternActivity</code>类负责所有外部请求，根据<code>ACTION_CREATE_PATTERN</code> <code>ACTION_COMPARE_PATTERN</code> <code>ACTION_VERIFY_CAPTCHA</code> 等<code>Action</code>选择操作模式，加载设置后初始化<code>LockPatternView</code>，在用户完成操作后退出并返回结果。</p>
<p><strong>主要方法说明：</strong>  </p>
<ul>
<li>public void onCreate(Bundle savedInstanceState)<br>首次创建时调用，根据 intent 设置 theme，设置 resultIntent，调用 loadSettings() initContentView()。  </li>
<li>private void loadSettings()<br>根据 metaData 与 Settings 类的内容得到显示模式、最少图形点数、自动存储、自定义加密等配置。  </li>
<li>private void initContentView()<br>根据 Aciton 与配置信息初始化 UI，实例化 OnPatternListener 设置到 LockPatternView 类的对象。  </li>
<li>private void doCheckAndCreatePattern(final List<cell> pattern)<br>首先检查 pattern 是否合法，然后判断 Intent 是否保存有特征码，如果没有就把 pattern 加密并提取特征码 put 到 Intent，如果有就把特征码解密并与 pattern 对比，根据对比结果设置 UI。  </cell></li>
<li>private void doComparePattern(final List<cell> pattern)<br>首先检查 pattern 是否合法，然后从 Intent 或者 Settings 中 get 特征码，把特征码解密后与 pattern 对比，成功则调用 finishWithResultOk(null)，失败次数超过最大次数则调用 finishWithNegativeResult(result_failed)。  </cell></li>
<li>private void finishWithResultOk(char[] pattern)  </li>
<li>private void finishWithNegativeResult(int resultCode)  </li>
</ul>
<h5 id="4-2-2_LockPatternView-java">4.2.2 LockPatternView.java</h5><p><code>LockPatternView</code>类主要是显示解锁的图形界面，在用户操作的时候显示连线与动画，用户操作完成后根据结果做提示。  </p>
<p><strong>添加图形点</strong>  </p>
<ul>
<li>private int getRowHit(float y)<br>遍历所有图形点行高，寻找坐标 y 在哪个图案点的行高范围内。  </li>
<li>private int getColumnHit(float x)<br>遍历所有图形点列宽，寻找坐标 x 在哪个图案点的列宽范围内。  </li>
<li>private Cell checkForNewHit(float x, float y)<br>根据<code>getRowHit(float y)</code>与<code>getColumnHit(float x)</code>返回的行、列判断是否是新的图形点，如果是返回新点，否则返回 null。  </li>
<li>private Cell detectAndAddHit(float x, float y)<br>调用<code>checkForNewHit(float x, float y)</code>返回当前图形点，如图形点非 null，继续判断 pattern list 是否为空，如果不为空就把 last 与当前的图形点之间同一直线的其他点加入 list，然后把当前点加入 list。  </li>
</ul>
<p><strong>按下事件</strong>  </p>
<ul>
<li>handleActionDown(MotionEvent event)<br>首先清理屏幕，获取当前手指的坐标，调用<code>detectAndAddHit(float x, float y)</code>并判断其返回值发送通知与局部刷新。  </li>
</ul>
<p><strong>移动事件</strong>  </p>
<ul>
<li>private void handleActionMove(MotionEvent event)<br>检查手指移动过程中每一个点的坐标，判断如果 pattern list 不为空，则把最后一个图形点的坐标与当前手指坐标的区域进行局部刷新，如果在移动过程中加入了新的图形点则以此点坐标继续局部刷新。  </li>
</ul>
<p><strong>弹起事件</strong>  </p>
<ul>
<li>private void handleActionUp(MotionEvent event)<br>检查 pattern list 如果不为空则停止添加，发送完成消息，全局刷新。  </li>
</ul>
<h5 id="4-2-3_LockPatternUtils-java">4.2.3 LockPatternUtils.java</h5><p><strong>图形摘要并加密</strong></p>
<ul>
<li>public static String patternToSha1(List<lockpatternview.cell> pattern)<br>调用<code>List&lt;LockPatternView.Cell&gt; pattern</code>把pattern list进行信息摘要，然后使用SHA-1算法加密，返回加密的摘要。</lockpatternview.cell></li>
<li>public static String patternToString(List<lockpatternview.cell> pattern)<br>把pattern list进行信息摘要，从左上角起编号为00，至右下角止编号为08，按照list中点的顺序生成编号序列，返回序列。</lockpatternview.cell></li>
</ul>
<h4 id="5-_安全性分析">5. 安全性分析</h4><p>android-lockpattern默认的加密存储流程与Android系统的图形解锁是一致的，以Android系统为例来破解图形锁。</p>
<h5 id="5-1_加密存储过程">5.1 加密存储过程</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/android-lockpattern/image/sec.png" alt="Compare Pattern"> </p>
<h5 id="5-2_破解思路">5.2 破解思路</h5><ul>
<li>图案总数固定：至少四个点、最多九个点、无重复点</li>
<li>加密较弱：单次SHA-1</li>
<li>最快的方法：暴力猜解</li>
</ul>
<h5 id="5-3_实战">5.3 实战</h5><p>首先获取系统图形锁加密摘要文件  </p>
<p><code>adb pull /data/system/gesture.key gesture.key</code></p>
<p>参考<code>4.2.3</code>中的图形摘要规则，然后我写了一个python脚本，生成了9个点所有组合的摘要字符串，同时再生成对应的SHA-1 HEX，这个字典也就57m。</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/android-lockpattern/image/password.jpg" alt="Compare Pattern"> </p>
<p>把<code>gesture.key</code>中的加密字符串在字典中反查即可得出图形锁的原始信息摘要，然后就可以按步骤画图解锁了。</p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 android-lockpattern 部分<br>项目地址：<a href="https://code.google.com/p/android-lockpattern/" target="_blank" rel="external">android-lockpattern</a>，分析的版本：<a href="https://code.google.com/p/android-lockpattern/source/detail?r=40293d2250c2b273223ba25e4aeb3d290a0fdfad" target="_blank" rel="external">40293d2250c2</a>，Demo 地址：等待添加<br>分析者：<a href="https://github.com/liang7" target="_blank" rel="external">爱早起</a>，校对者：<a href="https://github.com/Trinea" target="_blank" rel="external">Trinea</a>，校对状态：未完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_介绍">1. 介绍</h3><h4 id="1-1_关于">1.1 关于</h4><p>Android 的图案密码解锁，通过手势连接 3 * 3 的点矩阵绘制图案表示解锁密码。基于 <a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/com/android/internal/widget/LockPatternView.java">Android Source Code</a>。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之xUtils 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_xUtils/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_xUtils/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>xUtils一个Android公共库框架，主要包括四个部分：View，Db, Http, Bitmap 四个模块。</p>
<ul>
<li>View模块主要的功能是通过注解绑定UI，资源，事件。</li>
<li>Db模块是一个数据库orm框架， 简单的语句就能进行数据的操作。</li>
<li>Http模块主要访问网络，支持同步，异步方式的请求，支持文件的下载。</li>
<li>Bitmap模块是加载图片以及图片的处理， 支持加载本地，网络图片。而且支持图片的内存和本地缓存。  <a id="more"></a>
</li>
</ul>
<h3 id="2-_详细设计">2. 详细设计</h3><h4 id="2-1_View模块">2.1 View模块</h4><h5 id="2-1-1_总体设计">2.1.1 总体设计</h5><p>流程和关系较少， 请看下面的详细分析</p>
<h5 id="2-1-2_流程图">2.1.2 流程图</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/view_sque.png" alt="流程图"></p>
<h5 id="2-1-3_核心类功能介绍">2.1.3 核心类功能介绍</h5><h6 id="请先了解注解_，动态代理_可以帮助到您，_如果已经了解请忽略。">请先了解<a href="https://github.com/android-cn/android-open-project-analysis/blob/master/tech/annotation.md" target="_blank" rel="external">注解</a> ，<a href="https://github.com/android-cn/android-open-project-analysis/blob/master/tech/proxy.md" target="_blank" rel="external">动态代理</a>  可以帮助到您， 如果已经了解请忽略。</h6><p>注解和反射知识是这个模块的主要内容</p>
<h5 id="1-ViewUtils-java">1.ViewUtils.java</h5><p>View和各种事件的注入以及资源的注入。</p>
<h6 id="(1)主要函数">(1)主要函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectObject</span><span class="params">(Object handler, ViewFinder finder)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数Object handler代表的是需要注入的对象， 第二个参数是需要注入View（这个View就是handler的成员变量）所在的View或者Activity的包装对象。<br>该方法完成了View和各种事件的注入以及资源的注入。主要的原理就是通过反射和注解。  </p>
<ul>
<li>完成Activity的setContentView。  </li>
<li>完成View的注入。  </li>
<li>完成资源的注入。  </li>
<li>完成各种事件的注入。  </li>
</ul>
<h5 id="2-ViewFinder-java">2.ViewFinder.java</h5><h6 id="(1)主要函数-1">(1)主要函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pid)</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure>
<p>如果存在父View， 优先从父View寻找，否则从当前的View或者Activity中寻找。</p>
<h5 id="3-ResLoader-java">3.ResLoader.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">loadRes</span><span class="params">(ResType type, Context context, <span class="keyword">int</span> id)</span></span></span><br></pre></td></tr></table></figure>
<p>获取资源文件值。支持多种资源的获取。</p>
<h5 id="4-EventListenerManager-java">4.EventListenerManager.java</h5><p>事件的注入， 其中的设计是通过动态代理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt; listenerCache =</span><br><span class="line">            <span class="keyword">new</span> DoubleKeyValueMap&lt;ViewInjectInfo, Class&lt;?&gt;, Object&gt;();</span><br></pre></td></tr></table></figure></p>
<p>存放监听事件接口map。 因为有些接口有多个函数， 代理会判断事件接口是否存在， 如果存在只增加代理方法就够了， 避免重新设置监听事件接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addEventMethod</span><span class="params">(</span><br><span class="line">            ViewFinder finder,</span><br><span class="line">            ViewInjectInfo info,</span><br><span class="line">            Annotation eventAnnotation,</span><br><span class="line">            Object handler,</span><br><span class="line">            Method method)</span></span></span><br></pre></td></tr></table></figure></p>
<p>代理监听事件</p>
<h5 id="5-注解类">5.注解类</h5><h4 id="2-2_Db模块">2.2 Db模块</h4><h5 id="2-2-1_总体设计">2.2.1 总体设计</h5><p>流程和关系较少， 请看下面的详细分析</p>
<h5 id="2-2-2_流程图">2.2.2 流程图</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/db_sque.png" alt="流程图"></p>
<h5 id="2-2-3_核心类功能介绍">2.2.3 核心类功能介绍</h5><p>注解、反射和数据库操作知识这个模块的主要内容</p>
<h5 id="1-DbUtils-java">1.DbUtils.java</h5><p>主要功能数据库的创建，数据库的增删改查。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, DbUtils&gt; daoMap = <span class="keyword">new</span> HashMap&lt;String, DbUtils&gt;();</span><br></pre></td></tr></table></figure></p>
<p>存放DbUtils实例对象的map，每个数据库对应一个实例， key为数据库的名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> DbUtils <span class="title">getInstance</span><span class="params">(DaoConfig daoConfig)</span></span></span><br></pre></td></tr></table></figure></p>
<p>采取的是单例模式，根据DaoConfig创建数据库， 中间还涉及到数据库升级。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete；</span><br><span class="line">findAll；</span><br><span class="line">findById；</span><br><span class="line">saveOrUpdate；<span class="comment">// 当数据库没有时保存， 存在时修改。</span></span><br><span class="line">update；</span><br></pre></td></tr></table></figure></p>
<p>增删改查。</p>
<h5 id="2-DaoConfig-java">2.DaoConfig.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String dbName = <span class="string">"xUtils.db"</span>; <span class="comment">// default db name数据库名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> dbVersion = <span class="number">1</span>; <span class="comment">//数据库版本</span></span><br><span class="line"><span class="keyword">private</span> DbUpgradeListener dbUpgradeListener; <span class="comment">//升级监听事件</span></span><br></pre></td></tr></table></figure>
<p>数据库配置类。</p>
<h5 id="3-FindTempCache-java">3.FindTempCache.java</h5><p>在DbUtils的查询数据中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Selector selector)</span> <span class="keyword">throws</span> DbException </span>&#123;</span><br><span class="line">	....</span><br><span class="line">	</span><br><span class="line">	String sql = selector.toString();</span><br><span class="line">       <span class="keyword">long</span> seq = CursorUtils.FindCacheSequence.getSeq();</span><br><span class="line">       findTempCache.setSeq(seq);</span><br><span class="line">       Object obj = findTempCache.get(sql);<span class="comment">//优先从缓存读取</span></span><br><span class="line">       <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> (List&lt;T&gt;) obj;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>数据库查询数据的缓存。在查询中会优先调用缓存中的数据</p>
<h5 id="4-SqlInfoBuilder-java">4.SqlInfoBuilder.java</h5><p>sql建表、增删改语句的组合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildCreateTableSqlInfo</span><span class="params">(DbUtils db, Class&lt;?&gt; entityType)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildDeleteSqlInfo</span><span class="params">(DbUtils db, Class&lt;?&gt; entityType, Object idValue)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildDeleteSqlInfo</span><span class="params">(DbUtils db, Class&lt;?&gt; entityType, WhereBuilder whereBuilder)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildDeleteSqlInfo</span><span class="params">(DbUtils db, Object entity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildInsertSqlInfo</span><span class="params">(DbUtils db, Object entity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildUpdateSqlInfo</span><span class="params">(DbUtils db, Object entity, String... updateColumnNames)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlInfo <span class="title">buildUpdateSqlInfo</span><span class="params">(DbUtils db, Object entity, WhereBuilder whereBuilder, String... updateColumnNames)</span></span></span><br></pre></td></tr></table></figure></p>
<h5 id="5-SqlInfo-java">5.SqlInfo.java</h5><p>sql语句和值包装对象。</p>
<h5 id="6-Table-java">6.Table.java</h5><p>表对象。</p>
<h5 id="7-Column-java">7.Column.java</h5><p>表中列对象。</p>
<h5 id="8-Id-java">8.Id.java</h5><p>表对应的主键对象。</p>
<h5 id="9-Selector-java">9.Selector.java</h5><p>sql查询语句的组合。</p>
<h5 id="10-WhereBuilder-java">10.WhereBuilder.java</h5><p>sql条件语句的组合。</p>
<h5 id="2-3_Http模块">2.3 Http模块</h5><h5 id="2-3-1_总体设计">2.3.1 总体设计</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/http_design.png" alt="整体构建思路"></p>
<h5 id="2-3-2_流程图">2.3.2 流程图</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/http_sque.png" alt="流程图">  </p>
<h5 id="2-3-3_类图">2.3.3 类图</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/http_class.png" alt="流程图"></p>
<h5 id="1-HttpUtils-java">1.HttpUtils.java</h5><p>支持异步同步访问网络数据， 断点下载文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络数据的缓存。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> HttpCache sHttpCache = <span class="keyword">new</span> HttpCache();</span><br><span class="line"><span class="comment">//访问网络的HttpClient。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultHttpClient httpClient; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HttpContext httpContext = <span class="keyword">new</span> BasicHttpContext();</span><br><span class="line"><span class="comment">//线程池。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> PriorityExecutor EXECUTOR = <span class="keyword">new</span> PriorityExecutor(DEFAULT_POOL_SIZE);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpUtils</span><span class="params">(<span class="keyword">int</span> connTimeout, String userAgent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//配置超时时间，UserAgent， http版本信息协议等一些信息</span></span><br><span class="line">        .....</span><br><span class="line">		<span class="comment">//将配置的参数统一放到httpClient中</span></span><br><span class="line">        httpClient = <span class="keyword">new</span> DefaultHttpClient(<span class="keyword">new</span> ThreadSafeClientConnManager(params, schemeRegistry), params);</span><br><span class="line">		....</span><br><span class="line"></span><br><span class="line">		<span class="comment">//下面这个关键，设置拦截器。 默认加上gizp压缩。 通过gizp压缩后的数据传输效率高很多。</span></span><br><span class="line">        httpClient.addRequestInterceptor(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(org.apache.http.HttpRequest httpRequest, HttpContext httpContext)</span> <span class="keyword">throws</span> org.apache.http.HttpException, IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!httpRequest.containsHeader(HEADER_ACCEPT_ENCODING)) &#123; </span><br><span class="line">                    httpRequest.addHeader(HEADER_ACCEPT_ENCODING, ENCODING_GZIP);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        httpClient.addResponseInterceptor(<span class="keyword">new</span> HttpResponseInterceptor() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpResponse response, HttpContext httpContext)</span> <span class="keyword">throws</span> org.apache.http.HttpException, IOException </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> HttpEntity entity = response.getEntity();</span><br><span class="line">                <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> Header encoding = entity.getContentEncoding();</span><br><span class="line">                <span class="keyword">if</span> (encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (HeaderElement element : encoding.getElements()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (element.getName().equalsIgnoreCase(<span class="string">"gzip"</span>)) &#123;</span><br><span class="line">							<span class="comment">//这里判断从服务器传输的数据是否需要通过gzip解压。</span></span><br><span class="line">                            response.setEntity(<span class="keyword">new</span> GZipDecompressingEntity(response.getEntity())); </span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问网络数据</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HttpHandler&lt;T&gt; <span class="title">sendRequest</span><span class="params">(HttpRequest request, RequestParams params, RequestCallBack&lt;T&gt; callBack)</span></span>;</span><br><span class="line"><span class="comment">//下载网络文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpHandler&lt;File&gt; <span class="title">download</span><span class="params">(HttpRequest.HttpMethod method, String url, String target,</span><br><span class="line">                                     RequestParams params, <span class="keyword">boolean</span> autoResume, <span class="keyword">boolean</span> autoRename, RequestCallBack&lt;File&gt; callback)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-HttpRequest-java">2.HttpRequest.java</h5><p>网络请求的包装类。 包括url， 访问请求方法， 参数值等。</p>
<h5 id="3-RequestCallBack-java">3.RequestCallBack.java</h5><p>完成数据请求回调接口。  </p>
<h5 id="4-HttpHandler-java">4.HttpHandler.java</h5><p>获取网络数据逻辑的实现。这里可以理解为系统内部AsyncTask。<br>访问网络数据处理流程图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/request_sque.png" alt="流程图"></p>
<h5 id="5-HttpCache-java">5.HttpCache.java</h5><p>网络数据的缓存，内部包含LruMemoryCache。在获取数据的时候会判断是否过期。</p>
<h5 id="6-StringDownLoadHandler-java">6.StringDownLoadHandler.java</h5><p><code>handleEntity()</code>将网络io流转化为String。</p>
<h5 id="7-FileDownLoadHandler-java">7.FileDownLoadHandler.java</h5><p><code>handleEntity()</code>将网络io流转化为File。</p>
<h6 id="8-HttpException-java">8.HttpException.java</h6><p>统一异常</p>
<h5 id="2-4_Bitmap模块">2.4 Bitmap模块</h5><h5 id="2-4-1_总体设计">2.4.1 总体设计</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/bitmap_design.png" alt="整体构建思路"></p>
<h5 id="2-4-2_流程图">2.4.2 流程图</h5><p>请查看http模块</p>
<h5 id="2-4-3_类图">2.4.3 类图</h5><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/bitmap_class.png" alt="类图"></p>
<h5 id="1-BitmapUtils-java">1.BitmapUtils.java</h5><p>图片的异步加载，支持本地和网络图片， 图片的压缩处理， 图片的内存缓存已经本地缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BitmapGlobalConfig globalConfig; <span class="comment">// 线程池，缓存，和网络的配置</span></span><br><span class="line">   <span class="keyword">private</span> BitmapDisplayConfig defaultDisplayConfig; <span class="comment">//图片显示的配置</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * <span class="doctag">@param</span> container 表示需要显示图片的View</span><br><span class="line">    * <span class="doctag">@param</span> uri 图片的uri</span><br><span class="line">    * <span class="doctag">@param</span> displayConfig 图片显示的配置</span><br><span class="line">    * <span class="doctag">@param</span> callBack 图片加载的回调接口</span><br><span class="line">    */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends View&gt; <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(T container, String uri, BitmapDisplayConfig displayConfig, BitmapLoadCallBack&lt;T&gt; callBack)</span></span></span><br></pre></td></tr></table></figure>
<p>设置图片流程图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/bitmap_sque.png" alt="流程图">  </p>
<p>详细流程图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/xutils/image/bitmap_de_sque.png" alt="Bitmap详细流程图"></p>
<h5 id="2-BitmapLoadTask-java">2.BitmapLoadTask.java</h5><p>加载图片的异步任务。在<code>doInBackground</code>中读取图片资源</p>
<h5 id="3-BitmapCache-java">3.BitmapCache.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LruDiskCache mDiskLruCache; <span class="comment">//闪存缓存</span></span><br><span class="line"><span class="keyword">private</span> LruMemoryCache&lt;MemoryCacheKey, Bitmap&gt; mMemoryCache; <span class="comment">//运存缓存</span></span><br></pre></td></tr></table></figure>
<h5 id="(1)主要函数-2">(1)主要函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载网络图片， 然后根据配置压缩图片， 将图片缓存。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">downloadBitmap</span><span class="params">(String uri, BitmapDisplayConfig config, <span class="keyword">final</span> BitmapUtils.BitmapLoadTask&lt;?&gt; task)</span></span><br><span class="line"><span class="comment">//从运存缓存中读取bitmap 在获取的时候会判断是否过期</span></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String uri, BitmapDisplayConfig config)</span></span><br><span class="line"><span class="comment">//从闪存缓存中读取bitmap</span></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromDiskCache</span><span class="params">(String uri, BitmapDisplayConfig config)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="4-BitmapGlobalConfig-java">4.BitmapGlobalConfig.java</h5><p>配置， 包括线程池， 缓存的大小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闪存缓存的路径</span></span><br><span class="line"><span class="keyword">private</span> String diskCachePath;</span><br><span class="line"><span class="comment">//运存缓存的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> memoryCacheSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4MB</span></span><br><span class="line"><span class="comment">//闪存缓存的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> diskCacheSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">50</span>;  <span class="comment">// 50M</span></span><br><span class="line"><span class="comment">//从网络加载数据的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> PriorityExecutor BITMAP_LOAD_EXECUTOR = <span class="keyword">new</span> PriorityExecutor(DEFAULT_POOL_SIZE);</span><br><span class="line"><span class="comment">//从闪存读取数据的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> PriorityExecutor DISK_CACHE_EXECUTOR = <span class="keyword">new</span> PriorityExecutor(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//bitmap缓存的的时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> defaultCacheExpiry = <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>; <span class="comment">// 30 days</span></span><br><span class="line"><span class="comment">//bitmap缓存</span></span><br><span class="line"><span class="keyword">private</span> BitmapCache bitmapCache;</span><br></pre></td></tr></table></figure></p>
<h5 id="5-BitmapDisplayConfig-java">5.BitmapDisplayConfig.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片显示的大小</span></span><br><span class="line">   <span class="keyword">private</span> BitmapSize bitmapMaxSize;</span><br><span class="line"><span class="comment">//图片的动画</span></span><br><span class="line">   <span class="keyword">private</span> Animation animation;</span><br><span class="line"><span class="comment">// 图片加载过程中的显示图片</span></span><br><span class="line">   <span class="keyword">private</span> Drawable loadingDrawable;</span><br><span class="line"><span class="comment">// 图片加载失败的显示图片</span></span><br><span class="line">   <span class="keyword">private</span> Drawable loadFailedDrawable;</span><br><span class="line"><span class="comment">// 图片显示的配置色彩</span></span><br><span class="line">   <span class="keyword">private</span> Bitmap.Config bitmapConfig = Bitmap.Config.RGB_565;</span><br></pre></td></tr></table></figure>
<h5 id="6-DefaultDownloader-java">6.DefaultDownloader.java</h5><p>获取bitmap， 支持三种获取路径， 本地文件，资产文件， 和网络图片。</p>
<h5 id="7-DefaultBitmapLoadCallBack-java">7.DefaultBitmapLoadCallBack.java</h5><p>图片加载完成的的回调， 默认回调将获取的bitmap值传递给view。</p>
<h3 id="3-_杂谈">3. 杂谈</h3><p>和Volley框架相比</p>
<h4 id="相同点：">相同点：</h4><ul>
<li>1.采用了网络数据缓存机制。  </li>
<li>2.通过handler进行线程通信</li>
</ul>
<h4 id="不同点：">不同点：</h4><ul>
<li><ol>
<li>Volley的Http请求在 android 2.3 版本之前是通过HttpClient ，在之后的版本是通过URLHttpConnection。xUtils都是通过HttpClient请求网络（bitmap模块图片下载是通过URLHttpConnection）。 URLHttpConnection默认支持GZIP压缩，api操作简单。</li>
</ol>
</li>
<li>2.Volley将Http请求数据先缓存进byte[]， 然后是分配给不同的请求转化为需要的格式。xUtils是直接转化为想要的格式。 Volley：扩展性好， 但是不能存在大数据请求，否则就OOM。xUtils：不缓存入byte[] 支持大数据的请求， 速度比Volley稍快，但扩展性就低。</li>
<li>4.Volley访问网络数据时直接开启固定个数线程访问网络， 在run方法中执行死循环， 阻塞等待请求队列。 xUtils是开启线程池来管理线程。</li>
<li><ol>
<li>缓存失效策略， volley的所有网络数据支持从http响应头中控制是否缓存和读取缓存失效时间，每个请求可以控制是否缓存和缓存失效时间。 Xutils网络数据请求是统一自定义缓存失效时间。</li>
</ol>
</li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 xUtils 部分。<br>项目地址：<a href="https://github.com/wyouflf/xUtils" target="_blank" rel="external">xUtils</a>，分析的版本：<a href="https://github.com/wyouflf/xUtils/commit/192c2a886c2d467e50718c6e469de63696f5cded" target="_blank" rel="external">192c2a886c</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/xutils-demo" target="_blank" rel="external">xUtils Demo</a><br>分析者：<a href="https://github.com/Caij" target="_blank" rel="external">Caij</a>，校对者：<a href="https://github.com/maogy" target="_blank" rel="external">maogy</a>，校对状态：未完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><p>xUtils一个Android公共库框架，主要包括四个部分：View，Db, Http, Bitmap 四个模块。</p>
<ul>
<li>View模块主要的功能是通过注解绑定UI，资源，事件。</li>
<li>Db模块是一个数据库orm框架， 简单的语句就能进行数据的操作。</li>
<li>Http模块主要访问网络，支持同步，异步方式的请求，支持文件的下载。</li>
<li>Bitmap模块是加载图片以及图片的处理， 支持加载本地，网络图片。而且支持图片的内存和本地缓存。]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之Volley 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_volley/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1-_Volley">1.1. Volley</h4><p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。<br><a id="more"></a></p>
<blockquote>
<p>名字由来：a burst or emission of many things or a large amount at once<br>发布演讲时候的配图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley.png" alt="Volley"></p>
</blockquote>
<p>从名字由来和配图中无数急促的火箭可以看出 Volley 的特点：特别适合<strong>数据量小，通信频繁</strong>的网络操作。（个人认为 Android 应用中绝大多数的网络操作都属于这种类型）。</p>
<h4 id="1-2_Volley_的主要特点">1.2 Volley 的主要特点</h4><p>(1). 扩展性强。Volley 中大多是基于接口的设计，可配置性强。<br>(2). 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。<br>(3). 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，这两者的区别及优劣在<code>4.2.1 Volley</code>中具体介绍。<br>(4). 提供简便的图片加载工具。  </p>
<h3 id="2-_总体设计">2. 总体设计</h3><h4 id="2-1-_总体设计图">2.1. 总体设计图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/design.png" alt="总体设计图"><br>上面是 Volley 的总体设计图，主要是通过两种<code>Diapatch Thread</code>不断从<code>RequestQueue</code>中取出请求，根据是否已缓存调用<code>Cache</code>或<code>Network</code>这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据，然后交由<code>ResponseDelivery</code>去做结果分发及回调处理。  </p>
<h4 id="2-2-_Volley_中的概念">2.2. Volley 中的概念</h4><p>简单介绍一些概念，在<code>详细设计</code>中会仔细介绍。<br>Volley 的调用比较简单，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>后，只需要往这个<code>RequestQueue</code>不断 add Request 即可。  </p>
<p><strong>Volley：</strong>Volley 对外暴露的 API，通过 newRequestQueue(…) 函数新建并启动一个请求队列<code>RequestQueue</code>。  </p>
<p><strong>Request：</strong>表示一个请求的抽象类。<code>StringRequest</code>、<code>JsonRequest</code>、<code>ImageRequest</code> 都是它的子类，表示某种类型的请求。  </p>
<p><strong>RequestQueue：</strong>表示请求队列，里面包含一个<code>CacheDispatcher</code>(用于处理走缓存请求的调度线程)、<code>NetworkDispatcher</code>数组(用于处理走网络请求的调度线程)，一个<code>ResponseDelivery</code>(返回结果分发接口)，通过 start() 函数启动时会启动<code>CacheDispatcher</code>和<code>NetworkDispatchers</code>。  </p>
<p><strong>CacheDispatcher：</strong>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p>
<p><strong>NetworkDispatcher：</strong>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code>去执行后续处理，并判断结果是否要进行缓存。  </p>
<p><strong>ResponseDelivery：</strong>返回结果分发接口，目前只有基于<code>ExecutorDelivery</code>的在入参 handler 对应线程内进行分发。  </p>
<p><strong>HttpStack：</strong>处理 Http 请求，返回请求结果。目前 Volley 中有基于 HttpURLConnection 的<code>HurlStack</code>和 基于 Apache HttpClient 的<code>HttpClientStack</code>。  </p>
<p><strong>Network：</strong>调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。  </p>
<p><strong>Cache：</strong>缓存请求结果，Volley 默认使用的是基于 sdcard 的<code>DiskBasedCache</code>。<code>NetworkDispatcher</code>得到请求结果后判断是否需要存储在 Cache，<code>CacheDispatcher</code>会从 Cache 中取缓存结果。  </p>
<h3 id="3-_流程图">3. 流程图</h3><p>Volley 请求流程图<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/Volley-run-flow-chart.png" alt="Volley请求流程图">  </p>
<blockquote>
<p><strong>上图是 Volley 请求时的流程图，在  Volley 的发布演讲中给出，我在这里将其用中文重新画出。</strong>   </p>
</blockquote>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/volley-class.png" alt="类关系图"><br>这是 Volley 框架的主要类关系图    </p>
<blockquote>
<p>图中<strong>红色圈内</strong>的部分，组成了 Volley 框架的核心，围绕 RequestQueue 类，将各个功能点以<strong>组合</strong>的方式结合在了一起。各个功能点也都是以<strong>接口</strong>或者<strong>抽象类</strong>的形式提供。<br>红色圈外面的部分，在 Volley 源码中放在了toolbox包中，作为 Volley 为各个功能点提供的默认的具体实现。<br>通过类图我们看出， Volley 有着非常好的拓展性。通过各个功能点的接口，我们可以给出自定义的，更符合我们需求的具体实现。</p>
<p><strong>多用组合，少用继承；针对接口编程，不针对具体实现编程。</strong>  </p>
<p><strong>优秀框架的设计，令人叫绝，受益良多。</strong>  </p>
</blockquote>
<h3 id="4-2_核心类功能介绍">4.2 核心类功能介绍</h3><h4 id="4-2-1_Volley-java">4.2.1 Volley.java</h4><p>这个和 Volley 框架同名的类，其实是个工具类，作用是构建一个可用于添加网络请求的<code>RequestQueue</code>对象。<br><strong>(1). 主要函数</strong><br>Volley.java 有两个重载的静态方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span></span></span><br></pre></td></tr></table></figure></p>
<p>第一个方法的实现调用了第二个方法，传 HttpStack 参数为 null。<br>第二个方法中，如果 HttpStatck 参数为 null，则如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 HttpURLConnection 的 HurlStack，如果小于 9，采用基于 HttpClient 的 HttpClientStack。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现<code>BasicNetwork</code>。<br>接着构造一个代表缓存（Cache）的基于 Disk 的具体实现<code>DiskBasedCache</code>。<br>最后将网络（Network）对象和缓存（Cache）对象传入构建一个 RequestQueue，启动这个 RequestQueue，并返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">queue.start();</span><br><span class="line"><span class="keyword">return</span> queue;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们平时大多采用<code>Volly.newRequestQueue(context)</code>的默认实现，构建RequestQueue。<br>通过源码可以看出，我们可以抛开 Volley 工具类构建自定义的RequestQueue，采用自定义的<code>HttpStatck</code>，采用自定义的<code>Network</code>实现，采用自定义的Cache实现等来构建<code>RequestQueue</code>。<br><strong>优秀框架的高可拓展性的魅力来源于此啊</strong></p>
</blockquote>
<p><strong>(2). HttpURLConnection 和 AndroidHttpClient(HttpClient 的封装)如何选择及原因：</strong><br>在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。<br>另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。<br>再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。  </p>
<p><strong>(3). 关于 User Agent</strong><br>通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？<br>如果用 <a href="http://www.trinea.cn/android/android-network-sniffer/" target="_blank" rel="external">Fiddler 或 Charles</a> 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S)</span><br></pre></td></tr></table></figure></p>
<p>经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String userAgent = System.getProperty(<span class="string">"http.agent"</span>);</span><br></pre></td></tr></table></figure></p>
<p>得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String&gt; getHeaders() <span class="keyword">throws</span> AuthFailureError &#123;</span><br><span class="line">    <span class="comment">// self-defined user agent</span></span><br><span class="line">    Map&lt;String, String&gt; headerMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    headerMap.put(<span class="string">"User-Agent"</span>, <span class="string">"android-open-project-analysis/1.0"</span>);</span><br><span class="line">    <span class="keyword">return</span> headerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-2_Request-java">4.2.2 Request.java</h4><p>代表一个网络请求的抽象类。我们通过构建一个<code>Request</code>类的非抽象子类(StringRequest、JsonRequest、ImageRequest或自定义)对象，并将其加入到·RequestQueue·中来完成一次网络请求操作。<br>Volley 支持 8 种 Http 请求方式 <strong>GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH</strong><br>Request 类中包含了请求 url，请求请求方式，请求 Header，请求 Body，请求的优先级等信息。  </p>
<p><strong>因为是抽象类，子类必须重写的两个方法。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>子类重写此方法，将网络返回的原生字节内容，转换成合适的类型。此方法会在工作线程中被调用。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br></pre></td></tr></table></figure>
<p>子类重写此方法，将解析成合适类型的内容传递给它们的监听回调。</p>
<p><strong>以下两个方法也经常会被重写</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBody()</span><br></pre></td></tr></table></figure></p>
<p>重写此方法，可以构建用于 POST、PUT、PATCH 请求方式的 Body 内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, String&gt; getParams()</span><br></pre></td></tr></table></figure></p>
<p>在上面<code>getBody</code>函数没有被重写情况下，此方法的返回值会被 key、value 分别编码后拼装起来转换为字节码作为 Body 内容。  </p>
<h4 id="4-2-3_RequestQueue-java">4.2.3 RequestQueue.java</h4><p>Volley 框架的核心类，将请求Request加入到一个运行的<code>RequestQueue</code>中，来完成请求操作。</p>
<h4 id="(1)-_主要成员变量">(1). 主要成员变量</h4><p>RequestQueue 中维护了两个<strong>基于优先级</strong>的 Request 队列，缓存请求队列和网络请求队列。<br>放在缓存请求队列中的 Request，将通过缓存获取数据；放在网络请求队列中的 Request，将通过网络获取数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>维护了一个正在进行中，尚未完成的请求集合。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="(2)-_启动队列">(2). 启动队列</h4><p>创建出 RequestQueue 以后，调用 start 方法，启动队列。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Starts the dispatchers in this queue.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">    <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start 方法中，开启一个<strong>缓存调度线程<code>CacheDispatcher</code></strong>和 n 个<strong>网络调度线程<code>NetworkDispatcher</code></strong>，这里 n 默认为4，存在优化的余地，比如可以根据 CPU 核数以及网络类型计算更合适的并发数。<br>缓存调度线程不断的从缓存请求队列中取出 Request 去处理，网络调度线程不断的从网络请求队列中取出 Request 去处理。  </p>
<h4 id="(3)-_加入请求">(3). 加入请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span></span>;</span><br></pre></td></tr></table></figure>
<p>流程图如下：<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/RequestQueue-add-flow-chart.png" alt="加入请求流程图">  </p>
<h4 id="(4)-_请求完成">(4). 请求完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span></span></span><br></pre></td></tr></table></figure>
<p>Request 请求结束  </p>
<blockquote>
<p>(1). 首先从正在进行中请求集合<code>mCurrentRequests</code>中移除该请求。<br>(2). 然后查找请求等待集合<code>mWaitingRequests</code>中是否存在等待的请求，如果存在，则将等待队列移除，并将等待队列所有的请求添加到缓存请求队列中，让缓存请求处理线程<code>CacheDispatcher</code>自动处理。  </p>
</blockquote>
<h4 id="(5)-_请求取消">(5). 请求取消</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(RequestFilter filter)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(<span class="keyword">final</span> Object tag)</span></span></span><br></pre></td></tr></table></figure>
<p>取消当前请求集合中所有符合条件的请求。<br>filter 参数表示可以按照自定义的过滤器过滤需要取消的请求。<br>tag 表示按照<code>Request.setTag</code>设置好的 tag 取消请求，比如同属于某个 Activity 的。  </p>
<h4 id="4-2-4_CacheDispatcher-java">4.2.4 CacheDispatcher.java</h4><p>一个线程，用于调度处理走缓存的请求。启动后会不断从缓存请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给<code>ResponseDelivery</code> 去执行后续处理。当结果未缓存过、缓存失效或缓存需要刷新的情况下，该请求都需要重新进入<code>NetworkDispatcher</code>去调度处理。  </p>
<h4 id="(1)-_成员变量">(1). 成员变量</h4><p><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue</code> 缓存请求队列<br><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue</code> 网络请求队列<br><code>Cache mCache</code> 缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类  </p>
<h4 id="(2)-_处理流程图">(2). 处理流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/CacheDispatcher-run-flow-chart.png" alt="缓存调度线程处理流程图">  </p>
<h4 id="4-2-5_NetworkDispatcher-java">4.2.5 NetworkDispatcher.java</h4><p>一个线程，用于调度处理走网络的请求。启动后会不断从网络请求队列中取请求处理，队列为空则等待，请求处理结束则将结果传递给 ResponseDelivery 去执行后续处理，并判断结果是否要进行缓存。</p>
<h4 id="(1)-_成员变量-1">(1). 成员变量</h4><p><code>BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue</code> 网络请求队列<br><code>Network mNetwork</code> 网络类，代表了一个可以执行请求的网络<br><code>Cache mCache</code>  缓存类，代表了一个可以获取请求结果，存储请求结果的缓存<br><code>ResponseDelivery mDelivery</code> 请求结果传递类，可以传递请求的结果或者错误到调用者  </p>
<h4 id="(2)-_处理流程图-1">(2). 处理流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/NetworkDispatcher-run-flow-chart.png" alt="网络调度线程处理流程图">  </p>
<h4 id="4-2-6_Cache-java">4.2.6 Cache.java</h4><p>缓存接口，代表了一个可以获取请求结果，存储请求结果的缓存。</p>
<h4 id="(1)-_主要方法：">(1). 主要方法：</h4><p><code>public Entry get(String key);</code> 通过 key 获取请求的缓存实体<br><code>public void put(String key, Entry entry);</code> 存入一个请求的缓存实体<br><code>public void remove(String key);</code> 移除指定的缓存实体<br><code>public void clear();</code> 清空缓存  </p>
<h4 id="(2)-_代表缓存实体的内部类_Entry">(2). 代表缓存实体的内部类 Entry</h4><p>成员变量和方法<br><code>byte[] data</code> 请求返回的数据（Body 实体）<br><code>String etag</code> Http 响应首部中用于缓存新鲜度验证的 ETag<br><code>long serverDate</code> Http 响应首部中的响应产生时间<br><code>long ttl</code> 缓存的过期时间<br><code>long softTtl</code> 缓存的新鲜时间<br><code>Map&lt;String, String&gt; responseHeaders</code> 响应的 Headers<br><code>boolean isExpired()</code> 判断缓存是否过期，过期缓存不能继续使用<br><code>boolean refreshNeeded()</code> 判断缓存是否新鲜，不新鲜的缓存需要发到服务端做新鲜度的检测  </p>
<h4 id="4-2-7_DiskBasedCache-java">4.2.7 DiskBasedCache.java</h4><p>继承 Cache 类，基于 Disk 的缓存实现类。</p>
<h4 id="(1)-_主要方法：-1">(1). 主要方法：</h4><p><code>public synchronized void initialize()</code> 初始化，扫描缓存目录得到所有缓存数据摘要信息放入内存。<br><code>public synchronized Entry get(String key)</code> 从缓存中得到数据。先从摘要信息中得到摘要信息，然后读取缓存数据文件得到内容。<br><code>public synchronized void put(String key, Entry entry)</code> 将数据存入缓存内。先检查缓存是否会满，会则先删除缓存中部分数据，然后再新建缓存文件。<br><code>private void pruneIfNeeded(int neededSpace)</code> 检查是否能再分配 neededSpace 字节的空间，如果不能则删除缓存中部分数据。<br><code>public synchronized void clear()</code> 清空缓存。<br><code>public synchronized void remove(String key)</code> 删除缓存中某个元素。  </p>
<h4 id="(2)-_CacheHeader_类">(2). CacheHeader 类</h4><p>CacheHeader 是缓存文件摘要信息，存储在缓存文件的头部，与上面的<code>Cache.Entry</code>相似。  </p>
<h4 id="4-2-8_NoCache-java">4.2.8 NoCache.java</h4><p>继承 Cache 类，不做任何操作的缓存实现类，可将它作为构建<code>RequestQueue</code>的参数以实现一个不带缓存的请求队列。  </p>
<h4 id="4-2-9_Network-java">4.2.9 Network.java</h4><p>代表网络的接口，处理网络请求。<br>唯一的方法，用于执行特定请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-10_NetworkResponse-java">4.2.10 NetworkResponse.java</h4><p><code>Network</code>中方法 performRequest 的返回值，<code>Request</code>的 parseNetworkResponse(…) 方法入参，是 Volley 中用于内部 Response 转换的一级。<br>封装了网络请求响应的 StatusCode，Headers 和 Body 等。  </p>
<h4 id="(1)-_成员变量-2">(1). 成员变量</h4><p><code>int statusCode</code> Http 响应状态码<br><code>byte[] data</code> Body 数据<br><code>Map&lt;String, String&gt; headers</code> 响应 Headers<br><code>boolean notModified</code> 表示是否为 304 响应<br><code>long networkTimeMs</code> 请求耗时  </p>
<h4 id="(2)-_Volley_的内部_Response_转换流程图">(2). Volley 的内部 Response 转换流程图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/volley/image/response-process-flow-chart.png" alt="Volley"><br>从上到下表示从得到数据后一步步的处理，箭头旁的注释表示该步处理后的实体类。  </p>
<h4 id="4-2-11_BasicNetwork-java">4.2.11 BasicNetwork.java</h4><p>实现 Network，Volley 中默认的网络接口实现类。调用<code>HttpStack</code>处理请求，并将结果转换为可被<code>ResponseDelivery</code>处理的<code>NetworkResponse</code>。<br>主要实现了以下功能：<br>(1). 利用 HttpStack 执行网络请求。<br>(2). 如果 Request 中带有实体信息，如 Etag,Last-Modify 等，则进行缓存新鲜度的验证，并处理 304（Not Modify）响应。<br>(3). 如果发生超时，认证失败等错误，进行重试操作，直到成功、抛出异常(不满足重试策略等)结束。  </p>
<h4 id="4-2-12_HttpStack-java">4.2.12 HttpStack.java</h4><p>用于处理 Http 请求，返回请求结果的接口。目前 Volley 中的实现有基于 HttpURLConnection 的 HurlStack 和 基于 Apache HttpClient 的 HttpClientStack。<br>唯一方法，执行请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br></pre></td></tr></table></figure></p>
<p>执行 Request 代表的请求，第二个参数表示发起请求之前，添加额外的请求 Headers。  </p>
<h4 id="4-2-13_HttpClientStack-java">4.2.13 HttpClientStack.java</h4><p>实现 HttpStack 接口，利用 Apache 的 HttpClient 进行各种请求方式的请求。<br>基本就是 org.apache.http 包下面相关类的常见用法，不做详解，不过与下面 HttpURLConnection 做下对比就能发现 HttpURLConnection 的 API 相对简单的多。  </p>
<h4 id="4-2-14_HurlStack-java">4.2.14 HurlStack.java</h4><p>实现 HttpStack 接口，利用 Java 的 HttpURLConnection 进行各种请求方式的请求。  </p>
<h4 id="4-2-15_Response-java">4.2.15 Response.java</h4><p>封装了经过解析后的数据，用于传输。并且有两个内部接口 Listener 和 ErrorListener 分别可表示请求失败和成功后的回调。<br>Response 的构造函数被私有化，而通过两个函数名更易懂的静态方法构建对象。  </p>
<h4 id="4-2-16_ByteArrayPool-java">4.2.16 ByteArrayPool.java</h4><p>byte[] 的回收池，用于 byte[] 的回收再利用，减少了内存的分配和回收。<br>主要通过一个元素长度从小到大排序的<code>ArrayList</code>作为 byte[] 的缓存，另有一个按使用时间先后排序的<code>ArrayList</code>属性用于缓存满时清理元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span></span></span><br></pre></td></tr></table></figure></p>
<p>将用过的 byte[] 回收，根据 byte[] 长度按照从小到大的排序将 byte[] 插入到缓存中合适位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len)</span><br></pre></td></tr></table></figure></p>
<p>获取长度不小于 len 的 byte[]，遍历缓存，找出第一个长度大于传入参数<code>len</code>的 byte[]，并返回；如果最终没有合适的byte[]，new 一个返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>当缓存的 byte 超过预先设置的大小时，按照先进先出的顺序删除最早的 byte[]。  </p>
<h4 id="4-2-17_PoolingByteArrayOutputStream-java">4.2.17 PoolingByteArrayOutputStream.java</h4><p>继承ByteArrayOutputStream，原始 ByteArrayOutputStream 中用于接受写入 bytes 的 buf，每次空间不足时便会 new 更大容量的 byte[]，而 PoolingByteArrayOutputStream 使用了 ByteArrayPool 作为 Byte[] 缓存来减少这种操作，从而提高性能。  </p>
<h4 id="4-2-18_HttpHeaderParser-java">4.2.18 HttpHeaderParser.java</h4><p>Http header 的解析工具类，在 Volley 中主要作用是用于解析 Header 从而判断返回结果是否需要缓存，如果需要返回 Header 中相关信息。<br>有三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parseDateAsEpoch</span><span class="params">(String dateStr)</span></span></span><br></pre></td></tr></table></figure></p>
<p>解析时间，将 RFC1123 的时间格式，解析成 epoch 时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers)</span></span></span><br></pre></td></tr></table></figure>
<p>解析编码集，在 Content-Type 首部中获取编码集，如果没有找到，默认返回 ISO-8859-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>比较重要的方法</strong>，通过网络响应中的缓存控制 Header 和 Body 内容，构建缓存实体。如果 Header 的 Cache-Control 字段含有<code>no-cache</code>或<code>no-store</code>表示不缓存，返回 null。<br>(1). 根据 Date 首部，获取响应生成时间<br>(2). 根据 ETag 首部，获取响应实体标签<br>(3). 根据 Cache－Control 和 Expires 首部，计算出缓存的过期时间，和缓存的新鲜度时间</p>
<blockquote>
<p>两点需要说明下：<br>1.没有处理<code>Last-Modify</code>首部，而是处理存储了<code>Date</code>首部，并在后续的新鲜度验证时，使用<code>Date</code>来构建<code>If-Modified-Since</code>。<br>这与 Http 1.1 的语义有些违背。<br>2.计算过期时间，Cache－Control 首部优先于 Expires 首部。  </p>
</blockquote>
<h4 id="4-2-19_RetryPolicy-java">4.2.19 RetryPolicy.java</h4><p>重试策略接口<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>获取当前请求用时（用于Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>获取已经重试的次数（用于Log）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br></pre></td></tr></table></figure></p>
<p>确定是否重试，参数为这次异常的具体信息。在请求异常时此接口会被调用，可在此函数实现中抛出传入的异常表示停止重试。  </p>
<h4 id="4-2-20_DefaultRetryPolicy-java">4.2.20 DefaultRetryPolicy.java</h4><p>实现 RetryPolicy，Volley 默认的重试策略实现类。主要通过在 retry(…) 函数中判断重试次数是否达到上限确定是否继续重试。<br>其中<code>mCurrentTimeoutMs</code>变量表示已经重试次数。<br><code>mBackoffMultiplier</code>表示每次重试之前的 timeout 该乘以的因子。<br><code>mCurrentTimeoutMs</code>变量表示当前重试的 timeout 时间，会以<code>mBackoffMultiplier</code>作为因子累计前几次重试的 timeout。  </p>
<h4 id="4-2-21_ResponseDelivery-java">4.2.21 ResponseDelivery.java</h4><p>请求结果的传输接口，用于传递请求结果或者请求错误。<br>有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传递请求结果，<code>request</code> 和 <code>response</code> 参数分别表示请求信息和返回结果信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传递请求结果，并在完成传递后执行 Runnable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此方法用于传输请求错误。  </p>
<h4 id="4-2-22_ExecutorDelivery-java">4.2.22 ExecutorDelivery.java</h4><p>请求结果传输接口具体实现类。<br>在 Handler 对应线程中传输缓存调度线程或者网络调度线程中产生的请求结果或请求错误，会在请求成功的情况下调用 Request.deliverResponse(…) 函数，失败时调用 Request.deliverError(…) 函数。  </p>
<h4 id="4-2-23_StringRequest-java">4.2.23 StringRequest.java</h4><p>继承 Request 类,代表了一个返回值为 String 的请求。将网络返回的结果数据解析为 String 类型。通过构造函数的 listener 传参，支持请求成功后的 onResponse(…) 回调。  </p>
<h4 id="4-2-24_JsonRequest-java">4.2.24 JsonRequest.java</h4><p>抽象类，继承自 Request，代表了 body 为 JSON 的请求。提供了构建 JSON 请求参数的方法。  </p>
<h4 id="4-2-25_JsonObjectRequest-java">4.2.25 JsonObjectRequest.java</h4><p>继承自 JsonRequest，将网络返回的结果数据解析为 JSONObject 类型。  </p>
<h4 id="4-2-26_JsonArrayRequest-java">4.2.26 JsonArrayRequest.java</h4><p>继承自 JsonRequest，将网络返回的结果数据解析为 JSONArray 类型。  </p>
<h4 id="4-2-27_ImageRequest-java">4.2.27 ImageRequest.java</h4><p>继承 Request 类，代表了一个返回值为 Image 的请求。将网络返回的结果数据解析为 Bitmap 类型。<br>可以设置图片的最大宽度和最大高度，并计算出合适尺寸返回。每次最多解析一张图片防止 OOM。  </p>
<h4 id="4-2-28_ImageLoader-java">4.2.28 ImageLoader.java</h4><p>封装了 ImageRequst 的方便使用的图片加载工具类。 </p>
<blockquote>
<p>1.可以设置自定义的<code>ImageCache</code>，可以是内存缓存，也可以是 Disk 缓存，将获取的图片缓存起来，重复利用，减少请求。<br>2.可以定义图片请求过程中显示的图片和请求失败后显示的图片。<br>3.相同请求（相同地址，相同大小）只发送一个，可以避免重复请求。<br>// TODO  </p>
</blockquote>
<h4 id="4-2-29_NetworkImageView-java">4.2.29 NetworkImageView.java</h4><p>利用 ImageLoader，可以加载网络图片的 ImageView<br>有三个公开的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultImageResId</span><span class="params">(<span class="keyword">int</span> defaultImage)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置默认图片，加载图片过程中显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorImageResId</span><span class="params">(<span class="keyword">int</span> errorImage)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置错误图片，加载图片失败后显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImageUrl</span><span class="params">(String url, ImageLoader imageLoader)</span></span></span><br></pre></td></tr></table></figure></p>
<p>设置网络图片的 Url 和 ImageLoader，将利用这个 ImageLoader 去获取网络图片。  </p>
<blockquote>
<p>如果有新的图片加载请求，会把这个ImageView上旧的加载请求取消。  </p>
</blockquote>
<h4 id="4-2-30_ClearCacheRequest-java">4.2.30 ClearCacheRequest.java</h4><p>用于人为清空 Http 缓存的请求。<br>添加到 RequestQueue 后能很快执行，因为优先级很高，为<code>Priority.IMMEDIATE</code>。并且清空缓存的方法<code>mCache.clear()</code>写在了<code>isCanceled()</code>方法体中，能最早的得到执行。  </p>
<p>ClearCacheRequest 的写法不敢苟同，目前看来唯一的好处就是可以将清空缓存操作也当做一个请求。而在<code>isCanceled()</code>中做清空操作本身就造成了歧义，不看源码没人知道在<code>NetworkDispatcher</code> run 方法循环的过程中，<code>isCanceled()</code>这个读操作竟然做了可能造成缓存被清空。只能跟源码的解释一样当做一个 Hack 操作。  </p>
<h4 id="4-2-31_Authenticator-java">4.2.31 Authenticator.java</h4><p>身份认证接口，用于基本认证或者摘要认证。这个类是 Volley 用于和身份验证打通的接口，比如 OAuth，不过目前的使用不是特别广泛和 Volley 的内部结合也不是特别紧密。  </p>
<h4 id="4-2-32_AndroidAuthenticator-java">4.2.32 AndroidAuthenticator.java</h4><p>继承 Authenticator，基于 Android AccountManager 的认证交互实现类。  </p>
<h4 id="4-2-33_VolleyLog-java">4.2.33 VolleyLog.java</h4><p>Volley 的 Log 工具类。  </p>
<h4 id="4-2-34_VolleyError-java">4.2.34 VolleyError.java</h4><p>Volley 中所有错误异常的父类，继承自 Exception，可通过此类设置和获取 NetworkResponse 或者请求的耗时。  </p>
<h4 id="4-2-35_AuthFailureError-java">4.2.35 AuthFailureError.java</h4><p>继承自 VolleyError，代表请求认证失败错误，如 RespondeCode 的 401 和 403。  </p>
<h4 id="4-2-36_NetworkError-java">4.2.36 NetworkError.java</h4><p>继承自 VolleyError，代表网络错误。  </p>
<h4 id="4-2-37_ParseError-java">4.2.37 ParseError.java</h4><p>继承自 VolleyError，代表内容解析错误。  </p>
<h4 id="4-2-38_ServerError-java">4.2.38 ServerError.java</h4><p>继承自 VolleyError，代表服务端错误。  </p>
<h4 id="4-2-39_TimeoutError-java">4.2.39 TimeoutError.java</h4><p>继承自 VolleyError，代表请求超时错误。  </p>
<h4 id="4-2-40_NoConnectionError-java">4.2.40 NoConnectionError.java</h4><p>继承自NetworkError，代表无法建立连接错误。  </p>
<h3 id="5-_杂谈">5. 杂谈</h3><h4 id="5-1_关于_Http_缓存">5.1 关于 Http 缓存</h4><p>Volley 构建了一套相对完整的符合 Http 语义的缓存机制。<br><strong>优点和特点</strong><br>(1). 根据<code>Cache-Control</code>和<code>Expires</code>首部来计算缓存的过期时间。如果两个首部都存在情况下，以<code>Cache-Control</code>为准。<br>(2). 利用<code>If-None-Match</code>和<code>If-Modified-Since</code>对过期缓存或者不新鲜缓存，进行请求再验证，并处理 304 响应，更新缓存。<br>(3). 默认的缓存实现，将缓存以文件的形式存储在 Disk，程序退出后不会丢失。</p>
<p><strong>我个人认为的不足之处</strong><br>缓存的再验证方面，在构建<code>If-Modified-Since</code>请求首部时，Volley 使用了服务端响应的<code>Date</code>首部，没有使用<code>Last-Modified</code>首部。整个框架没有使用<code>Last-Modified</code>首部。这与 Http 语义不符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">        headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端根据请求时通过<code>If-Modified-Since</code>首部传过来的时间，判断资源文件是否在<code>If-Modified-Since</code>时间 <strong>以后</strong> 有改动，如果有改动，返回新的请求结果。如果没有改动，返回 304 not modified。<br><code>Last-Modified</code>代表了资源文件的最后修改时间。通常使用这个首部构建<code>If-Modified-Since</code>的时间。<br><code>Date</code>代表了响应产生的时间，正常情况下<code>Date</code>时间在<code>Last-Modified</code>时间之后。也就是<code>Date</code>&gt;=<code>Last-Modified</code>。<br>通过以上原理，既然<code>Date</code>&gt;=<code>Last-Modified</code>。那么我利用<code>Date</code>构建，也是完全正确的。  </p>
<p><strong>可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http 语义，采用时间比较的方式来验证<code>If-Modified-Since</code>，判断服务器资源文件修改时间是不是在<code>If-Modified-Since</code>之后。那么使用<code>Date</code>完全正确。</strong><br><strong>可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和<code>If-Modified-Since</code>所传时间相等。这样使用<code>Date</code>就不能实现正确的再验证，因为<code>Date</code>的时间总不会和服务器资源文件修改时间相等。</strong>  </p>
<p>尽管使用<code>Date</code>可能出现的不正确情况，归结于服务端没有正确的实现 Http 语义。<br><strong>但我还是希望Volley也能完全正确的实现Http语义，至少同时处理<code>Last-Modified</code>和<code>Date</code>,并且优先使用<code>Last-Modified</code>。</strong>  </p>
<h4 id="5-2_Bug">5.2 Bug</h4><h5 id="(1)-_BasicNetwork-performRequest(…)">(1). BasicNetwork.performRequest(…)</h5><p>如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">            NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ……</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BasicNetwork.performRequest(…) 最后的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br></pre></td></tr></table></figure></p>
<p>应该是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(e);</span><br></pre></td></tr></table></figure></p>
<p>更合理。  </p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 Volley 部分<br>项目地址：<a href="https://android.googlesource.com/platform/frameworks/volley/" target="_blank" rel="external">Volley</a>，分析的版本：<a href="https://android.googlesource.com/platform/frameworks/volley/+/35ce77836d8e1e951b8e4b2ec43e07fb7336dab6" target="_blank" rel="external">35ce778</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/volley-demo" target="_blank" rel="external">Volley Demo</a><br>分析者：<a href="https://github.com/grumoon" target="_blank" rel="external">grumoon</a>，校对者：<a href="https://github.com/huxian99" target="_blank" rel="external">huxian99</a>、<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1-_Volley">1.1. Volley</h4><p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之ViewPagerindicator 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_view-pager-indicator/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_view-pager-indicator/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h3 id="1-1_ViewPagerIndicator">1.1 ViewPagerIndicator</h3><p>ViewPagerIndicator用于各种基于AndroidSupportLibrary中ViewPager的界面导航。主要特点：使用简单、样式全、易扩展。<br><a id="more"></a></p>
<h3 id="2-_总体设计">2. 总体设计</h3><p>该项目总体设计非常简单，一个pageIndicator接口类，具体样式的导航类实现该接口，然后根据具体样式去实现相应的逻辑。<br>IcsLinearLayout：LinearLayout的扩展，支持了4.0以上的divider特性。<br>CirclePageIndicator、LinePageIndicator、UnderlinePageIndicator、TitlePagerIndicator继承自View。TabPageIndicator、IconPageIndicator 继承自HorizontalScrollView。</p>
<p>CirclePageIndicator、LinePageIndicator、UnderlinePageIndicator继承自View的原因是它们样式相对简单，继承View，自己去定制一套测量和绘制逻辑更简单，而且免去了Measure部分繁琐的步骤，效率更高。<br>TitlePagerIndicator相对复杂，Android系统提供的控件中没有类似的，而且实现底部线条的精准控制也复杂，所以只能继承自View，实现绘制逻辑，达到理想的UI效果。      </p>
<p>TabPageIndicator、IconPageIndicator继承自HorizontalScrollView是由于它们各自的ChildView较多，而且具有相似性些，继承自LinearLayout，通过for循环一个个add上去更简单，而且HorizontalScrollView具有水平滑动的功能，当tab比较多的时候，可以左右滑动。  </p>
<h3 id="3-_详细设计">3. 详细设计</h3><h4 id="3-1类关系图">3.1类关系图</h4><p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/view-pager-indicator/image/class_relation.png" alt="viewpagerindicator img">  </p>
<h4 id="3-2_自定义控件相关知识">3.2 自定义控件相关知识</h4><p>由于ViewPagerIndicator项目全部都是自定义View，因此对于其原理的分析，就是对自定义View的分析，自定义View涉及到的核心部分有：View的绘制机制和Touch事件传递机制。对于View的绘制机制，这里做了详细的阐述，这一部分在Android中为公共知识点，已经将这一部分的内容单独去了，在<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tech" target="_blank" rel="external">tech</a>目录下，而对于Touch事件，由于该项目只是Indicator，因此没有涉及到复杂的Touch传递机制，该项目中与Touch机制相关只有onTouch(Event)方法，因此只对该方法涉及到的相关知识进行介绍。</p>
<h4 id="3-2-1_自定义控件步骤">3.2.1 自定义控件步骤</h4><ol>
<li><p>创建自定义的View  </p>
<ul>
<li>继承View或View的子类，添加必要的构造函数</li>
<li>定义自定义属性（外观与行为）</li>
<li>应用自定义属性：在布局中指定属性值，在初始化时获取并应用到View上</li>
<li>添加控制属性的方法</li>
</ul>
</li>
<li><p>自定义View的绘制<br>重写onDraw()方法,按需求绘制自定义的view。每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象，比如绘制过程中使用的Paint，应该在初始化的时候就创建，而不是在onDraw方法中。</p>
</li>
<li><p>使View具有交互性<br>一个好的自定义View还应该具有交互性，使用户可以感受到UI上的微小变化，并且这些变化应该尽可能的和现实世界的物理规律保持一致，更自然。Android提供一个输入事件模型，帮助你处理用户的输入事件,你可以借助GestureDetector、Scroller、属性动画等使得过渡更加自然和流畅。 </p>
</li>
</ol>
<h4 id="3-2-2_Android的拖拽事件">3.2.2 Android的拖拽事件</h4><p>该项目使用的是ViewPager，本来不用处理拖拽事件的，但项目中的CirclePageIndicator、LinePageIndicator、UnderlinePageIndicator、TitlePageIndicator都对onTouchEvent进行了处理，开始不明白，后来看到该项目的Issue，有问到该问题的:<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/issues/213" target="_blank" rel="external">CirclePageIndicator consuming TouchEvents</a> 原来是模仿了IOS中springboard的Indicator，使得点击Indicator的左1/3和右边1/3都可以切换Page，如果你使用该项目同时又处理了Touch事件，有可能它们会出现冲突问题，下面是涉及到的拖拽事件相关的知识点：</p>
<h5 id="3-2-2-1_区分原始点及之后的任意触摸点">3.2.2.1 区分原始点及之后的任意触摸点</h5><p>ACTION_POINTER_DOWN、ACTION_POINTER_UP:多触摸手势事件中的按下和抬起事件。每当第二个触控点按下或拿起时，会触发该事件。在onTouchEvent()中可以捕捉并处理。</p>
<h5 id="3-2-2-2_确保操作中点的ID(the_active_pointer_ID)有效">3.2.2.2 确保操作中点的ID(the active pointer ID)有效</h5><p>当ACTION_POINTER_UP事件发生时，示例程序会移除对该点的索引值的引用，确保操作中的点的ID(the active pointer ID)不会引用已经不在触摸屏上的触摸点。这种情况下，app会选择另一个触摸点来作为操作中(active)的点，并保存它当前的x、y。可以在触控点MOVE时，始终能拿到有效的Pointer正确的计算移动的距离。</p>
<h5 id="3-2-2-3_mTouchSlop">3.2.2.3 mTouchSlop</h5><p>指在用户触摸事件可被识别为移动手势前,移动过的那一段像素距离。Touchslop通常用来预防用户在做一些其他操作时意外地滑动，例如触摸屏幕上的元素时。</p>
<p>在本项目中，对于onTouche的处理是模板方法，因为没有复杂的交互，仅仅是追踪有效的手势以及确定Page的切换时机。官方文档中在拖拽与缩放中有详细的讲解<a href="http://developer.android.com/training/gestures/scale.html" target="_blank" rel="external">Dragging and Scaling</a> 本项目中的onTouchEvent中的代码就是官方文档的模板代码，就是为了确保获取到可用、可信的点，然后对ViewPager相应处理。</p>
<h4 id="3-2-3_View绘制机制">3.2.3 View绘制机制</h4><p>请直接参考<a href="https://github.com/android-cn/android-open-project-analysis/blob/master/tech/viewdrawflow.md" target="_blank" rel="external">公共技术点viewdrawflow</a>部分  </p>
<h3 id="3-3_核心类及功能介绍">3.3 核心类及功能介绍</h3><h5 id="3-3-1_CirclePageIndicator">3.3.1 CirclePageIndicator</h5><p>继承自 View 实现了 PageIndicator,整个绘制过程中用到的方法调用规则为：<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/view-pager-indicator/image/circle_indicator_method_flow.png" alt="circle_indicator_method_flow img"><br><strong>(1) 主要成员变量含义</strong><br>1.<code>mCurrentPage</code> 当前界面的索引<br>2.<code>mSnapPage</code> Sanp模式下，当前界面的索引<br>3.<code>mPageOffset</code> ViewPager的水平偏移量<br>4.<code>mScrollState</code> ViewPager的滑动状态<br>5.<code>mOrientation</code> Indicator的模式：水平、竖直<br>6.<code>mLastMotionX</code> 每一次onTouch事件产生时水平位置的最后偏移量<br>7.<code>mActivePointerId</code> 当前处于活动中pointer的ID默认值为 -1<br>8.<code>mIsDragging</code> 用户是否主观的滑动屏幕的标识<br>9.<code>mSnap</code><br>circle有2种绘制模式:<br>     mSnap = true：ViewPager滑动过程中，circle之间不绘制，只绘制最终的实心点<br>     mSnap = false：ViewPager滑动过程中，相邻circle之间根据mPageOffset实时绘制circle<br>10.<code>mTouchSlop</code><br>指在用户触摸事件可被识别为移动手势前,移动过的那一段像素距离。<br>Touchslop通常用来预防用户在做一些其他操作时意外地滑动，例如触摸屏幕上的元素时产生的滑动。</p>
<p><strong>(2) 核心方法</strong><br>1.<strong>onDraw(Canvas canvas)</strong><br><code>threeRadius</code>两相邻circle的间距<br><code>shortOffset</code>当前方向的垂直方向的圆心坐标位置<br><code>longOffset</code> 当前方向的圆心位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环的 draw circle</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> iLoop = <span class="number">0</span>; iLoop &lt; count; iLoop++) &#123;</span><br><span class="line">           <span class="keyword">float</span> drawLong = longOffset + (iLoop * threeRadius);<span class="comment">//计算当前方向的每个circle偏移量</span></span><br><span class="line">           canvas.drawCircle(dX, dY, pageFillRadius, mPaintPageFill);<span class="comment">//绘制空心的circle</span></span><br><span class="line">           canvas.drawCircle(dX, dY, mRadius, mPaintStroke);<span class="comment">//绘制stroke</span></span><br><span class="line">           ...</span><br><span class="line">           计算实心的circle的坐标</span><br><span class="line">           ...</span><br><span class="line">           canvas.drawCircle(dX, dY, mRadius, mPaintFill);<span class="comment">//绘制当前page的circle</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>onTouchEvent(MotionEvent ev)</strong><br>核心思想：获取拖拽过程中有效的触摸点，正确计算移动距离。这一部分为模板代码，在其它几种Indicator的实现中，对于Touch的事件的处理是相同的，<br><code>MotionEvent.ACTION_DOWN</code>:记录第一触摸点的ID,获取当前水平移动距离<br><code>MotionEvent.ACTION_MOVE</code>: 获取第一点的索引并计算其偏移，处理用户是否是主观的滑动屏幕<br><code>MotionEvent.ACTION_CANCEL</code>:如果用户不是主动滑动，则以Indicator的1/3和2/3为临界点进行previous和next<br>page的处理，处理完成，还原mIsDragging，mActivePointerId、viewpager的fakeDragging状态<br><code>MotionEvent.ACTION_UP</code>:同上<br><code>MotionEventCompat.ACTION_POINTER_DOWN</code>:当除最初点外的第一个外出现在屏幕上时，触发该事件，这时记录新的mLastMotionX，mActivePointerId<br><code>MotionEventCompat.ACTION_POINTER_UP</code>:当非第一点离开屏幕时，获取抬起手指的ID，如果之前跟踪的mActivePointerId是当前抬起的手指ID，那么就重新为mActivePointerId 赋值另一个活动中的pointerId，最后再次获取仍活动在屏幕上pointer的X坐标值  </p>
<p>3.<strong>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</strong><br>View在测量阶段的最终大小的设定是由setMeasuredDimension()方法决定的,也是必须要调用的方法，否则会报异常，这里就直接调用了setMeasuredDimension()方法设置值了。根据CircleIndicator的方向，计算相应的width、height<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mOrientation == HORIZONTAL) &#123;</span><br><span class="line">        setMeasuredDimension(measureLong(widthMeasureSpec), measureShort(heightMeasureSpec));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setMeasuredDimension(measureShort(widthMeasureSpec), measureLong(heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.<strong>measureLong</strong><br>与之对应的有measureShort，只是处理的方向不同<br>如果该View的测量要求为EXACTLY，则能直接确定子View的大小,该大小就是MeasureSpec.getSize(measureSpec)的值<br>如果该View的测量要求为UNSPECIFIED或AT_MOST模式，则根据实际需求计算宽度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((specMode == MeasureSpec.EXACTLY) || (mViewPager == <span class="keyword">null</span>))&#123;</span><br><span class="line">    <span class="comment">//We were told how big to be</span></span><br><span class="line">    result = specSize;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mViewPager.getAdapter().getCount();</span><br><span class="line">    result = (<span class="keyword">int</span>)(getPaddingLeft() + getPaddingRight()</span><br><span class="line">            + (count * <span class="number">2</span> * mRadius) + (count - <span class="number">1</span>) * mRadius + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果父视图的测量要求为AT_MOST，即限定了一个最大值，则再从系统建议值和自己计算值中取一个较小值</span></span><br><span class="line">    <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">        result = Math.min(result, specSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-3-2_IconPageIndicator、TabPageIndicator">3.3.2 IconPageIndicator、TabPageIndicator</h5><p>都是继承自HorizontalScrollView，而且实现逻辑很相似，所以这里只对IconPageIndicator分析  </p>
<p><strong>(1) 主要成员变量含义</strong><br>1.<code>mIconsLayout</code>  管理Icon的父视图。在初始化的时候，直接通过addView()加入到根节点。<br>2.<code>mIconSelector</code>  IconPageIndicator  Post的Runnable对象，该对象会执行滑动到指定的Icon位置的逻辑。</p>
<p><strong>(2) 核心方法</strong><br>1.<code>notifyDataSetChanged</code> 在setViewPager中调用，用于创建IconPageIndicator，内部通过一个for循环不断new ImageView，然后add到mIconsLayout上去，紧接着请求布局。<br>2.<code>animateToIcon</code>滑动到指定的Icon，及时回收上一次的mIconSelector，同时post一个新的mIconSelector。<br>3.<code>onAttachedToWindow</code> 该方法在View attach 到Window的时候被调用，此时View拥有了一片可绘制区域，此时可以做一些初始化的操作，这里初始化了之前选定的Icon。<br>4.<code>onDetachedFromWindow</code>该方法调用后，View不再拥有可绘制的区域。此时可以对View进行一些清理操作。这里将mIconSelector从消息队列中移除。</p>
<h5 id="3-3-3_TitlePageIndicator">3.3.3 TitlePageIndicator</h5><p>由于效果的实时性和复杂性，整个Indicator全部都是绘制出来的，主要逻辑都在onDraw中。<br><strong>(1) 主要成员变量含义</strong><br>1.<code>mPaintText</code>绘制Text的Paint<br>2.<code>mPaintFooterLine</code>绘制底线的Paint<br>3.<code>mPaintFooterIndicator</code> 当前title底部指示器的Paint</p>
<p><strong>(2) 核心方法</strong><br>1.<code>calculateAllBounds</code> 根据当前选中的Title计算所有Title的边界值<br>2.<code>clipViewOnTheLeft</code>为左边的TextView设置边界，当TextView向左移至Indicator的边界时，则设置该TextViwe的left坐标值始终为Indicator的left坐标值，从而呈现停留的效果。<br>3.<code>clipViewOnTheRight</code>同上，反向相反  </p>
<p>整个绘制流程：  </p>
<p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/view-pager-indicator/image/title_indicator_draw_flow.png" alt="title_indicator_draw_flow"></p>
<h5 id="3-3-4_LinePageIndicator、UnderLineIndicator">3.3.4  LinePageIndicator、UnderLineIndicator</h5><p>类似CirclePageIndicator，可以参考CirclePageIndicator的分析。  </p>
<h4 id="3-4_创建自定义View的步骤分析">3.4 创建自定义View的步骤分析</h4><p>这里以CirclePageIndicator为例</p>
<h5 id="3-4-1_继承自View，实现构造函数">3.4.1 继承自View，实现构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CirclePageIndicator extends View implements PageIndicator &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CirclePageIndicator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CirclePageIndicator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, R.attr.vpiCirclePageIndicatorStyle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CirclePageIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-2_定义属性">3.4.2 定义属性</h5><p>vpi_attrs.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"CirclePageIndicator"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Color of the filled circle that represents the current page. --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"fillColor"</span> <span class="attribute">format</span>=<span class="value">"color"</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Color of the filled circles that represents pages. --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"pageColor"</span> <span class="attribute">format</span>=<span class="value">"color"</span> /&gt;</span></span><br><span class="line">       ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="3-4-3_应用属性">3.4.3 应用属性</h5><p>在布局中应用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先指定命名空间，属性才可以使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--应用属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">com.viewpagerindicator.CirclePageIndicator</span></span><br><span class="line">        <span class="attribute">...</span></span><br><span class="line">        <span class="attribute">app:fillColor</span>=<span class="value">"#FF888888"</span></span><br><span class="line">        <span class="attribute">app:pageColor</span>=<span class="value">"#88FF0000"</span></span><br><span class="line">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在代码中加载布局中的属性值并应用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CirclePageIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//加载默认值</span></span><br><span class="line">       <span class="keyword">final</span> Resources res = getResources();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> defaultPageColor = res.getColor(R.color.default_circle_indicator_page_color);</span><br><span class="line">       <span class="comment">//获取并应用属性值</span></span><br><span class="line">       TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CirclePageIndicator, defStyle, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">//应用属性值</span></span><br><span class="line">       mPaintPageFill.setColor(a.getColor(R.styleable.CirclePageIndicator_pageColor, defaultPageColor));</span><br><span class="line">       ...</span><br><span class="line">       a.recycle();<span class="comment">//记得及时释放资源</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-4-4_自定义View的绘制">3.4.4 自定义View的绘制</h5><p>请参考上面的CirclePageIndicator的onDraw，也可以参考tech下的<a href="https://github.com/android-cn/android-open-project-analysis/blob/master/tech/viewdrawflow.md" target="_blank" rel="external">View的绘制流程</a>的Draw部分。</p>
<h5 id="3-4-5_使View可交互">3.4.5 使View可交互</h5><p>请参考上面的CirclePageIndicator的onTouch ，这里只是简单的处理了onTouch事件，交互更好的自定义控件往往会加一些自然的动画等。</p>
<h2 id="4-_杂谈">4. 杂谈</h2><p>大多数的App中的导航都类似，ViewPagerIndicator能够满足你开发的基本需求，如果不能满足，你可以在源码的基础上进行一些简单的改造。其中有一点是很多朋友提出的就是LineIndicator没有实现TextView颜色状态的联动。这个有已经实现的开源库:<a href="https://github.com/jpardogo/PagerSlidingTabStrip" target="_blank" rel="external">PagerSlidingTabStrip</a>，你可以作为参考。<br>对于什么时候需要自定义控件以及如何更好的进行自定义控件的定制，你可以参考这篇文章<a href="http://greenrobot.me/devpost/android-custom-layout" target="_blank" rel="external">深入解析Android的自定义布局</a> 相信会有一些启发。<br>整片文章看下来，确实比较多，也是花了一部分时间写的，其实之前是自己整理了一些相关知识，这次一下全部跟大家分享了。整篇文章都在讲View的绘制机制，三个过程也都很详细的通过源码分析介绍了。如果你对View的绘制机制还不清楚，而且希望将来往更高级的方向发展，这一步一定会经历的，那么请你耐心看完，你可以分多次研读，过程中出现问题或者原文分析不到位的地方，欢迎PR。<br>当你掌握了这些基本的知识，你可以去研究GitHub上的一部分开源项目了（因为Touch事件这里介绍的不多，而很多项目和Touch事件相关）。</p>
<p><strong>参考文献</strong><br><a href="http://developer.android.com/training/gestures/index.html" target="_blank" rel="external">http://developer.android.com/training/gestures/index.html</a><br><a href="http://developer.android.com/training/custom-views/create-view.html" target="_blank" rel="external">http://developer.android.com/training/custom-views/create-view.html</a><br><a href="https://github.com/kesenhoo/android-training-course-in-chinese" target="_blank" rel="external">Google Android官方培训课程中文版</a>  </p>
<p>View的绘制：<br><a href="http://blog.csdn.net/wangjinyu501/article/details/9008271" target="_blank" rel="external">http://blog.csdn.net/wangjinyu501/article/details/9008271</a><br><a href="http://blog.csdn.net/qinjuning/article/details/7110211" target="_blank" rel="external">http://blog.csdn.net/qinjuning/article/details/7110211</a><br><a href="http://blog.csdn.net/qinjuning/article/details/8074262" target="_blank" rel="external">http://blog.csdn.net/qinjuning/article/details/8074262</a></p>
<p><strong>相关资源</strong><br><a href="https://www.youtube.com/watch?v=NYtB6mlu7vA#t=228" target="_blank" rel="external">Google I/O 2013 - Writing Custom Views for Android</a>  </p>
<p><a href="http://www.rapidvaluesolutions.com/tech_blog/best-practices-for-android-user-interface/" target="_blank" rel="external">best-practices-for-android-user-interface</a><br><a href="http://greenrobot.me/devpost/android-custom-layout/" target="_blank" rel="external">深入解析Android的自定义布局</a><br><a href="http://www.imooc.com/learn/237" target="_blank" rel="external">慕课网自定义FlowLayout课程</a>  </p>
<p>Touch事件传递<br><a href="http://blog.csdn.net/xiaanming/article/details/21696315" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/21696315</a><br><a href="http://blog.csdn.net/wangjinyu501/article/details/22584465" target="_blank" rel="external">http://blog.csdn.net/wangjinyu501/article/details/22584465</a>    </p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 ViewPagerindicator 部分<br>项目地址：<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/" target="_blank" rel="external">ViewPagerIndicator</a>，分析的版本：<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/commit/8cd549f23f3d20ff920e19a2345c54983f65e26b" title="Commit id is 8cd549f23f3d20ff920e19a2345c54983f65e26b" target="_blank" rel="external">8cd549f</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/viewpager-indicator-demo" target="_blank" rel="external">ViewPagerIndicator Demo</a><br>分析者：<a href="https://github.com/lightSky" target="_blank" rel="external">lightSky</a>，校对者：<a href="https://github.com/AaronPlay" target="_blank" rel="external">aaronplay</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h3 id="1-1_ViewPagerIndicator">1.1 ViewPagerIndicator</h3><p>ViewPagerIndicator用于各种基于AndroidSupportLibrary中ViewPager的界面导航。主要特点：使用简单、样式全、易扩展。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之Universal Image Loader 源码分析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_universal-image-loader/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_universal-image-loader/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_Android_Universal_Image_Loader">1.1 Android Universal Image Loader</h4><p>Android Universal Image Loader 是一个强大的、可高度定制的图片缓存，本文简称为<code>UIL</code>。<br>简单的说 UIL 就做了一件事——获取图片并显示在相应的控件上。<br><a id="more"></a></p>
<h4 id="1-2_基本使用">1.2 基本使用</h4><h5 id="1-2-1_初始化">1.2.1 初始化</h5><p>添加完依赖后在<code>Application</code>或<code>Activity</code>中初始化<code>ImageLoader</code>，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">super</span>.onCreate();</span><br><span class="line">	    ImageLoaderConfiguration configuration = <span class="keyword">new</span> ImageLoaderConfiguration.Builder(<span class="keyword">this</span>)</span><br><span class="line">	        <span class="comment">// 添加你的配置需求</span></span><br><span class="line">	        .build();</span><br><span class="line">	    ImageLoader.getInstance().init(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 configuration 表示<code>ImageLoader</code>的配置信息，可包括图片最大尺寸、线程池、缓存、下载器、解码器等等。  </p>
<h5 id="1-2-2_Manifest_配置">1.2.2 Manifest 配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">".YourApplication"</span></span><br><span class="line">        …… &gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加网络权限。如果允许磁盘缓存，需要添加写外设的权限。  </p>
<h5 id="1-2-3_下载显示图片">1.2.3 下载显示图片</h5><p>下载图片，解析为 Bitmap 并在 ImageView 中显示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageLoader.displayImage(imageUri, imageView);</span><br></pre></td></tr></table></figure></p>
<p>下载图片，解析为 Bitmap 传递给回调接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">imageLoader.loadImage(imageUri, <span class="keyword">new</span> SimpleImageLoadingListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingComplete</span><span class="params">(String imageUri, View view, Bitmap loadedImage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 图片处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上是简单使用，更复杂 API 见本文<code>详细设计</code>。  </p>
<h4 id="1-3_特点">1.3 特点</h4><ul>
<li>可配置度高。支持任务线程池、下载器、解码器、内存及磁盘缓存、显示选项等等的配置。  </li>
<li>包含内存缓存和磁盘缓存两级缓存。  </li>
<li>支持多线程，支持异步和同步加载。  </li>
<li>支持多种缓存算法、下载进度监听、ListView 图片错乱解决等。 </li>
</ul>
<h3 id="2-_总体设计">2. 总体设计</h3><h4 id="2-1-_总体设计图">2.1. 总体设计图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/overall-design.png" alt="总体设计图"><br>上面是 UIL 的总体设计图。整个库分为<code>ImageLoaderEngine</code>，<code>Cache</code>及<code>ImageDownloader</code>，<code>ImageDecoder</code>，<code>BitmapDisplayer</code>，<code>BitmapProcessor</code>五大模块，其中<code>Cache</code>分为<code>MemoryCache</code>和<code>DiskCache</code>两部分。  </p>
<p>简单的讲就是<code>ImageLoader</code>收到加载及显示图片的任务，并将它交给<code>ImageLoaderEngine</code>，<code>ImageLoaderEngine</code>分发任务到具体线程池去执行，任务通过<code>Cache</code>及<code>ImageDownloader</code>获取图片，中间可能经过<code>BitmapProcessor</code>和<code>ImageDecoder</code>处理，最终转换为<code>Bitmap</code>交给<code>BitmapDisplayer</code>在<code>ImageAware</code>中显示。  </p>
<h4 id="2-2-_UIL_中的概念">2.2. UIL 中的概念</h4><p>简单介绍一些概念，在<code>4. 详细设计</code>中会仔细介绍。<br><strong>ImageLoaderEngine：</strong>任务分发器，负责分发<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>给具体的线程池去执行，本文中也称其为<code>engine</code>，具体参考<code>4.2.6 ImageLoaderEngine.java</code>。  </p>
<p><strong>ImageAware：</strong>显示图片的对象，可以是<code>ImageView</code>等，具体参考<code>4.2.9 ImageAware.java</code>。  </p>
<p><strong>ImageDownloader：</strong>图片下载器，负责从图片的各个来源获取输入流, 具体参考<code>4.2.22 ImageDownloader.java</code>。  </p>
<p><strong>Cache：</strong>图片缓存，分为<code>MemoryCache</code>和<code>DiskCache</code>两部分。  </p>
<p><strong>MemoryCache：</strong>内存图片缓存，可向内存缓存缓存图片或从内存缓存读取图片，具体参考<code>4.2.24 MemoryCache.java</code>。  </p>
<p><strong>DiskCache：</strong>本地图片缓存，可向本地磁盘缓存保存图片或从本地磁盘读取图片，具体参考<code>4.2.38 DiskCache.java</code>。  </p>
<p><strong>ImageDecoder：</strong>图片解码器，负责将图片输入流<code>InputStream</code>转换为<code>Bitmap</code>对象, 具体参考<code>4.2.53 ImageDecoder.java</code>。 </p>
<p><strong>BitmapProcessor：</strong>图片处理器，负责从缓存读取或写入前对图片进行处理。具体参考<code>4.2.61 BitmapProcessor.java</code>。  </p>
<p><strong>BitmapDisplayer：</strong>将<code>Bitmap</code>对象显示在相应的控件<code>ImageAware</code>上, 具体参考<code>4.2.56 BitmapDisplayer.java</code>。  </p>
<p><strong>LoadAndDisplayImageTask：</strong>用于加载并显示图片的任务, 具体参考<code>4.2.20 LoadAndDisplayImageTask.java</code>。  </p>
<p><strong>ProcessAndDisplayImageTask：</strong>用于处理并显示图片的任务, 具体参考<code>4.2.19 ProcessAndDisplayImageTask.java</code>。  </p>
<p><strong>DisplayBitmapTask：</strong>用于显示图片的任务, 具体参考<code>4.2.18 DisplayBitmapTask.java</code>。  </p>
<h3 id="3-_流程图">3. 流程图</h3><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/uil-flow.png" alt=""><br>上图为图片加载及显示流程图，在uil库中给出，这里用中文重新画出。  </p>
<h3 id="4-_详细设计">4. 详细设计</h3><h4 id="4-1_类关系图">4.1 类关系图</h4><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/relation-class.png" alt="">  </p>
<h4 id="4-2_核心类功能介绍">4.2 核心类功能介绍</h4><h5 id="4-2-1_ImageLoader-java">4.2.1 ImageLoader.java</h5><p>图片加载器，对外的主要 API，采取了单例模式，用于图片的加载和显示。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)-_getInstance()">(1). getInstance()</h5><p>得到<code>ImageLoader</code>的单例。通过双层是否为 null 判断提高性能。  </p>
<h5 id="(2)-_init(ImageLoaderConfiguration_configuration)">(2). init(ImageLoaderConfiguration configuration)</h5><p>初始化配置参数，参数<code>configuration</code>为<code>ImageLoader</code>的配置信息，包括图片最大尺寸、任务线程池、磁盘缓存、下载器、解码器等等。<br>实现中会初始化<code>ImageLoaderEngine engine</code>属性，该属性为任务分发器。  </p>
<h5 id="(3)-_displayImage(String_uri,_ImageAware_imageAware,_DisplayImageOptions_options,_ImageLoadingListener_listener,_ImageLoadingProgressListener_progressListener)">(3). displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageLoadingListener listener, ImageLoadingProgressListener progressListener)</h5><p>加载并显示图片或加载并执行回调接口。<code>ImageLoader</code> 加载图片主要分为三类接口：  </p>
<ul>
<li><code>displayImage(…)</code> 表示异步加载并显示图片到对应的<code>ImageAware</code>上。  </li>
<li><code>loadImage(…)</code> 表示异步加载图片并执行回调接口。  </li>
<li><code>loadImageSync(…)</code> 表示同步加载图片。  </li>
</ul>
<p>以上三类接口最终都会调用到这个函数进行图片加载。函数参数解释如下：<br><strong>uri:</strong> 图片的 uri。uri 支持多种来源的图片，包括 http、https、file、content、assets、drawable 及自定义，具体介绍可见<code>ImageDownloader</code>。<br><strong>imageAware:</strong> 一个接口，表示需要加载图片的对象，可包装 View。<br><strong>options:</strong> 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。<br><strong>listener:</strong> 图片加载各种时刻的回调接口，包括开始加载、加载失败、加载成功、取消加载四个时刻的回调函数。<br><strong>progressListener:</strong> 图片加载进度的回调接口。  </p>
<p><strong>函数流程图如下：</strong><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/display-image-flow-chart.png" alt="ImageLoader Display Image Flow Chart">  </p>
<h5 id="4-2-2_ImageLoaderConfiguration-java">4.2.2 ImageLoaderConfiguration.java</h5><p><code>ImageLoader</code>的配置信息，包括图片最大尺寸、线程池、缓存、下载器、解码器等等。  </p>
<p><strong>主要属性：</strong>  </p>
<h5 id="(1)-_Resources_resources">(1). Resources resources</h5><p>程序本地资源访问器，用于加载<code>DisplayImageOptions</code>中设置的一些 App 中图片资源。  </p>
<h5 id="(2)-_int_maxImageWidthForMemoryCache">(2). int maxImageWidthForMemoryCache</h5><p>内存缓存的图片最大宽度。  </p>
<h5 id="(3)-_int_maxImageHeightForMemoryCache">(3). int maxImageHeightForMemoryCache</h5><p>内存缓存的图片最大高度。  </p>
<h5 id="(4)-_int_maxImageWidthForDiskCache">(4). int maxImageWidthForDiskCache</h5><p>磁盘缓存的图片最大宽度。  </p>
<h5 id="(5)-_int_maxImageHeightForDiskCache">(5). int maxImageHeightForDiskCache</h5><p>磁盘缓存的图片最大高度。  </p>
<h5 id="(6)-_BitmapProcessor_processorForDiskCache">(6). BitmapProcessor processorForDiskCache</h5><p>图片处理器，用于处理从磁盘缓存中读取到的图片。  </p>
<h5 id="(7)-_Executor_taskExecutor">(7). Executor taskExecutor</h5><p><code>ImageLoaderEngine</code>中用于执行从源获取图片任务的 Executor。  </p>
<h5 id="(18)-_Executor_taskExecutorForCachedImages">(18). Executor taskExecutorForCachedImages</h5><p><code>ImageLoaderEngine</code>中用于执行从缓存获取图片任务的 Executor。  </p>
<h5 id="(19)-_boolean_customExecutor">(19). boolean customExecutor</h5><p>用户是否自定义了上面的 taskExecutor。  </p>
<h5 id="(20)-_boolean_customExecutorForCachedImages">(20). boolean customExecutorForCachedImages</h5><p>用户是否自定义了上面的 taskExecutorForCachedImages。  </p>
<h5 id="(21)-_int_threadPoolSize">(21). int threadPoolSize</h5><p>上面两个默认线程池的核心池大小，即最大并发数。  </p>
<h5 id="(22)-_int_threadPriority">(22). int threadPriority</h5><p>上面两个默认线程池的线程优先级。  </p>
<h5 id="(23)-_QueueProcessingType_tasksProcessingType">(23). QueueProcessingType tasksProcessingType</h5><p>上面两个默认线程池的线程队列类型。目前只有 FIFO, LIFO 两种可供选择。  </p>
<h5 id="(24)-_MemoryCache_memoryCache">(24). MemoryCache memoryCache</h5><p>图片内存缓存。  </p>
<h5 id="(25)-_DiskCache_diskCache">(25). DiskCache diskCache</h5><p>图片磁盘缓存，一般放在 SD 卡。  </p>
<h5 id="(26)-_ImageDownloader_downloader">(26). ImageDownloader downloader</h5><p>图片下载器。  </p>
<h5 id="(27)-_ImageDecoder_decoder">(27). ImageDecoder decoder</h5><p>图片解码器，内部可使用我们常用的<code>BitmapFactory.decode(…)</code>将图片资源解码成<code>Bitmap</code>对象。  </p>
<h5 id="(28)-_DisplayImageOptions_defaultDisplayImageOptions">(28). DisplayImageOptions defaultDisplayImageOptions</h5><p>图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。  </p>
<h5 id="(29)-_ImageDownloader_networkDeniedDownloader">(29). ImageDownloader networkDeniedDownloader</h5><p>不允许访问网络的图片下载器。  </p>
<h5 id="(30)-_ImageDownloader_slowNetworkDownloader">(30). ImageDownloader slowNetworkDownloader</h5><p>慢网络情况下的图片下载器。  </p>
<h5 id="4-2-3_ImageLoaderConfiguration-Builder-java_静态内部类">4.2.3 ImageLoaderConfiguration.Builder.java 静态内部类</h5><p>Builder 模式，用于构造参数繁多的<code>ImageLoaderConfiguration</code>。<br>其属性与<code>ImageLoaderConfiguration</code>类似，函数多是属性设置函数。  </p>
<p><strong>主要函数及含义：</strong>  </p>
<h5 id="(1)-_build()">(1). build()</h5><p>按照配置，生成 ImageLoaderConfiguration。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ImageLoaderConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	initEmptyFieldsWithDefaultValues();</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ImageLoaderConfiguration(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="(2)-_initEmptyFieldsWithDefaultValues()">(2). initEmptyFieldsWithDefaultValues()</h5><p>初始化值为<code>null</code>的属性。若用户没有配置相关项，UIL 会通过调用<code>DefaultConfigurationFactory</code>中的函数返回一个默认值当配置。<br><code>taskExecutorForCachedImages</code>、<code>taskExecutor</code>及<code>ImageLoaderEngine</code>的<code>taskDistributor</code>的默认值如下：  </p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>taskDistributor</th>
<th>taskExecutorForCachedImages/taskExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>3</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>60</td>
<td>0</td>
</tr>
<tr>
<td>unit</td>
<td>SECONDS</td>
<td>MILLISECONDS</td>
</tr>
<tr>
<td>workQueue</td>
<td>SynchronousQueue</td>
<td>LIFOLinkedBlockingDeque / LinkedBlockingQueue</td>
</tr>
<tr>
<td>priority</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><code>diskCacheFileNameGenerator</code>默认值为<code>HashCodeFileNameGenerator</code>。<br><code>memoryCache</code>默认值为<code>LruMemoryCache</code>。如果内存缓存不允许缓存一张图片的多个尺寸，则用<code>FuzzyKeyMemoryCache</code>做封装，同一个图片新的尺寸会覆盖缓存中该图片老的尺寸。<br><code>diskCache</code>默认值与<code>diskCacheSize</code>和<code>diskCacheFileCount</code>值有关，如果他们有一个大于 0，则默认为<code>LruDiskCache</code>，否则使用无大小限制的<code>UnlimitedDiskCache</code>。<br><code>downloader</code>默认值为<code>BaseImageDownloader</code>。<br><code>decoder</code>默认值为<code>BaseImageDecoder</code>。<br>详细及其他属性默认值请到<code>DefaultConfigurationFactory</code>中查看。  </p>
<h5 id="(3)-_denyCacheImageMultipleSizesInMemory()">(3). denyCacheImageMultipleSizesInMemory()</h5><p>设置内存缓存不允许缓存一张图片的多个尺寸，默认允许。<br>后面会讲到 View 的 <code>getWidth()</code> 在初始化前后的不同值与这个设置的关系。  </p>
<h5 id="(4)-_diskCacheSize(int_maxCacheSize)">(4). diskCacheSize(int maxCacheSize)</h5><p>设置磁盘缓存的最大字节数，如果大于 0 或者下面的<code>maxFileCount</code>大于 0，默认的<code>DiskCache</code>会用<code>LruDiskCache</code>，否则使用无大小限制的<code>UnlimitedDiskCache</code>。  </p>
<h5 id="(5)-_diskCacheFileCount(int_maxFileCount)">(5). diskCacheFileCount(int maxFileCount)</h5><p>设置磁盘缓存文件夹下最大文件数，如果大于 0 或者上面的<code>maxCacheSize</code>大于 0，默认的<code>DiskCache</code>会用<code>LruDiskCache</code>，否则使用无大小限制的<code>UnlimitedDiskCache</code>。  </p>
<h5 id="4-2-4_ImageLoaderConfiguration-NetworkDeniedImageDownloader-java_静态内部类">4.2.4 ImageLoaderConfiguration.NetworkDeniedImageDownloader.java 静态内部类</h5><p>不允许访问网络的图片下载器，实现了<code>ImageDownloader</code>接口。<br>实现也比较简单，包装一个<code>ImageDownloader</code>对象，通过在 getStream(…) 函数中禁止 Http 和 Https Scheme 禁止网络访问，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HTTP:</span><br><span class="line">		<span class="keyword">case</span> HTTPS:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> wrappedDownloader.getStream(imageUri, extra);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4-2-5_ImageLoaderConfiguration-SlowNetworkImageDownloader-java_静态内部类">4.2.5 ImageLoaderConfiguration.SlowNetworkImageDownloader.java 静态内部类</h5><p>慢网络情况下的图片下载器，实现了<code>ImageDownloader</code>接口。<br>通过包装一个<code>ImageDownloader</code>对象实现，在 getStream(…) 函数中当 Scheme 为 Http 和 Https 时，用<code>FlushedInputStream</code>代替<code>InputStream</code>处理慢网络情况，具体见后面<code>FlushedInputStream</code>的介绍。  </p>
<h5 id="4-2-6_ImageLoaderEngine-java">4.2.6 ImageLoaderEngine.java</h5><p><code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>任务分发器，负责分发任务给具体的线程池。  </p>
<p><strong>主要属性：</strong>  </p>
<h5 id="(1)-_ImageLoaderConfiguration_configuration">(1). ImageLoaderConfiguration configuration</h5><p><code>ImageLoader</code>的配置信息，可包括图片最大尺寸、线程池、缓存、下载器、解码器等等。  </p>
<h5 id="(2)-_Executor_taskExecutor">(2). Executor taskExecutor</h5><p>用于执行从源获取图片任务的 Executor，为<code>configuration</code>中的 taskExecutor，如果为<code>null</code>，则会调用<code>DefaultConfigurationFactory.createExecutor(…)</code>根据配置返回一个默认的线程池。  </p>
<h5 id="(3)-_Executor_taskExecutorForCachedImages">(3). Executor taskExecutorForCachedImages</h5><p>用于执行从缓存获取图片任务的 Executor，为<code>configuration</code>中的 taskExecutorForCachedImages，如果为<code>null</code>，则会调用<code>DefaultConfigurationFactory.createExecutor(…)</code>根据配置返回一个默认的线程池。  </p>
<h5 id="(4)-_Executor_taskDistributor">(4). Executor taskDistributor</h5><p>任务分发线程池，任务指<code>LoadAndDisplayImageTask</code>和<code>ProcessAndDisplayImageTask</code>，因为只需要分发给上面的两个 Executor 去执行任务，不存在较耗时或阻塞操作，所以用无并发数(Int 最大值)限制的线程池即可。  </p>
<h5 id="(5)-_Map_cacheKeysForImageAwares">(5). Map<integer, string=""> cacheKeysForImageAwares</integer,></h5><p><code>ImageAware</code>与内存缓存 key 对应的 map，key 为<code>ImageAware</code>的 id，value 为内存缓存的 key。</p>
<h5 id="(6)-_Map_uriLocks">(6). Map<string, reentrantlock=""> uriLocks</string,></h5><p>图片正在加载的重入锁 map，key 为图片的 uri，value 为标识其正在加载的重入锁。  </p>
<h5 id="(7)-_AtomicBoolean_paused">(7). AtomicBoolean paused</h5><p>是否被暂停。如果为<code>true</code>，则所有新的加载或显示任务都会等待直到取消暂停(为<code>false</code>)。  </p>
<h5 id="(8)-_AtomicBoolean_networkDenied">(8). AtomicBoolean networkDenied</h5><p>是否不允许访问网络，如果为<code>true</code>，通过<code>ImageLoadingListener.onLoadingFailed(…)</code>获取图片，则所有不在缓存中需要网络访问的请求都会失败，返回失败原因为<code>网络访问被禁止</code>。  </p>
<h5 id="(9)-_AtomicBoolean_slowNetwork">(9). AtomicBoolean slowNetwork</h5><p>是否是慢网络情况，如果为<code>true</code>，则自动调用<code>SlowNetworkImageDownloader</code>下载图片。  </p>
<h5 id="(10)-_Object_pauseLock">(10). Object pauseLock</h5><p>暂停的等待锁，可在<code>engine</code>被暂停后调用这个锁等待。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)-_void_submit(final_LoadAndDisplayImageTask_task)">(1). void submit(final LoadAndDisplayImageTask task)</h5><p>添加一个<code>LoadAndDisplayImageTask</code>。直接用<code>taskDistributor</code>执行一个 Runnable，在 Runnable 内部根据图片是否被磁盘缓存过确定使用<code>taskExecutorForCachedImages</code>还是<code>taskExecutor</code>执行该 task。  </p>
<h5 id="(2)-_void_submit(ProcessAndDisplayImageTask_task)">(2). void submit(ProcessAndDisplayImageTask task)</h5><p>添加一个<code>ProcessAndDisplayImageTask</code>。直接用<code>taskExecutorForCachedImages</code>执行该 task。  </p>
<h5 id="(3)-_void_pause()">(3). void pause()</h5><p>暂停图片加载任务。所有新的加载或显示任务都会等待直到取消暂停(为<code>false</code>)。  </p>
<h5 id="(4)-_void_resume()">(4). void resume()</h5><p>继续图片加载任务。</p>
<h5 id="(5)-_stop()">(5). stop()</h5><p>暂停所有加载和显示图片任务并清除这里的内部属性值。  </p>
<h5 id="(6)-_fireCallback(Runnable_r)">(6). fireCallback(Runnable r)</h5><p><code>taskDistributor</code>立即执行某个任务。  </p>
<h5 id="(7)-_getLockForUri(String_uri)">(7). getLockForUri(String uri)</h5><p>得到某个 uri 的重入锁，如果不存在则新建。   </p>
<h5 id="(8)-_createTaskExecutor()">(8). createTaskExecutor()</h5><p>调用<code>DefaultConfigurationFactory.createExecutor(…)</code>创建一个线程池。  </p>
<h5 id="(9)-_getLoadingUriForView(ImageAware_imageAware)">(9). getLoadingUriForView(ImageAware imageAware)</h5><p>得到某个<code>imageAware</code>正在加载的图片 uri。  </p>
<h5 id="(10)-_prepareDisplayTaskFor(ImageAware_imageAware,_String_memoryCacheKey)">(10). prepareDisplayTaskFor(ImageAware imageAware, String memoryCacheKey)</h5><p>准备开始一个<code>Task</code>。向<code>cacheKeysForImageAwares</code>中插入<code>ImageAware</code>的 id 和图片在内存缓存中的 key。  </p>
<h5 id="(11)-_void_cancelDisplayTaskFor(ImageAware_imageAware)">(11). void cancelDisplayTaskFor(ImageAware imageAware)</h5><p>取消一个显示任务。从<code>cacheKeysForImageAwares</code>中删除<code>ImageAware</code>对应元素。  </p>
<h5 id="(12)-_denyNetworkDownloads(boolean_denyNetworkDownloads)">(12). denyNetworkDownloads(boolean denyNetworkDownloads)</h5><p>设置是否不允许网络访问。  </p>
<h5 id="(13)-_handleSlowNetwork(boolean_handleSlowNetwork)">(13). handleSlowNetwork(boolean handleSlowNetwork)</h5><p>设置是否慢网络情况。  </p>
<h5 id="4-2-7_DefaultConfigurationFactory-java">4.2.7 DefaultConfigurationFactory.java</h5><p>为<code>ImageLoaderConfiguration</code>及<code>ImageLoaderEngine</code>提供一些默认配置。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)-_createExecutor(int_threadPoolSize,_int_threadPriority,_QueueProcessingType_tasksProcessingType)">(1). createExecutor(int threadPoolSize, int threadPriority, QueueProcessingType tasksProcessingType)</h5><p>创建线程池。<br><code>threadPoolSize</code>表示核心池大小(最大并发数)。<br><code>threadPriority</code>表示线程优先级。<br><code>tasksProcessingType</code>表示线程队列类型，目前只有 FIFO, LIFO 两种可供选择。<br>内部实现会调用<code>createThreadFactory(…)</code>返回一个支持线程优先级设置，并且以固定规则命名新建的线程的线程工厂类<code>DefaultConfigurationFactory.DefaultThreadFactory</code>。  </p>
<h5 id="(2)-_createTaskDistributor()">(2). createTaskDistributor()</h5><p>为<code>ImageLoaderEngine</code>中的任务分发器<code>taskDistributor</code>提供线程池，该线程池为 normal 优先级的无并发大小限制的线程池。  </p>
<h5 id="(3)-_createFileNameGenerator()">(3). createFileNameGenerator()</h5><p>返回一个<code>HashCodeFileNameGenerator</code>对象，即以 uri HashCode 为文件名的文件名生成器。  </p>
<h5 id="(4)-_createDiskCache(Context_context,_FileNameGenerator_diskCacheFileNameGenerator,_long_diskCacheSize,_int_diskCacheFileCount)">(4). createDiskCache(Context context, FileNameGenerator diskCacheFileNameGenerator, long diskCacheSize, int diskCacheFileCount)</h5><p>创建一个 Disk Cache。如果 diskCacheSize 或者 diskCacheFileCount 大于 0，返回一个<code>LruDiskCache</code>，否则返回无大小限制的<code>UnlimitedDiskCache</code>。  </p>
<h5 id="(5)-_createMemoryCache(Context_context,_int_memoryCacheSize)">(5). createMemoryCache(Context context, int memoryCacheSize)</h5><p>创建一个 Memory Cache。返回一个<code>LruMemoryCache</code>，若 memoryCacheSize 为 0，则设置该内存缓存的最大字节数为 App 最大可用内存的 1/8。<br>这里 App 的最大可用内存也支持系统在 Honeycomb之后(ApiLevel &gt;= 11) application 中<code>android:largeHeap=&quot;true&quot;</code>的设置。  </p>
<h5 id="(6)-_createImageDownloader(Context_context)">(6). createImageDownloader(Context context)</h5><p>创建图片下载器，返回一个<code>BaseImageDownloader</code>。  </p>
<h5 id="(7)-_createImageDecoder(boolean_loggingEnabled)">(7). createImageDecoder(boolean loggingEnabled)</h5><p>创建图片解码器，返回一个<code>BaseImageDecoder</code>。  </p>
<h5 id="(8)-_createBitmapDisplayer()">(8). createBitmapDisplayer()</h5><p>创建图片显示器，返回一个<code>SimpleBitmapDisplayer</code>。  </p>
<h5 id="4-2-8_DefaultConfigurationFactory-DefaultThreadFactory">4.2.8 DefaultConfigurationFactory.DefaultThreadFactory</h5><p>默认的线程工厂类，为<br><code>DefaultConfigurationFactory.createExecutor(…)</code><br>和<br><code>DefaultConfigurationFactory.createTaskDistributor(…)</code><br>提供线程工厂。支持线程优先级设置，并且以固定规则命名新建的线程。  </p>
<p>PS：重命名线程是个很好的习惯，它的一大作用就是方便问题排查，比如性能优化，用 TraceView 查看线程，根据名字很容易分辨各个线程。  </p>
<h5 id="4-2-9_ImageAware-java">4.2.9 ImageAware.java</h5><p>需要显示图片的对象的接口，可包装 View 表示某个需要显示图片的 View。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)-_View_getWrappedView()">(1). View getWrappedView()</h5><p>得到被包装的 View，图片在该 View 上显示。  </p>
<h5 id="(2)-_getWidth()_与_getHeight()">(2). getWidth() 与 getHeight()</h5><p>得到宽度高度，在计算图片缩放比例时会用到。  </p>
<h5 id="(3)-_getId()">(3). getId()</h5><p>得到唯一标识 id。<code>ImageLoaderEngine</code>中用这个 id 标识正在加载图片的<code>ImageAware</code>和图片内存缓存 key 的对应关系，图片请求前会将内存缓存 key 与新的内存缓存 key 进行比较，如果不相等，则之前的图片请求会被取消。这样当<code>ImageAware</code>被复用时就不会因异步加载(前面任务未取消)而造成错乱了。 </p>
<h5 id="4-2-10_ViewAware-java">4.2.10 ViewAware.java</h5><p>封装 Android View 来显示图片的抽象类，实现了<code>ImageAware</code>接口，利用<code>Reference</code>来 Warp View 防止内存泄露。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)-_ViewAware(View_view,_boolean_checkActualViewSize)">(1). ViewAware(View view, boolean checkActualViewSize)</h5><p>构造函数。<br><code>view</code>表示需要显示图片的对象。<br><code>checkActualViewSize</code>表示通过<code>getWidth()</code>和<code>getHeight()</code>获取图片宽高时返回真实的宽和高，还是<code>LayoutParams</code>的宽高，true 表示返回真实宽和高。<br>如果为<code>true</code>会导致一个问题，<code>View</code>在还没有初始化完成时加载图片，这时它的真实宽高为0，会取它<code>LayoutParams</code>的宽高，而图片缓存的 key 与这个宽高有关，所以当<code>View</code>初始化完成再次需要加载该图片时，<code>getWidth()</code>和<code>getHeight()</code>返回的宽高都已经变化，缓存 key 不一样，从而导致缓存命中失败会再次从网络下载一次图片。可通过<code>ImageLoaderConfiguration.Builder.denyCacheImageMultipleSizesInMemory()</code>设置不允许内存缓存缓存一张图片的多个尺寸。  </p>
<h5 id="(2)-_setImageDrawable(Drawable_drawable)">(2). setImageDrawable(Drawable drawable)</h5><p>如果当前操作在主线程并且 View 没有被回收，则调用抽象函数<code>setImageDrawableInto(Drawable drawable, View view)</code>去向<code>View</code>设置图片。  </p>
<h5 id="(3)-_setImageBitmap(Bitmap_bitmap)">(3). setImageBitmap(Bitmap bitmap)</h5><p>如果当前操作在主线程并且 View 没有被回收，则调用抽象函数<code>setImageBitmapInto(Bitmap bitmap, View view)</code>去向<code>View</code>设置图片。  </p>
<h5 id="4-2-11_ImageViewAware-java">4.2.11 ImageViewAware.java</h5><p>封装 Android ImageView 来显示图片的<code>ImageAware</code>，继承了<code>ViewAware</code>，利用<code>Reference</code>来 Warp View 防止内存泄露。<br>如果<code>getWidth()</code>函数小于等于0，会利用反射获取<code>mMaxWidth</code>的值作为宽。<br>如果<code>getHeight()</code>函数小于等于0，会利用反射获取<code>mMaxHeight</code>的值作为高。  </p>
<h5 id="4-2-12_NonViewAware-java">4.2.12 NonViewAware.java</h5><p>仅包含处理图片相关信息却没有需要显示图片的 View 的<code>ImageAware</code>，实现了<code>ImageAware</code>接口。常用于加载图片后调用回调接口而不是显示的情况。  </p>
<h5 id="4-2-13_DisplayImageOptions-java">4.2.13 DisplayImageOptions.java</h5><p>图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在 memory 缓存等。  </p>
<p><strong>主要属性及含义：</strong>  </p>
<h5 id="(1)-_int_imageResOnLoading">(1). int imageResOnLoading</h5><p>图片正在加载中的占位图片的 resource id，优先级比下面的<code>imageOnLoading</code>高，当存在时，<code>imageOnLoading</code>不起作用。  </p>
<h5 id="(2)-_int_imageResForEmptyUri">(2). int imageResForEmptyUri</h5><p>空 uri 时的占位图片的 resource id，优先级比下面的<code>imageForEmptyUri</code>高，当存在时，<code>imageForEmptyUri</code>不起作用。  </p>
<h5 id="(3)-_int_imageResOnFail">(3). int imageResOnFail</h5><p>加载失败时的占位图片的 resource id，优先级比下面的<code>imageOnFail</code>高，当存在时，<code>imageOnFail</code>不起作用。  </p>
<h5 id="(4)-_Drawable_imageOnLoading">(4). Drawable imageOnLoading</h5><p>加载中的占位图片的 drawabled 对象，默认为 null。  </p>
<h5 id="(5)-_Drawable_imageForEmptyUri">(5). Drawable imageForEmptyUri</h5><p>空 uri 时的占位图片的 drawabled 对象，默认为 null。  </p>
<h5 id="(6)-_Drawable_imageOnFail">(6). Drawable imageOnFail</h5><p>加载失败时的占位图片的 drawabled 对象，默认为 null。  </p>
<h5 id="(7)-_boolean_resetViewBeforeLoading">(7). boolean resetViewBeforeLoading</h5><p>在加载前是否重置 view，通过 Builder 构建的对象默认为 false。  </p>
<h5 id="(8)-_boolean_cacheInMemory">(8). boolean cacheInMemory</h5><p>是否缓存在内存中，通过 Builder 构建的对象默认为 false。  </p>
<h5 id="(9)-_boolean_cacheOnDisk">(9). boolean cacheOnDisk</h5><p>是否缓存在磁盘中，通过 Builder 构建的对象默认为 false。  </p>
<h5 id="(10)-_ImageScaleType_imageScaleType">(10). ImageScaleType imageScaleType</h5><p>图片的缩放类型，通过 Builder 构建的对象默认为<code>IN_SAMPLE_POWER_OF_2</code>。  </p>
<h5 id="(11)-_Options_decodingOptions;">(11). Options decodingOptions;</h5><p>为 BitmapFactory.Options，用于<code>BitmapFactory.decodeStream(imageStream, null, decodingOptions)</code>得到图片尺寸等信息。  </p>
<h5 id="(12)-_int_delayBeforeLoading">(12). int delayBeforeLoading</h5><p>设置在开始加载前的延迟时间，单位为毫秒，通过 Builder 构建的对象默认为 0。  </p>
<h5 id="(13)-_boolean_considerExifParams">(13). boolean considerExifParams</h5><p>是否考虑图片的 EXIF 信息，通过 Builder 构建的对象默认为 false。  </p>
<h5 id="(14)-_Object_extraForDownloader">(14). Object extraForDownloader</h5><p>下载器需要的辅助信息。下载时传入<code>ImageDownloader.getStream(String, Object)</code>的对象，方便用户自己扩展，默认为 null。  </p>
<h5 id="(15)-_BitmapProcessor_preProcessor">(15). BitmapProcessor preProcessor</h5><p>缓存在内存之前的处理程序，默认为 null。  </p>
<h5 id="(16)-_BitmapProcessor_postProcessor">(16). BitmapProcessor postProcessor</h5><p>缓存在内存之后的处理程序，默认为 null。  </p>
<h5 id="(17)-_BitmapDisplayer_displayer">(17). BitmapDisplayer displayer</h5><p>图片的显示方式，通过 Builder 构建的对象默认为<code>SimpleBitmapDisplayer</code>。  </p>
<h5 id="(18)-_Handler_handler">(18). Handler handler</h5><p>handler 对象，默认为 null。  </p>
<h5 id="(19)-_boolean_isSyncLoading">(19). boolean isSyncLoading</h5><p>是否同步加载，通过 Builder 构建的对象默认为 false。  </p>
<h5 id="4-2-14_DisplayImageOptions-Builder-java_静态内部类">4.2.14 DisplayImageOptions.Builder.java 静态内部类</h5><p>Builder 模式，用于构造参数繁多的<code>DisplayImageOptions</code>。<br>其属性与<code>DisplayImageOptions</code>类似，函数多是属性设置函数。  </p>
<h5 id="4-2-15_ImageLoadingListener-java">4.2.15 ImageLoadingListener.java</h5><p>图片加载各种时刻的回调接口，可在图片加载的某些点做监听。<br>包括开始加载(onLoadingStarted)、加载失败(onLoadingFailed)、加载成功(onLoadingComplete)、取消加载(onLoadingCancelled)四个回调函数。  </p>
<h5 id="4-2-16_SimpleImageLoadingListener-java">4.2.16 SimpleImageLoadingListener.java</h5><p>实现<code>ImageLoadingListener</code>接口，不过各个函数都是空实现，表示不在 Image 加载过程中做任何回调监听。<br><code>ImageLoader.displayImage(…)</code>函数中当入参<code>listener</code>为空时的默认值。  </p>
<h5 id="4-2-17_ImageLoadingProgressListener-java">4.2.17 ImageLoadingProgressListener.java</h5><p>Image 加载进度的回调接口。其中抽象函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(String imageUri, View view, <span class="keyword">int</span> current, <span class="keyword">int</span> total)</span></span></span><br></pre></td></tr></table></figure></p>
<p>会在获取图片存储到文件系统时被回调。其中<code>total</code>表示图片总大小，为网络请求结果<code>Response Header</code>中<code>content-length</code>字段，如果不存在则为 -1。  </p>
<h5 id="4-2-18_DisplayBitmapTask-java">4.2.18 DisplayBitmapTask.java</h5><p>显示图片的<code>Task</code>，实现了<code>Runnable</code>接口，必须在主线程调用。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)_run()">(1) run()</h5><p>首先判断<code>imageAware</code>是否被 GC 回收，如果是直接调用取消加载回调接口<code>ImageLoadingListener.onLoadingCancelled(…)</code>；<br>否则判断<code>imageAware</code>是否被复用，如果是直接调用取消加载回调接口<code>ImageLoadingListener.onLoadingCancelled(…)</code>；<br>否则调用<code>displayer</code>显示图片，并将<code>imageAware</code>从正在加载的 map 中移除。调用加载成功回调接口<code>ImageLoadingListener.onLoadingComplete(…)</code>。  </p>
<p>对于 ListView 或是 GridView 这类会缓存 Item 的 View 来说，单个 Item 中如果含有 ImageView，在滑动过程中可能因为异步加载及 View 复用导致图片错乱，这里对<code>imageAware</code>是否被复用的判断就能很好的解决这个问题。原因类似：<a href="http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/" target="_blank" rel="external">Android ListView 滑动过程中图片显示重复错位闪烁问题原因及解决方案</a>。  </p>
<h5 id="4-2-19_ProcessAndDisplayImageTask-java">4.2.19 ProcessAndDisplayImageTask.java</h5><p>处理并显示图片的<code>Task</code>，实现了<code>Runnable</code>接口。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)_run()-1">(1) run()</h5><p>主要通过 imageLoadingInfo 得到<code>BitmapProcessor</code>处理图片，并用处理后的图片和配置新建一个<code>DisplayBitmapTask</code>在<code>ImageAware</code>中显示图片。  </p>
<h5 id="4-2-20_LoadAndDisplayImageTask-java">4.2.20 LoadAndDisplayImageTask.java</h5><p>加载并显示图片的<code>Task</code>，实现了<code>Runnable</code>接口，用于从网络、文件系统或内存获取图片并解析，然后调用<code>DisplayBitmapTask</code>在<code>ImageAware</code>中显示图片。  </p>
<p><strong>主要函数：</strong>  </p>
<h5 id="(1)_run()-2">(1) run()</h5><p>获取图片并显示，核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bmp = configuration.memoryCache.get(memoryCacheKey);</span><br><span class="line"><span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</span><br><span class="line">	bmp = tryLoadBitmap();</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</span><br><span class="line">		L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</span><br><span class="line">		configuration.memoryCache.put(memoryCacheKey, bmp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</span><br><span class="line">runTask(displayBitmapTask, syncLoading, handler, engine);</span><br></pre></td></tr></table></figure></p>
<p>从上面代码段中可以看到先是从内存缓存中去读取 bitmap 对象，若 bitmap 对象不存在，则调用 tryLoadBitmap() 函数获取 bitmap 对象，获取成功后若在 DisplayImageOptions.Builder 中设置了 cacheInMemory(true), 同时将 bitmap 对象缓存到内存中。<br>最后新建<code>DisplayBitmapTask</code>显示图片。  </p>
<p><strong>函数流程图如下：</strong><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/load-display-flow-chart.png" alt="Load and Display Image Task Flow Chart">  </p>
<ol>
<li>判断图片的内存缓存是否存在，若存在直接执行步骤 8；  </li>
<li>判断图片的磁盘缓存是否存在，若存在直接执行步骤 5；  </li>
<li>从网络上下载图片；  </li>
<li>将图片缓存在磁盘上；  </li>
<li>将图片 decode 成 bitmap 对象；  </li>
<li>根据<code>DisplayImageOptions</code>配置对图片进行预处理(Pre-process Bitmap)；  </li>
<li>将 bitmap 对象缓存到内存中；  </li>
<li>根据<code>DisplayImageOptions</code>配置对图片进行后处理(Post-process Bitmap)；  </li>
<li>执行<code>DisplayBitmapTask</code>将图片显示在相应的控件上。<br>流程图可以参见<code>3. 流程图</code>。  </li>
</ol>
<h5 id="(2)_tryLoadBitmap()">(2) tryLoadBitmap()</h5><p>从磁盘缓存或网络获取图片，核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">File imageFile = configuration.diskCache.get(uri);</span><br><span class="line"><span class="keyword">if</span> (imageFile != <span class="keyword">null</span> &amp;&amp; imageFile.exists()) &#123;</span><br><span class="line">	...</span><br><span class="line">	bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bitmap == <span class="keyword">null</span> || bitmap.getWidth() &lt;= <span class="number">0</span> || bitmap.getHeight() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	String imageUriForDecoding = uri;</span><br><span class="line">	<span class="keyword">if</span> (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</span><br><span class="line">		imageFile = configuration.diskCache.get(uri);</span><br><span class="line">		<span class="keyword">if</span> (imageFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">			imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	checkTaskNotActual();</span><br><span class="line">	bitmap = decodeImage(imageUriForDecoding);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先根据 uri 看看磁盘中是不是已经缓存了这个文件，如果已经缓存，调用 decodeImage 函数，将图片文件 decode 成 bitmap 对象；<br>如果 bitmap 不合法或缓存文件不存在，判断是否需要缓存在磁盘，需要则调用<code>tryCacheImageOnDisk()</code>函数去下载并缓存图片到本地磁盘，再通过<code>decodeImage(imageUri)</code>函数将图片文件decode成bitmap对象，否则直接通过<code>decodeImage(imageUriForDecoding)</code>下载图片并解析。  </p>
<h5 id="(3)_tryCacheImageOnDisk()">(3) tryCacheImageOnDisk()</h5><p>下载图片并存储在磁盘内，根据磁盘缓存图片最长宽高的配置处理图片。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaded = downloadImage();</span><br></pre></td></tr></table></figure></p>
<p>主要就是这一句话，调用下载器下载并保存图片。<br>如果你在<code>ImageLoaderConfiguration</code>中还配置了<code>maxImageWidthForDiskCache</code>或者<code>maxImageHeightForDiskCache</code>，还会调用<code>resizeAndSaveImage()</code>函数，调整图片尺寸，并保存新的图片文件。  </p>
<h5 id="(4)_downloadImage()">(4) downloadImage()</h5><p>下载图片并存储在磁盘内。调用<code>getDownloader()</code>得到<code>ImageDownloader</code>去下载图片。  </p>
<h5 id="(4)_resizeAndSaveImage(int_maxWidth,_int_maxHeight)">(4) resizeAndSaveImage(int maxWidth, int maxHeight)</h5><p>从磁盘缓存中得到图片，重新设置大小及进行一些处理后保存。  </p>
<h5 id="(5)_getDownloader()">(5) getDownloader()</h5><p>根据<code>ImageLoaderEngine</code>配置得到下载器。<br>如果不允许访问网络，则使用不允许访问网络的图片下载器<code>NetworkDeniedImageDownloader</code>；如果是慢网络情况，则使用慢网络情况下的图片下载器<code>SlowNetworkImageDownloader</code>；否则直接使用<code>ImageLoaderConfiguration</code>中的<code>downloader</code>。  </p>
<h5 id="4-2-21_ImageLoadingInfo-java">4.2.21 ImageLoadingInfo.java</h5><p>加载和显示图片任务需要的信息。<br><code>String uri</code> 图片 url。<br><code>String memoryCacheKey</code> 图片缓存 key。<br><code>ImageAware imageAware</code> 需要加载图片的对象。<br><code>ImageSize targetSize</code> 图片的显示尺寸。<br><code>DisplayImageOptions options</code> 图片显示的配置项。<br><code>ImageLoadingListener listener</code> 图片加载各种时刻的回调接口。<br><code>ImageLoadingProgressListener progressListener</code> 图片加载进度的回调接口。<br><code>ReentrantLock loadFromUriLock</code> 图片加载中的重入锁。  </p>
<h5 id="4-2-22_ImageDownloader-java">4.2.22 ImageDownloader.java</h5><p>图片下载接口。待实现函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getStream(String imageUri, Object extra)</span><br></pre></td></tr></table></figure></p>
<p>表示通过 uri 得到 InputStream。<br>通过内部定义的枚举<code>Scheme</code>, 可以看出 UIL 支持哪些图片来源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP(<span class="string">"http"</span>), HTTPS(<span class="string">"https"</span>), FILE(<span class="string">"file"</span>), CONTENT(<span class="string">"content"</span>), ASSETS(<span class="string">"assets"</span>), DRAWABLE(<span class="string">"drawable"</span>), UNKNOWN(<span class="string">""</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="4-2-23_BaseImageDownloader-java">4.2.23 BaseImageDownloader.java</h5><p><code>ImageDownloader</code>的具体实现类。得到上面各种<code>Scheme</code>对应的图片 InputStream。  </p>
<p><strong>主要函数</strong>  </p>
<h5 id="(1)-_getStream(String_imageUri,_Object_extra)">(1). getStream(String imageUri, Object extra)</h5><p>在<code>getStream(…)</code>函数内根据不同<code>Scheme</code>类型获取图片输入流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HTTP:</span><br><span class="line">		<span class="keyword">case</span> HTTPS:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromNetwork(imageUri, extra);</span><br><span class="line">		<span class="keyword">case</span> FILE:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromFile(imageUri, extra);</span><br><span class="line">		<span class="keyword">case</span> CONTENT:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromContent(imageUri, extra);</span><br><span class="line">		<span class="keyword">case</span> ASSETS:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromAssets(imageUri, extra);</span><br><span class="line">		<span class="keyword">case</span> DRAWABLE:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromDrawable(imageUri, extra);</span><br><span class="line">		<span class="keyword">case</span> UNKNOWN:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> getStreamFromOtherSource(imageUri, extra);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体见下面各函数介绍。  </p>
<h5 id="(2)-_getStreamFromNetwork(String_imageUri,_Object_extra)">(2). getStreamFromNetwork(String imageUri, Object extra)</h5><p>通过<code>HttpURLConnection</code>从网络获取图片的<code>InputStream</code>。支持 response code 为 3xx 的重定向。这里有个小细节代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	imageStream = conn.getInputStream();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	<span class="comment">// Read all data to allow reuse connection (http://bit.ly/1ad35PY)</span></span><br><span class="line">	IoUtils.readAndCloseStream(conn.getErrorStream());</span><br><span class="line">	<span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在发生异常时会调用<code>conn.getErrorStream()</code>继续读取 Error Stream，这是为了利于网络连接回收及复用。但有意思的是在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，不少库通过在 2.3 之前使用 AndroidHttpClient 解决这个问题。  </p>
<h5 id="(3)-_getStreamFromFile(String_imageUri,_Object_extra)">(3). getStreamFromFile(String imageUri, Object extra)</h5><p>从文件系统获取图片的<code>InputStream</code>。如果 uri 是 video 类型，则需要单独得到 video 的缩略图返回，否则按照一般读取文件操作返回。  </p>
<h5 id="(4)-_getStreamFromContent(String_imageUri,_Object_extra)">(4). getStreamFromContent(String imageUri, Object extra)</h5><p>从 ContentProvider 获取图片的<code>InputStream</code>。<br>如果是 video 类型，则先从<code>MediaStore</code>得到 video 的缩略图返回；<br>如果是联系人类型，通过<code>ContactsContract.Contacts.openContactPhotoInputStream(res, uri)</code>读取内容返回。<br>否则通过 ContentResolver.openInputStream(…) 读取内容返回。  </p>
<h5 id="(5)-_getStreamFromAssets(String_imageUri,_Object_extra)">(5). getStreamFromAssets(String imageUri, Object extra)</h5><p>从 Assets 中获取图片的<code>InputStream</code>。  </p>
<h5 id="(6)-_getStreamFromDrawable(String_imageUri,_Object_extra)">(6). getStreamFromDrawable(String imageUri, Object extra)</h5><p>从 Drawable 资源中获取图片的<code>InputStream</code>。  </p>
<h5 id="(7)-_getStreamFromOtherSource(String_imageUri,_Object_extra)">(7). getStreamFromOtherSource(String imageUri, Object extra)</h5><p>UNKNOWN(自定义)类型的处理，目前是直接抛出不支持的异常。  </p>
<h5 id="4-2-24_MemoryCache-java">4.2.24 MemoryCache.java</h5><p>Bitmap 内存缓存接口，需要实现的接口包括 get(…)、put(…)、remove(…)、clear()、keys()。  </p>
<h5 id="4-2-25_BaseMemoryCache-java">4.2.25 BaseMemoryCache.java</h5><p>实现了<code>MemoryCache</code>主要函数的抽象类，以 Map\<string, reference\<bitmap\="">> softMap 做为缓存池，利于虚拟机在内存不足时回收缓存对象。提供抽象函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span></span></span><br></pre></td></tr></table></figure></string,></p>
<p>表示根据 Bitmap 创建一个 Reference<bitmap> 做为缓存对象。Reference 可以是 WeakReference、SoftReference 等。  </bitmap></p>
<h5 id="4-2-26_WeakMemoryCache-java">4.2.26 WeakMemoryCache.java</h5><p>以<code>WeakReference&lt;Bitmap&gt;</code>做为缓存 value 的内存缓存，实现了<code>BaseMemoryCache</code>。<br>实现了<code>BaseMemoryCache</code>的<code>createReference(Bitmap value)</code>函数，直接返回一个<code>new WeakReference&lt;Bitmap&gt;(value)</code>做为缓存 value。  </p>
<h5 id="4-2-27_LimitedMemoryCache-java">4.2.27 LimitedMemoryCache.java</h5><p>限制总字节大小的内存缓存，继承自<code>BaseMemoryCache</code>的抽象类。<br>会在 put(…) 函数中判断总体大小是否超出了上限，是则循环删除缓存对象直到小于上限。删除顺序由抽象函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Bitmap <span class="title">removeNext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>决定。抽象函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Bitmap value)</span></span></span><br></pre></td></tr></table></figure></p>
<p>表示每个元素大小。  </p>
<h5 id="4-2-28_LargestLimitedMemoryCache-java">4.2.28 LargestLimitedMemoryCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除 size 最大的元素，继承自<code>LimitedMemoryCache</code>。<br>实现了<code>LimitedMemoryCache</code>缓存<code>removeNext()</code>函数，总是返回当前缓存中 size 最大的元素。  </p>
<h5 id="4-2-29_UsingFreqLimitedMemoryCache-java">4.2.29 UsingFreqLimitedMemoryCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除使用次数最少的元素，继承自<code>LimitedMemoryCache</code>。<br>实现了<code>LimitedMemoryCache</code>缓存<code>removeNext()</code>函数，总是返回当前缓存中使用次数最少的元素。  </p>
<h5 id="4-2-30_LRULimitedMemoryCache-java">4.2.30 LRULimitedMemoryCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，继承自<code>LimitedMemoryCache</code>。<br>通过<code>new LinkedHashMap&lt;String, Bitmap&gt;(10, 1.1f, true)</code>作为缓存池。LinkedHashMap 第三个参数表示是否需要根据访问顺序(accessOrder)排序，true 表示根据<code>accessOrder</code>排序，最近访问的跟最新加入的一样放到最后面，false 表示根据插入顺序排序。这里为 true 且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。<br>实现了<code>LimitedMemoryCache</code>缓存<code>removeNext()</code>函数，总是返回第一个元素，即最近最少使用的元素。  </p>
<h5 id="4-2-31_FIFOLimitedMemoryCache-java">4.2.31 FIFOLimitedMemoryCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除先进入缓存的元素，继承自<code>LimitedMemoryCache</code>。<br>实现了<code>LimitedMemoryCache</code>缓存<code>removeNext()</code>函数，总是返回最先进入缓存的元素。  </p>
<p><strong>以上所有<code>LimitedMemoryCache</code>子类都有个问题，就是 Bitmap 虽然通过<code>WeakReference&lt;Bitmap&gt;</code>包装，但实际根本不会被虚拟机回收，因为他们子类中同时都保留了 Bitmap 的强引用。大都是 UIL 早期实现的版本，不推荐使用。</strong>  </p>
<h5 id="4-2-32_LruMemoryCache-java">4.2.32 LruMemoryCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，实现了<code>MemoryCache</code>。LRU(Least Recently Used) 为最近最少使用算法。  </p>
<p>以<code>new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true)</code>作为缓存池。LinkedHashMap 第三个参数表示是否需要根据访问顺序(accessOrder)排序，true 表示根据<code>accessOrder</code>排序，最近访问的跟最新加入的一样放到最后面，false 表示根据插入顺序排序。这里为 true 且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。  </p>
<p>在<code>put(…)</code>函数中通过<code>trimToSize(int maxSize)</code>函数判断总体大小是否超出了上限，是则删除第缓存池中第一个元素，即最近最少使用的元素，直到总体大小小于上限。  </p>
<p><code>LruMemoryCache</code>功能上与<code>LRULimitedMemoryCache</code>类似，不过在实现上更加优雅。用简单的实现接口方式，而不是不断继承的方式。  </p>
<h5 id="4-2-33_LimitedAgeMemoryCache-java">4.2.33 LimitedAgeMemoryCache.java</h5><p>限制了对象最长存活周期的内存缓存。<br><code>MemoryCache</code>的装饰者，相当于为<code>MemoryCache</code>添加了一个特性。以一个<code>MemoryCache</code>内存缓存和一个 maxAge 做为构造函数入参。在 get(…) 时判断如果对象存活时间已经超过设置的最长时间，则删除。  </p>
<h5 id="4-2-34_FuzzyKeyMemoryCache-java">4.2.34 FuzzyKeyMemoryCache.java</h5><p>可以将某些原本不同的 key 看做<code>相等</code>，在 put 时删除这些<code>相等</code>的 key。<br><code>MemoryCache</code>的装饰者，相当于为<code>MemoryCache</code>添加了一个特性。以一个<code>MemoryCache</code>内存缓存和一个 keyComparator 做为构造函数入参。在 put(…) 时判断如果 key 与缓存中已有 key 经过<code>Comparator</code>比较后相等，则删除之前的元素。  </p>
<h5 id="4-2-35_FileNameGenerator-java">4.2.35 FileNameGenerator.java</h5><p>根据 uri 得到文件名的接口。  </p>
<h5 id="4-2-36_HashCodeFileNameGenerator-java">4.2.36 HashCodeFileNameGenerator.java</h5><p>以 uri 的 hashCode 作为文件名。  </p>
<h5 id="4-2-37_Md5FileNameGenerator-java">4.2.37 Md5FileNameGenerator.java</h5><p>以 uri 的 MD5 值作为文件名。  </p>
<h5 id="4-2-38_DiskCache-java">4.2.38 DiskCache.java</h5><p>图片的磁盘缓存接口。  </p>
<p><strong>主要函数:</strong>  </p>
<h5 id="(1)_File_get(String_imageUri)">(1) File get(String imageUri)</h5><p>根据原始图片的 uri 去获取缓存图片的文件。  </p>
<h5 id="(2)_boolean_save(String_imageUri,_InputStream_imageStream,_IoUtils-CopyListener_listener)">(2) boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</h5><p>保存 imageStream 到磁盘中，listener 表示保存进度且可在其中取消某些段的保存。  </p>
<h5 id="(3)_boolean_save(String_imageUri,_Bitmap_bitmap)">(3) boolean save(String imageUri, Bitmap bitmap)</h5><p>保存图片到磁盘。  </p>
<h5 id="(4)_boolean_remove(String_imageUri)">(4) boolean remove(String imageUri)</h5><p>根据图片 uri 删除缓存图片。  </p>
<h5 id="(5)_void_close()">(5) void close()</h5><p>关闭磁盘缓存，并释放资源。  </p>
<h5 id="(6)_void_clear()">(6) void clear()</h5><p>清空磁盘缓存。  </p>
<h5 id="(7)_File_getDirectory()">(7) File getDirectory()</h5><p>得到磁盘缓存的根目录。  </p>
<h5 id="4-2-39_BaseDiskCache-java">4.2.39 BaseDiskCache.java</h5><p>一个无大小限制的本地图片缓存，实现了<code>DiskCache</code>主要函数的抽象类。<br>图片缓存在<code>cacheDir</code>文件夹内，当<code>cacheDir</code>不可用时，则使用备库<code>reserveCacheDir</code>。  </p>
<p><strong>主要函数：</strong> </p>
<h5 id="(1)-_save(String_imageUri,_InputStream_imageStream,_IoUtils-CopyListener_listener)">(1). save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</h5><p>先根据<code>imageUri</code>得到目标文件，将<code>imageStream</code>先写入与目标文件同一文件夹的 .tmp 结尾的临时文件内，若未被<code>listener</code>取消且写入成功则将临时文件重命名为目标文件并返回 true，否则删除临时文件并返回 false。  </p>
<h5 id="(2)-_save(String_imageUri,_Bitmap_bitmap)">(2). save(String imageUri, Bitmap bitmap)</h5><p>先根据<code>imageUri</code>得到目标文件，通过<code>Bitmap.compress(…)</code>函数将<code>bitmap</code>先写入与目标文件同一文件夹的 .tmp 结尾的临时文件内，若写入成功则将临时文件重命名为目标文件并返回 true，否则删除临时文件并返回 false。  </p>
<h5 id="(3)-_File_getFile(String_imageUri)">(3). File getFile(String imageUri)</h5><p>根据 imageUri 和 <code>fileNameGenerator</code>得到文件名，返回<code>cacheDir</code>内该文件，若<code>cacheDir</code>不可用，则使用备库<code>reserveCacheDir</code>。  </p>
<h5 id="4-2-40_LimitedAgeDiskCache-java">4.2.40 LimitedAgeDiskCache.java</h5><p>限制了缓存对象最长存活周期的磁盘缓存，继承自<code>BaseDiskCache</code>。<br>在 get(…) 时判断如果缓存对象存活时间已经超过设置的最长时间，则删除。在 save(…) 时保存当存时间作为对象的创建时间。  </p>
<h5 id="4-2-41_UnlimitedDiskCache-java">4.2.41 UnlimitedDiskCache.java</h5><p>一个无大小限制的本地图片缓存。与<code>BaseDiskCache</code>无异，只是用了个意思明确的类名。  </p>
<h5 id="4-2-42_DiskLruCache-java">4.2.42 DiskLruCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素。  </p>
<p>通过缓存目录下名为<code>journal</code>的文件记录缓存的所有操作，并在缓存<code>open</code>时读取<code>journal</code>的文件内容存储到<code>LinkedHashMap&lt;String, Entry&gt; lruEntries</code>中，后面<code>get(String key)</code>获取缓存内容时，会先从<code>lruEntries</code>中得到图片文件名返回文件。  </p>
<p>LRU 的实现跟上面内存缓存类似，<code>lruEntries</code>为<code>new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true)</code>，LinkedHashMap 第三个参数表示是否需要根据访问顺序(accessOrder)排序，true 表示根据<code>accessOrder</code>排序，最近访问的跟最新加入的一样放到最后面，false 表示根据插入顺序排序。这里为 true 且缓存满时<code>trimToSize()</code>函数始终删除第一个元素，即始终删除最近最少访问的文件。  </p>
<p>来源于 JakeWharton 的开源项目 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">DiskLruCache</a>，具体分析请等待 <a href="https://github.com/android-cn/android-open-project-analysis/tree/master/disk-lru-cache" target="_blank" rel="external">DiskLruCache 源码解析</a> 完成。  </p>
<h5 id="4-2-43_LruDiskCache-java">4.2.43 LruDiskCache.java</h5><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，实现了<code>DiskCache</code>。<br>内部有个<code>DiskLruCache cache</code>属性，缓存的存、取操作基本都是由该属性代理完成。  </p>
<h5 id="4-2-44_StrictLineReader-java">4.2.44 StrictLineReader.java</h5><p>通过<code>readLine()</code>函数从<code>InputStream</code>中读取一行，目前仅用于磁盘缓存操作记录文件<code>journal</code>的解析。  </p>
<h5 id="4-2-45_Util-java">4.2.45 Util.java</h5><p>工具类。<br><code>String readFully(Reader reader)</code>读取 reader 中内容。<br><code>deleteContents(File dir)</code>递归删除文件夹内容。  </p>
<h5 id="4-2-46_ContentLengthInputStream-java">4.2.46 ContentLengthInputStream.java</h5><p><code>InputStream</code>的装饰者，可通过<code>available()</code>函数得到 InputStream 对应数据源的长度(总字节数)。主要用于计算文件存储进度即图片下载进度时的总进度。  </p>
<h5 id="4-2-47_FailReason-java">4.2.47 FailReason.java</h5><p>图片下载及显示时的错误原因，目前包括：<br><code>IO_ERROR</code> 网络连接或是磁盘存储错误。<br><code>DECODING_ERROR</code> decode image 为 Bitmap 时错误。<br><code>NETWORK_DENIED</code> 当图片不在缓存中，且设置不允许访问网络时的错误。<br><code>OUT_OF_MEMORY</code> 内存溢出错误。<br><code>UNKNOWN</code> 未知错误。  </p>
<h5 id="4-2-48_FlushedInputStream-java">4.2.48 FlushedInputStream.java</h5><p>为了解决早期 Android 版本<code>BitmapFactory.decodeStream(…)</code>在慢网络情况下 decode image 异常的 Bug。<br>主要通过重写<code>FilterInputStream</code>的 skip(long n) 函数解决，确保 skip(long n) 始终跳过了 n 个字节。如果返回结果即跳过的字节数小于 n，则不断循环直到 skip(long n) 跳过 n 字节或到达文件尾。  </p>
<h5 id="4-2-49_ImageScaleType-java">4.2.49 ImageScaleType.java</h5><p>Image 的缩放类型，目前包括：<br><code>NONE</code>不缩放。<br><code>NONE_SAFE</code>根据需要以整数倍缩小图片，使得其尺寸不超过 Texture 可接受最大尺寸。<br><code>IN_SAMPLE_POWER_OF_2</code>根据需要以 2 的 n 次幂缩小图片，使其尺寸不超过目标大小，比较快的缩小方式。<br><code>IN_SAMPLE_INT</code>根据需要以整数倍缩小图片，使其尺寸不超过目标大小。<br><code>EXACTLY</code>根据需要缩小图片到宽或高有一个与目标尺寸一致。<br><code>EXACTLY_STRETCHED</code>根据需要缩放图片到宽或高有一个与目标尺寸一致。  </p>
<h5 id="4-2-50_ViewScaleType-java">4.2.50 ViewScaleType.java</h5><p><code>ImageAware</code>的 ScaleType。<br>将 ImageView 的 ScaleType 简化为两种<code>FIT_INSIDE</code>和<code>CROP</code>两种。<code>FIT_INSIDE</code>表示将图片缩放到至少宽度和高度有一个小于等于 View 的对应尺寸，<code>CROP</code>表示将图片缩放到宽度和高度都大于等于 View 的对应尺寸。  </p>
<h5 id="4-2-51_ImageSize-java">4.2.51 ImageSize.java</h5><p>表示图片宽高的类。<br><code>scaleDown(…)</code> 等比缩小宽高。<br><code>scale(…)</code> 等比放大宽高。  </p>
<h5 id="4-2-52_LoadedFrom-java">4.2.52 LoadedFrom.java</h5><p>图片来源枚举类，包括网络、磁盘缓存、内存缓存。  </p>
<h5 id="4-2-53_ImageDecoder-java">4.2.53 ImageDecoder.java</h5><p>将图片转换为 Bitmap 的接口，抽象函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bitmap <span class="title">decode</span><span class="params">(ImageDecodingInfo imageDecodingInfo)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p>
<p>表示根据<code>ImageDecodingInfo</code>信息得到图片并根据参数将其转换为 Bitmap。  </p>
<h5 id="4-2-54_BaseImageDecoder-java">4.2.54 BaseImageDecoder.java</h5><p>实现了<code>ImageDecoder</code>。调用<code>ImageDownloader</code>获取图片，然后根据<code>ImageDecodingInfo</code>或图片 Exif 信息处理图片转换为 Bitmap。  </p>
<p><strong>主要函数：</strong></p>
<h5 id="(1)-_decode(ImageDecodingInfo_decodingInfo)">(1). decode(ImageDecodingInfo decodingInfo)</h5><p>调用<code>ImageDownloader</code>获取图片，再调用<code>defineImageSizeAndRotation(…)</code>函数得到图片的相关信息，调用<code>prepareDecodingOptions(…)</code>得到图片缩放的比例，调用<code>BitmapFactory.decodeStream</code>将 InputStream 转换为 Bitmap，最后调用<code>considerExactScaleAndOrientatiton(…)</code>根据参数将图片放大、翻转、旋转为合适的样子返回。  </p>
<h5 id="(2)-_defineImageSizeAndRotation(InputStream_imageStream,_ImageDecodingInfo_decodingInfo)">(2). defineImageSizeAndRotation(InputStream imageStream, ImageDecodingInfo decodingInfo)</h5><p>得到图片真实大小以及 Exif 信息(设置考虑 Exif 的条件下)。  </p>
<h5 id="(3)-_defineExifOrientation(String_imageUri)">(3). defineExifOrientation(String imageUri)</h5><p>得到图片 Exif 信息中的翻转以及旋转角度信息。  </p>
<h5 id="(4)-_prepareDecodingOptions(ImageSize_imageSize,_ImageDecodingInfo_decodingInfo)">(4). prepareDecodingOptions(ImageSize imageSize, ImageDecodingInfo decodingInfo)</h5><p>得到图片缩放的比例。  </p>
<ol>
<li>如果<code>scaleType</code>等于<code>ImageScaleType.NONE</code>，则缩放比例为 1；  </li>
<li>如果<code>scaleType</code>等于<code>ImageScaleType.NONE_SAFE</code>，则缩放比例为 <code>(int)Math.ceil(Math.max((float)srcWidth / maxWidth, (float)srcHeight / maxHeight))</code>；  </li>
<li>否则，调用<code>ImageSizeUtils.computeImageSampleSize(…)</code>计算缩放比例。<br>在 computeImageSampleSize(…) 中  </li>
<li>如果<code>viewScaleType</code>等于<code>ViewScaleType.FIT_INSIDE</code>；<br>1.1 如果<code>scaleType</code>等于<code>ImageScaleType.IN_SAMPLE_POWER_OF_2</code>，则缩放比例从 1 开始不断 *2 直到宽或高小于最大尺寸；<br>1.2 否则取宽和高分别与最大尺寸比例中较大值，即<code>Math.max(srcWidth / targetWidth, srcHeight / targetHeight)</code>。  </li>
<li>如果<code>scaleType</code>等于<code>ViewScaleType.CROP</code>；<br>2.1 如果<code>scaleType</code>等于<code>ImageScaleType.IN_SAMPLE_POWER_OF_2</code>，则缩放比例从 1 开始不断 *2 直到宽和高都小于最大尺寸。<br>2.2 否则取宽和高分别与最大尺寸比例中较小值，即<code>Math.min(srcWidth / targetWidth, srcHeight / targetHeight)</code>。  </li>
<li>最后判断宽和高是否超过最大值，如果是 *2 或是 +1 缩放。  </li>
</ol>
<h5 id="(5)-_considerExactScaleAndOrientatiton(Bitmap_subsampledBitmap,_ImageDecodingInfo_decodingInfo,_int_rotation,_boolean_flipHorizontal)">(5). considerExactScaleAndOrientatiton(Bitmap subsampledBitmap, ImageDecodingInfo decodingInfo, int rotation, boolean flipHorizontal)</h5><p>根据参数将图片放大、翻转、旋转为合适的样子返回。  </p>
<h5 id="4-2-55_ImageDecodingInfo-java">4.2.55 ImageDecodingInfo.java</h5><p>Image Decode 需要的信息。<br><code>String imageKey</code> 图片。<br><code>String imageUri</code> 图片 uri，可能是缓存文件的 uri。<br><code>String originalImageUri</code> 图片原 uri。<br><code>ImageSize targetSize</code> 图片的显示尺寸。<br><code>imageScaleType</code> 图片的 ScaleType。<br><code>ImageDownloader downloader</code> 图片的下载器。<br><code>Object extraForDownloader</code> 下载器需要的辅助信息。<br><code>boolean considerExifParams</code> 是否需要考虑图片 Exif 信息。<br><code>Options decodingOptions</code> 图片的解码信息，为 BitmapFactory.Options。  </p>
<h5 id="4-2-56_BitmapDisplayer-java">4.2.56 BitmapDisplayer.java</h5><p>在<code>ImageAware</code>中显示 bitmap 对象的接口。可在实现中对 bitmap 做一些额外处理，比如加圆角、动画效果。  </p>
<h5 id="4-2-57_FadeInBitmapDisplayer-java">4.2.57 FadeInBitmapDisplayer.java</h5><p>图片淡入方式显示在<code>ImageAware</code>中，实现了<code>BitmapDisplayer</code>接口。  </p>
<h5 id="4-2-58_RoundedBitmapDisplayer-java">4.2.58 RoundedBitmapDisplayer.java</h5><p>为图片添加圆角显示在<code>ImageAware</code>中，实现了<code>BitmapDisplayer</code>接口。主要通过<code>BitmapShader</code>实现。  </p>
<h5 id="4-2-59_RoundedVignetteBitmapDisplayer-java">4.2.59 RoundedVignetteBitmapDisplayer.java</h5><p>为图片添加渐变效果的圆角显示在<code>ImageAware</code>中，实现了<code>BitmapDisplayer</code>接口。主要通过<code>RadialGradient</code>实现。  </p>
<h5 id="4-2-60_SimpleBitmapDisplayer-java">4.2.60 SimpleBitmapDisplayer.java</h5><p>直接将图片显示在<code>ImageAware</code>中，实现了<code>BitmapDisplayer</code>接口。  </p>
<h5 id="4-2-61_BitmapProcessor-java">4.2.61 BitmapProcessor.java</h5><p>图片处理接口。可用于对图片预处理(Pre-process Bitmap)和后处理(Post-process Bitmap)。抽象函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapProcessor</span> </span>&#123;</span><br><span class="line">	<span class="function">Bitmap <span class="title">process</span><span class="params">(Bitmap bitmap)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用户可以根据自己需求去实现它。比如你想要为你的图片添加一个水印，那么可以自己去实现 BitmapProcessor 接口，在<code>DisplayImageOptions</code>中配置 Pre-process 阶段预处理图片，这样设置后存储在文件系统以及内存缓存中的图片都是加了水印后的。如果只希望在显示时改变不动原图片，可以在<code>BitmapDisplayer</code>中处理。  </p>
<h5 id="4-2-62_PauseOnScrollListener-java">4.2.62 PauseOnScrollListener.java</h5><p>可在 View 滚动过程中暂停图片加载的 Listener，实现了 OnScrollListener 接口。<br>它的好处是防止滚动中不必要的图片加载，比如快速滚动不希望滚动中的图片加载。在 ListView 或 GridView 中 item 加载图片最好使用它，简单的一行代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gridView.setOnScrollListener(<span class="keyword">new</span> PauseOnScrollListener(ImageLoader.getInstance(), <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br></pre></td></tr></table></figure></p>
<p><strong>主要的成员变量：</strong><br><code>pauseOnScroll</code> 触摸滑动(手指依然在屏幕上)过程中是否暂停图片加载。<br><code>pauseOnFling</code> 甩指滚动(手指已离开屏幕)过程中是否暂停图片加载。<br><code>externalListener</code> 自定义的 OnScrollListener 接口，适用于 View 原来就有自定义 OnScrollListener 情况设置。  </p>
<p><strong>实现原理：</strong><br>重写<code>onScrollStateChanged(…)</code>函数判断不同的状态下暂停或继续图片加载。<br><code>OnScrollListener.SCROLL_STATE_IDLE</code>表示 View 处于空闲状态，没有在滚动，这时候会加载图片。<br><code>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL</code>表示 View 处于触摸滑动状态，手指依然在屏幕上，通过<code>pauseOnScroll</code>变量确定是否需要暂停图片加载。这种时候大都属于慢速滚动浏览状态，所以建议继续图片加载。<br><code>OnScrollListener.SCROLL_STATE_FLING</code>表示 View 处于甩指滚动状态，手指已离开屏幕，通过<code>pauseOnFling</code>变量确定是否需要暂停图片加载。这种时候大都属于快速滚动状态，所以建议暂停图片加载以节省资源。  </p>
<h5 id="4-2-63_QueueProcessingType-java">4.2.63 QueueProcessingType.java</h5><p>任务队列的处理类型，包括<code>FIFO</code>先进先出、<code>LIFO</code>后进先出。  </p>
<h5 id="4-2-64_LIFOLinkedBlockingDeque-java">4.2.64 LIFOLinkedBlockingDeque.java</h5><p>后进先出阻塞队列。重写<code>LinkedBlockingDeque</code>的<code>offer(…)</code>函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.offerFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让<code>LinkedBlockingDeque</code>插入总在最前，而<code>remove()</code>本身始终删除第一个元素，所以就变为了后进先出阻塞队列。<br>实际一般情况只重写<code>offer(…)</code>函数是不够的，但因为<code>ThreadPoolExecutor</code>默认只用到了<code>BlockingQueue</code>的<code>offer(…)</code>函数，所以这种简单重写后做为<code>ThreadPoolExecutor</code>的任务队列没问题。  </p>
<p><code>LIFOLinkedBlockingDeque.java</code>包下的<code>LinkedBlockingDeque.java</code>、<code>BlockingDeque.java</code>、<code>Deque.java</code>都是 Java 1.6 源码中的，这里不做分析。  </p>
<h5 id="4-2-65_DiskCacheUtils-java">4.2.65 DiskCacheUtils.java</h5><p>磁盘缓存工具类，可用于查找或删除某个 uri 对应的磁盘缓存。  </p>
<h5 id="4-2-66_MemoryCacheUtils-java">4.2.66 MemoryCacheUtils.java</h5><p>内存缓存工具类。可用于根据 uri 生成内存缓存 key，缓存 key 比较，根据 uri 得到所有相关的 key 或图片，删除某个 uri 的内存缓存。<br><code>generateKey(String imageUri, ImageSize targetSize)</code><br>根据 uri 生成内存缓存 key，key 规则为<code>[imageUri]_[width]x[height]</code>。  </p>
<h5 id="4-2-67_StorageUtils-java">4.2.67 StorageUtils.java</h5><p>得到图片 SD 卡缓存目录路径。<br>缓存目录优先选择<code>/Android/data/[app_package_name]/cache</code>；若无权限或不可用，则选择 App 在文件系统的缓存目录<code>context.getCacheDir()</code>；若无权限或不可用，则选择<code>/data/data/[app_package_name]/cache</code>。  </p>
<p>如果缓存目录选择了<code>/Android/data/[app_package_name]/cache</code>，则新建<code>.nomedia</code>文件表示不允许类似 Galley 这些应用显示此文件夹下图片。不过在 4.0 系统有 Bug 这种方式不生效。  </p>
<h5 id="4-2-68_ImageSizeUtils-java">4.2.68 ImageSizeUtils.java</h5><p>用于计算图片尺寸、缩放比例相关的工具类。  </p>
<h5 id="4-2-69_IoUtils-java">4.2.69 IoUtils.java</h5><p>IO 相关工具类，包括 stream 拷贝，关闭等。  </p>
<h5 id="4-2-70_L-java">4.2.70 L.java</h5><p>Log 工具类。  </p>
<h3 id="5-_杂谈">5. 杂谈</h3><h4 id="聊聊_LRU">聊聊 LRU</h4><p>UIL 的内存缓存默认使用了 LRU 算法。<br>LRU: Least Recently Used 近期最少使用算法, 选用了基于链表结构的 LinkedHashMap 作为存储结构。<br>假设情景：内存缓存设置的阈值只够存储两个 bitmap 对象，当 put 第三个 bitmap 对象时，将近期最少使用的 bitmap 对象移除。<br>图1: 初始化 LinkedHashMap, 并按使用顺序来排序, accessOrder = true;<br>图2: 向缓存池中放入 bitmap1 和 bitmap2 两个对象。<br>图3: 继续放入第三个 bitmap3，根据假设情景，将会超过设定缓存池阈值。<br>图4: 释放对 bitmap1 对象的引用。<br>图5: bitmap1 对象被 GC 回收。<br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/lru_header.png" alt=""><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/lru_put.png" alt=""><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/lru_put_exceed_maxsize2.png" alt=""><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/lru_put_trim.png" alt=""><br><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/universal-image-loader/image/lru_trim_result.png" alt="">  </p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 Android Universal Image Loader 部分<br>项目地址：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">Android-Universal-Image-Loader</a>，分析的版本：<a href="https://github.com/nostra13/Android-Universal-Image-Loader/commit/eb794c306c1707a6cce80764b01f52109d5b9056" target="_blank" rel="external">eb794c3</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/universal-image-loader-demo" target="_blank" rel="external">UIL Demo</a><br>分析者：<a href="https://github.com/huxian99" target="_blank" rel="external">huxian99</a>，校对者：<a href="https://github.com/grumoon" target="_blank" rel="external">Grumoon</a>、<a href="https://github.com/trinea" target="_blank" rel="external">Trinea</a>，校对状态：完成</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h4 id="1-1_Android_Universal_Image_Loader">1.1 Android Universal Image Loader</h4><p>Android Universal Image Loader 是一个强大的、可高度定制的图片缓存，本文简称为<code>UIL</code>。<br>简单的说 UIL 就做了一件事——获取图片并显示在相应的控件上。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之PhotoView 源码解析]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_photoview/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/03/android-open-project-analysis_photoview/</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:40.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h5 id="特性(Features)：">特性(Features)：</h5><ul>
<li>支持Pinch手势自由缩放。</li>
<li>支持双击放大/还原。</li>
<li>支持平滑滚动。</li>
<li>在滑动父控件下能够运行良好。（例如：ViewPager）</li>
<li>支持基于Matrix变化（放大/缩小/移动）的事件监听。<a id="more"></a>
<h5 id="优势：">优势：</h5></li>
<li>PhotoView是ImageView的子类，自然的支持所有ImageView的源生行为。</li>
<li>任意项目可以非常方便的从ImageView升级到PhotoView，不用做任何额外的修改。</li>
<li>可以非常方便的与ImageLoader/Picasso之类的异步网络图片读取库集成使用。</li>
<li>事件分发做了很好的处理，可以方便的与ViewPager等同样支持滑动手势的控件集成。</li>
</ul>
<h3 id="2-_总体设计">2. 总体设计</h3><p>PhotoView这个库实际上比较简单,关键点其实就是Touch事件处理和Matrix图形变换的应用.</p>
<h5 id="2-1_TouchEvent及手势事件处理">2.1 TouchEvent及手势事件处理</h5><p>对TouchEvent分发流程不了解的建议先阅读 <a href="http://www.trinea.cn/android/touch-event-delivery-mechanism/" target="_blank" rel="external">Android Touch事件传递机制</a></p>
<p>本库中对Touch事件的处理流程请参考第三部分的流程图，会有一个比较直观的认识。</p>
<h5 id="2-2_Matrix">2.2 Matrix</h5><p>由于Matrix是Android系统源生API,很多开发者对此都比较熟悉,为了不影响阅读效果，故不在此详细叙述,如果对其不是很了解,可以查看本文档末尾的Matrix补充说明</p>
<h3 id="3-_流程图">3. 流程图</h3><p>Touch及手势事件判定及传递流程：</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/flow.png" alt="流程图"></p>
<p>如图，从架构上看，干净利落的将事件层层分离，交由不同的Detector处理，最后再将处理结果回调给PhtotViewAttacher中的Matrix去实现图形变换效果。</p>
<h3 id="4-_详细设计">4. 详细设计</h3><h3 id="4-1_核心类功能介绍">4.1 核心类功能介绍</h3><h3 id="Core核心类">Core核心类</h3><hr>
<h5 id="4-1-1_PhotoView">4.1.1 PhotoView</h5><p>PhotoView 类负责暴露所有供外部调用的API,其本身直接继承自ImageView,同时实现了IPhotoView接口.<br>IPhotoView接口提供了缩放相关的设置属性 和操控matrix变化的回调接口.</p>
<p>主要方法说明:</p>
<ul>
<li>public PhotoView(Context context)</li>
<li>public PhotoView(Context context, AttributeSet attr)</li>
<li>public PhotoView(Context context, AttributeSet attr, int defStyle)</li>
</ul>
<p>构造函数,完全与ImageView相同,你可以将PhotoView直接当做ImageView使用,完全兼容.</p>
<ul>
<li>public void setPhotoViewRotation(float rotationDegree)</li>
</ul>
<p>用于设置图片旋转角度.</p>
<p>注意：<br>例如使用Android相机拍摄的相片,会根据拍摄时手机方向的不同,在EXIF中存储不同的旋转角度信息,显示时往往需要查询EXIF信息并将照片旋转至正确的方向.<br>通常我们处理这种问题有两种方案：</p>
<ul>
<li>通过Bitmap.createBitmap方式重建出正确方向的图片，再加载到ImageView中显示。(不建议使用，因为会占用双倍的内存，Bitmap的回收不是立即生效的。)</li>
<li>在ImageView中使用自定义Matrix将图片旋转到正确的方向。</li>
</ul>
<p>由于PhotoView中对图片的 缩放 操作依赖对Matrix的操作，自定义Matrix会干扰 PhotoView 的缩放行为，所以PhotoView并不支持ScaleType.Matrix.<br>可参见PhotoViewAttacher源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span><br><span class="line"> * <span class="doctag">@return</span> true if the ScaleType is supported.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSupportedScaleType</span><span class="params">(<span class="keyword">final</span> ScaleType scaleType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == scaleType) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (scaleType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MATRIX:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(scaleType.name()</span><br><span class="line">                    + <span class="string">" is not supported in PhotoView"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里特意提供了一个额外的setPhotoViewRotation方法即是为了解决这个问题。</p>
<ul>
<li>public boolean canZoom()</li>
<li>public void setZoomable(boolean zoomable) </li>
</ul>
<p>缩放功能开关及状态获取.<br>关闭后PhotoView将不再响应 <code>缩放</code> 动作.</p>
<ul>
<li>public RectF getDisplayRect()</li>
<li>public Matrix getDisplayMatrix()</li>
<li>public boolean setDisplayMatrix(Matrix finalRectangle)</li>
</ul>
<p>获取及设置当前 <code>matrix</code> 状态.</p>
<ul>
<li>public ScaleType getScaleType()</li>
</ul>
<p>获取缩放模式。使用的源生的ImageView.ScaleType.<br>在PhotoView中默认值为FIT_CENTER.</p>
<ul>
<li>public void setAllowParentInterceptOnEdge(boolean allow)</li>
</ul>
<p>设置标志位 是否允许父控件捕获发生在边缘的TouchEvent</p>
<p>这个标志位实际上对应的是<br>ViewParent.requestDisallowInterceptTouchEvent(boolean flag)</p>
<p>经常做自定义View处理TouchEvent的对这个方法应当都不陌生。</p>
<p>PhotoView中英文注释：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Here we decide whether to let the ImageView's parent to start taking</span><br><span class="line">* over the touch event.</span><br><span class="line">*</span><br><span class="line">* First we<span class="instruction"> check </span>whether this function is enabled. We never want the</span><br><span class="line">* parent to take over<span class="instruction"> if </span>we're scaling. We then<span class="instruction"> check </span>the edge we're</span><br><span class="line">* on,<span class="instruction"> and </span>the direction of the scroll<span class="function"> (</span>i.e.<span class="instruction"> if </span>we're pulling against</span><br><span class="line">* the edge, aka 'overscrolling', let the parent take over<span class="function">)</span>.</span><br></pre></td></tr></table></figure>
<p>对应的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ViewParent parent = imageView.getParent();</span><br><span class="line"><span class="keyword">if</span> (mAllowParentInterceptOnEdge &amp;&amp; !mScaleDragDetector.isScaling()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollEdge == EDGE_BOTH</span><br><span class="line">            || (mScrollEdge == EDGE_LEFT &amp;&amp; dx &gt;= <span class="number">1f</span>)</span><br><span class="line">            || (mScrollEdge == EDGE_RIGHT &amp;&amp; dx &lt;= -<span class="number">1f</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != parent)</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != parent) &#123;</span><br><span class="line">        parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用setAllowParentInterceptOnEdge(false),可以完全屏蔽父控件的TouchEvent.<br>这个设置是为了防止父控件响应InterceptTouchEvent.</p>
<p>例如</p>
<p>PhotoView外层是ScrollView,通过requestDisallowInterceptTouchEvent方法可以阻止ScrollView响应滑动手势.</p>
<p>PhotoView本身已做好了相关处理,在PhotoView滚到图片边缘时,Scroll事件由父控件处理,在PhotoView未滚动到边缘时,Scroll事件由PhotoView处理.</p>
<p>除非开发者有特殊的需求,否则不需要自己去调用该方法改变TouchEvent事件的阻断逻辑.</p>
<ul>
<li>public void setImageDrawable(Drawable drawable)</li>
<li>public void setImageResource(int resId) </li>
<li>public void setImageURI(Uri uri)</li>
</ul>
<p>重载了ImageView的3个设置图片的方法,以确保图片改变时PhotoViewAttacher及时更新视图和重置matrix状态</p>
<ul>
<li>protected void onDetachedFromWindow()</li>
</ul>
<p>重载了ImageView的方法,用于在视图被从Window中移除时,通知PhotoViewAttacher清空数据.</p>
<h5 id="4-1-2_IPhotoView">4.1.2 IPhotoView</h5><p>IPhotoView接口定义了缩放相关的一组set/get方法.PhotoView是其实现类.<br>相关方法已在PhotoView中介绍,这里略过.</p>
<h5 id="4-1-3_PhotoViewAttacher">4.1.3 PhotoViewAttacher</h5><p>核心类</p>
<ul>
<li>private static boolean isSupportedScaleType(final ScaleType scaleType) </li>
</ul>
<p>判断ScaleType是否支持。<br>这个判断中实际只有ScaleType.Matrix会返回false.</p>
<p>由于PhotoView中 缩放 滑动操作都依赖<code>Matrix</code>,所以并不支持用户再传入自定义Matrix.</p>
<ul>
<li>public void cleanup()</li>
</ul>
<p>PhotoView不再使用时,可用于释放相关资源。移除Observer, Listener.</p>
<ul>
<li>public boolean setDisplayMatrix(Matrix finalMatrix)</li>
</ul>
<p>通过Matrix来直接修改ImageView的显示状态。</p>
<ul>
<li>private void cancelFling()</li>
</ul>
<p>取消惯性滑动。</p>
<ul>
<li>private boolean checkMatrixBounds() </li>
</ul>
<p>检查当前显示范围是否处于边界上，并更新mScrollEdge标志位。</p>
<p>处理TouchEvent时需要根据mScrollEdge标志位的状态来判断是否允许ViewParent的InterceptTouchEvent接收TouchEvent.</p>
<ul>
<li>private void resetMatrix()</li>
</ul>
<p>重置Matrix状态，并恢复至FIT_CENTER状态</p>
<ul>
<li>private void updateBaseMatrix(Drawable d)</li>
</ul>
<p>根据PhotoView的宽高和Drawable的宽高计算FIT_CENTER状态的Matrix.</p>
<ul>
<li>public void onDrag(float dx, float dy)</li>
</ul>
<p>OnGestureListener接口回调的实现方法.</p>
<p>实际完成拖拽/移动效果.<br>核心代码:</p>
<pre><code>mSuppMatrix.postTranslate(<span class="number">dx</span>, <span class="pseudo">dy</span>)<span class="comment">;</span>
</code></pre><p>通过改代码修改Matrix中View的起始位置,制造出图片被拖拽移动的效果.</p>
<ul>
<li>public void onFling(float startX, float startY, float velocityX, float velocityY)</li>
</ul>
<p>OnGestureListener接口回调的实现方法.<br>实际完成惯性滑动效果.</p>
<p>惯性滑动效果分两部分完成.</p>
<p>1) 调用 </p>
<pre><code>mScroller.fling(startX, startY, velocityX, velocityY, <span class="keyword">min</span>X,
                    <span class="keyword">max</span>X, <span class="keyword">min</span>Y, <span class="keyword">max</span>Y, <span class="number">0</span>, <span class="number">0</span>);
</code></pre><p>进行惯性滑动辅助计算.</p>
<p>对Scroller不了解的可以参考官方说明 <a href="http://developer.android.com/reference/android/widget/Scroller.html" target="_blank" rel="external">Scroller</a></p>
<p>简单来讲,Scroller是一个辅助计算器,它可以帮你计算出某一时刻View的滚动状态及位置,但是它本身不会对View进行任何更改</p>
<p>2) 使用了FlingRunnable和Compat.postOnAnimation(imageView,mFlingRunnable)在每一帧绘制前更新Matrix状态<br>关于FlingRunnable和Compat.postOnAnimation类的作用机制可以参考下面 4.1.4的说明.</p>
<ul>
<li>public void onScale(float scaleFactor, float focusX, float focusY)</li>
</ul>
<p>OnGestureListener接口回调的实现方法.</p>
<p>实际完成缩放效果.</p>
<p>核心代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);</span><br></pre></td></tr></table></figure>
<p>对Matrix作用机制不了解的话,可以拉到文档最后,有一个针对Matrix的简略介绍.</p>
<h6 id="内部类_FlingRunnable">内部类 FlingRunnable</h6><p>实现惯性滑动的动画效果.</p>
<p>这个Runnable必须配合 View.postOnAnimation(view,runnable) 使用.</p>
<p>在下一帧绘制前,系统会执行该Runnable,这样我们就可以在runnable中更新UI状态.</p>
<p>原理上类似一个递归调用,每次UI绘制前更新UI状态,并指定下次UI更新前再执行自己.</p>
<p>这种写法 与 使用循环或Handler每隔16ms刷新一次UI基本等价,但是更为方便快捷.</p>
<p>更新UI的核心逻辑非常简单,根据mScroller计算出的偏移量更新Matrix状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSuppMatrix.postTranslate(dx, dy);</span><br></pre></td></tr></table></figure>
<h6 id="内部类_AnimatedZoomRunnable">内部类 AnimatedZoomRunnable</h6><p>实现双击时的 缩放动画.</p>
<p>作用机制基本同上.</p>
<p>区别是AnimatedZoomRunnable的执行进度由AccelerateDecelerateInterpolator控制.</p>
<p>对Interpolator没有概念的可以参阅官方Demo<br><a href="http://developer.android.com/samples/Interpolator/src/com.example.android.interpolator/InterpolatorFragment.html" target="_blank" rel="external">Interpolator</a></p>
<p>你也可以简单认为这就是一个动画进度控制器.</p>
<p>核心逻辑依然很简单,根据动画进度缩小/放大图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSuppMatrix.postScale(deltaScale, deltaScale, mFocalX, mFocalY);</span><br></pre></td></tr></table></figure>
<h3 id="接口及工具类">接口及工具类</h3><hr>
<h5 id="4-1-4_Compat">4.1.4 Compat</h5><p>用于做View.postOnAnimation方法在低版本上的兼容.</p>
<p>注：View.postOnAnimation (Runnable action) 在PhotoView中用于处理  双击 放大/缩小 惯性滑动时的动画效果.</p>
<p>每次系统绘图前都会先执行这个Runnable回调，通过在此时改变视图状态以实现动画效果。该方法仅支持 api &gt;= 16<br>所以PhotoView中使用了Compat类来做低版本兼容。</p>
<p>实际上也可以使用android.support.v4.view.ViewCompat替代。<br>对比 android.support.v4.view.ViewCompat 和 uk.co.senab.photoview.Compat<br>其实现原理完全一致，都是通过view.postDelayed(runnable, frameTime)来实现.</p>
<h5 id="4-1-5_ScrollerProxy">4.1.5 ScrollerProxy</h5><p>抽象类,主要是为了做不用版本之间的兼容,具体说明见<code>GingerScroller</code> <code>IcsScroller</code> <code>PreGingerScroller</code> 这三个接口实现类的说明.</p>
<h5 id="4-1-6_GingerScroller">4.1.6 GingerScroller</h5><p><code>ScrollerProxy</code> 接口实现类<br>适用于 API 9 ~ 14 即 2.3 ~ 4.0 之间的所有Android版本.<br>其实现主要基于 android.widget.OverScroller</p>
<h5 id="4-1-7_IcsScroller">4.1.7 IcsScroller</h5><p>适用于 API 14 以上 即 4.0 以上的所有Android版本<br>其实现基于源生 android.widget.OverScroller , 没有任何修改.</p>
<h5 id="4-1-8_PreGingerScroller">4.1.8 PreGingerScroller</h5><p>适用于 API 9 以下 即 2.3 以下的所有Android版本<br>其实现主要基于 android.widget.Scroller</p>
<h5 id="4-1-9_GestureDetector">4.1.9 GestureDetector</h5><p>接口,主要是为了做不同版本之间的兼容,具体说明见 <code>CupcakeGestureDetector</code>,<code>EclairGestureDetector</code>,<code>FroyoGestureDetector</code> 三个接口的实现类.</p>
<h5 id="4-1-10_OnGestureListener">4.1.10 OnGestureListener</h5><p>手势回调接口</p>
<h5 id="4-1-11_CupcakeGestureDetector">4.1.11 CupcakeGestureDetector</h5><p>适用于 api &lt; 7 的设备,此时PhotoView不支持双指pinch放大/缩小操作</p>
<h5 id="4-1-12_EclairGestureDetector">4.1.12 EclairGestureDetector</h5><p>适用于 api &gt;= 8 , 用于修正多指操控的问题,使TouchEvent的getActiveX getActiveY指向正确的Pointer,并将事件传递给 <code>CupcakeGestureDetector</code> 处理,此时PhotoView不支持双指pinch放大/缩小操作</p>
<h5 id="4-1-13_FroyoGestureDetector">4.1.13 FroyoGestureDetector</h5><p>适用于 api &gt; 9 , 通过android.view.ScaleGestureDetector实现对Pinch手势的支持,并将事件传递给 <code>EclairGestureDetector</code> 处理</p>
<p>注意:<br>以上3个类并不实际执行 放大/缩小 行为, 判断行为之后会回调给PhtotViewAttacher执行缩放/移动操作</p>
<h5 id="4-1-14_VersionedGestureDetector">4.1.14 VersionedGestureDetector</h5><p>提供GestureDetector的实例，由它根据系统版本决定实例化哪一个 GestureDetector ，主要是为了兼容Android的不同版本。<br>具体调用栈请参考总体设计中调用流程图,注意一点,PhotoViewAttacher本身就实现了OnGestureListener接口,实际的缩放操作是由PhotoViewAttacher完成的,而不是这里声明的各个GestureDetector.</p>
<h3 id="4-2_类关系图">4.2 类关系图</h3><p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/startuml.jpg" alt="PhotoView"></p>
<h3 id="5-_杂谈">5. 杂谈</h3><p>该库唯一缺少的可能是 手势旋转 功能(可以参考QQ). 不过由于PhotoView中已将各级事件分开处理,从架构上来看可扩展性良好,自定义一个RotateGestureDetector来捕获旋转手势也可行.<br>但如何在不与ScaleGestureDetector冲突的情况下完成该功能会稍微有些麻烦.<br>如果不需要手势旋转的话，该库提供了单独的接口可以用代码设置旋转角度。</p>
<h3 id="6-_Matrix补充说明">6. Matrix补充说明</h3><p>Matrix是一个 3x3 矩阵,使用Matrix可以对 Bitmap/Canvas 进行4类基本图形变换,使用起来非常简便，如果你对Matrix的抽象变换不熟悉，还可以使用android.graphics.Camera类进行辅助计算。<br>Camera类可以将矩阵变换抽象成 视点（摄像机） 在三维空间内的移动，更易于直观的理解其效果。</p>
<p>矩阵如下：</p>
<p><img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/matrix.jpg" alt="tranlate"></p>
<p>相关API使用起来非常简单。<br>效果用文字比较难表述，直接看图好了.<br>你也可以自己运行<a href="https://github.com/android-cn/android-open-project-demo/tree/master/photoview-demo/MatrixDemo" target="_blank" rel="external">Demo Project</a></p>
<p>虚影为原始位置，实图为变换后位置.</p>
<h4 id="API">API</h4><ul>
<li><p>public void setTranslate(float dx, float dy)</p>
<p>  对目标进行平移dx,dy</p>
<p>  <img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/tranlate.png" alt="tranlate"></p>
</li>
<li><p>public void setScale(float sx, float sy, float px, float py)</p>
<p>  以(px,py)为中心,横向上缩放比例sx,纵向缩放比例sy</p>
<p>  <img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/scale.png" alt="scale"></p>
</li>
<li><p>public void setRotate(float degrees, float px, float py)</p>
<p>  以(px,py)为中心,旋转degrees度</p>
<p>  <img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/rotate.png" alt="rotate"></p>
</li>
<li><p>public void setSkew(float kx, float ky, float px, float py)</p>
<p>  图像的错切实际上是平面景物在投影平面上的非垂直投影。错切使图像中的图形产生扭变。<br>  这里是以(px,py)为中心,扭曲图片的x轴和y轴.</p>
<p>  这个用文字难以解释,请参考下面的实际效果图片.</p>
<p>  <img src="https://github.com/android-cn/android-open-project-analysis/raw/master/photoview/images/skew.png" alt="skew"></p>
</li>
</ul>
<h4 id="原理">原理</h4><p>如果你对矩阵变换背后的数学原理感兴趣且<code>线性代数</code>的内容没忘光的话，推荐这篇 <a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html" target="_blank" rel="external">文章</a>.</p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 中 PhotoView 部分<br>项目地址：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="external">PhotoView</a>，分析的版本：<a href="https://github.com/chrisbanes/PhotoView/commit/48427bff9bb1a408cfebf6697aa019c0788ded76" target="_blank" rel="external">48427bf</a>，Demo 地址：<a href="https://github.com/android-cn/android-open-project-demo/tree/master/photoview-demo" target="_blank" rel="external">PhotoView-demo</a><br>分析者：<a href="https://github.com/dkmeteor" target="_blank" rel="external">dkmeteor</a>，校对者：<a href="https://github.com/cpacm" target="_blank" rel="external">cpacm</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_功能介绍">1. 功能介绍</h3><h5 id="特性(Features)：">特性(Features)：</h5><ul>
<li>支持Pinch手势自由缩放。</li>
<li>支持双击放大/还原。</li>
<li>支持平滑滚动。</li>
<li>在滑动父控件下能够运行良好。（例如：ViewPager）</li>
<li>支持基于Matrix变化（放大/缩小/移动）的事件监听。]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之责任链模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_chain-of-responsibility/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_chain-of-responsibility/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>一个请求沿着一条“链”传递，直到该“链”上的某个处理者处理它为止。<br><a id="more"></a></p>
<h3 id="模式的使用场景">模式的使用场景</h3><p> 一个请求可以被多个处理者处理或处理者未明确指定时。</p>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/blob/master/chain-of-responsibility/AigeStudio/images/chain-of-responsibility.jpg?raw=true" alt="UML"></p>
<h3 id="角色介绍">角色介绍</h3><p>Client：客户端</p>
<p>Handler：抽象处理者</p>
<p>ConcreteHandler：具体处理者</p>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>责任链模式非常简单异常好理解，相信我它比单例模式还简单易懂，其应用也几乎无所不在，甚至可以这么说……从你敲代码的第一天起你就不知不觉用过了它最原始的裸体结构：分支语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleResponsibility</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> request = (<span class="keyword">int</span>) (Math.random() * <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">switch</span> (request) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			System.out.println(<span class="string">"SMBother handle it: "</span> + request);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			System.out.println(<span class="string">"Aige handle it: "</span> + request);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			System.out.println(<span class="string">"7Bother handle it: "</span> + request);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>谁敢说没用过上面这种结构体的站出来我保证不打屎他，没用过swith至少if-else用过吧，if-else都没用过你怎么知道github的……上面的这段代码其实就是一种最最简单的责任链模式，其根据request的值进行不同的处理。当然这只是个不恰当的例子来让大家尽快对责任链模式有个简单的理解，因为可能很多童鞋第一次听说这个模式，而人对未知事物总是恐惧的，为了消除大家的这种恐惧，我将大家最常见的code搬出来相信熟悉的代码对大家来说有一种亲切的感觉，当然我们实际应用中的责任链模式绝逼不是这么Mr.Simple，但是也不会复杂不到哪去。责任链模式，顾名思义，必定与责任Responsibility相关，其实质呢就像上面定义中说的那样一个请求（比如上面代码中的request值）沿着一条“链”（比如上面代码中我们的switch分支语句）传递，当某个处于“链”上的处理者（case定义的条件）处理它时完成处理。其实现实生活中关于责任者模式的例子数不胜数，最常见的就是工作中上下级之间的责任请求关系了。比如：</p>
<blockquote>
<p>程序猿狗屎运被派出去异国出差一周，这时候就要去申请一定的差旅费了，你心里小算一笔加上各种车马费估计大概要个两三万，于是先向小组长汇报申请，可是大于一千块小组长没权利批复，于是只好去找项目主管，项目主管一看妈蛋这么狠要这么多我只能批小于五千块的，于是你只能再跑去找部门经理，部门经理看了下一阵淫笑后说没法批我只能批小于一万的，于是你只能狗血地去跪求老总，老总一看哟！小伙子心忒黑啊！老总话虽如此但还是把钱批给你了毕竟是给公司办事，到此申请处理完毕，你也可以屁颠屁颠地滚了。</p>
</blockquote>
<p>如果把上面的场景应用到责任链模式，那么我们的request请求就是申请经费，组长主管经理老总们就是一个个具体的责任人他们可以对请求做出处理但是他们只能在自己的责任范围内处理该处理的请求，而程序猿只是个底层狗请求者向责任人们发起请求…………苦逼的猿。</p>
<h3 id="实现源码">实现源码</h3><p>上面的场景我们可以使用使用如下的代码来模拟实现：</p>
<p>首先定义一个程序员类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 程序猿类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramApe</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> expenses;<span class="comment">// 声明整型成员变量表示出差费用</span></span><br><span class="line">	<span class="keyword">private</span> String apply = <span class="string">"爹要点钱出差"</span>;<span class="comment">// 声明字符串型成员变量表示差旅申请</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 含参构造方法</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProgramApe</span><span class="params">(<span class="keyword">int</span> expenses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.expenses = expenses;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 获取程序员具体的差旅费用</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getExpenses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> expenses;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 获取差旅费申请</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> apply;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后依次是各个大爷类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 小组长类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"GroupLeader: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 项目主管类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Director: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 部门经理类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Manager: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 老总类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Boss: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，万事俱备只欠场景，现在我们模拟一下整个场景过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 场景模拟类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费</span><br><span class="line">		 */</span></span><br><span class="line">		ProgramApe ape = <span class="keyword">new</span> ProgramApe((<span class="keyword">int</span>) (Math.random() * <span class="number">30000</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 再来四个老大</span><br><span class="line">		 */</span></span><br><span class="line">		GroupLeader leader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">		Director director = <span class="keyword">new</span> Director();</span><br><span class="line">		Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">		Boss boss = <span class="keyword">new</span> Boss();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 处理申请</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ape.getExpenses() &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">			leader.handleRequest(ape);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ape.getExpenses() &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">			director.handleRequest(ape);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ape.getExpenses() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">			manager.handleRequest(ape);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			boss.handleRequest(ape);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，我的结果输出如下（注：由于随机值的原因你的结果也许与我不一样）：</p>
<blockquote>
<p>爹要点钱出差</p>
<p>Manager: Of course Yes!</p>
</blockquote>
<p>是不是感觉有点懂了？当然上面的代码虽然在一定程度上体现了责任链模式的思想，但是确是非常terrible的。作为一个code新手可以原谅，但是对有一定经验的code+来说就不可饶恕了，很明显所有的老大都有共同的handleRequest方法而程序猿也有不同类型的，比如一个公司的php、c/c++、Android、IOS等等，所有的这些共性我们都可以将其抽象为一个抽象类或接口，比如我们的程序猿抽象父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 程序猿抽象接口</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramApes</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取程序员具体的差旅费用</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@return</span> 要多少钱</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getExpenses</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 获取差旅费申请</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@return</span> Just a request</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getApply</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我们就可以实现该接口使用呆毛具现化一个具体的程序猿，比如Android猿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Android程序猿类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidApe</span> <span class="keyword">extends</span> <span class="title">ProgramApes</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> expenses;<span class="comment">// 声明整型成员变量表示出差费用</span></span><br><span class="line">	<span class="keyword">private</span> String apply = <span class="string">"爹要点钱出差"</span>;<span class="comment">// 声明字符串型成员变量表示差旅申请</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 含参构造方法</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AndroidApe</span><span class="params">(<span class="keyword">int</span> expenses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.expenses = expenses;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getExpenses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> expenses;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> apply;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，所有的老大都有一个批复经费申请的权利，我们把这个权利抽象为一个IPower接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 老大们的权利接口</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPower</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后让所有的老大们实现该接口即可其它不变，而场景类Client中也只是修改各个老大的引用类型为IPower而已，具体代码就不贴了，运行效果也类似。</p>
<p>然而上面的代码依然问题重重，为什么呢？大家想想，当程序猿发出一个申请时却是在场景类中做出判断决定的……然而这个职责事实上应该由老大们来承担并作出决定，上面的代码搞反了……既然知道了错误，那么我们就来再次重构一下代码：</p>
<p>把所有老大抽象为一个leader抽象类，在该抽象类中实现处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 领导人抽象类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> expenses;<span class="comment">// 当前领导能批复的金额</span></span><br><span class="line">	<span class="keyword">private</span> Leader mSuperiorLeader;<span class="comment">// 上级领导</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 含参构造方法</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> expenses</span><br><span class="line">	 *            当前领导能批复的金额</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leader</span><span class="params">(<span class="keyword">int</span> expenses)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.expenses = expenses;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 回应程序猿</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的程序猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ProgramApe ape)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 处理请求</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> ape</span><br><span class="line">	 *            具体的程序猿</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 如果说程序猿申请的money在当前领导的批复范围内</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ape.getExpenses() &lt;= expenses) &#123;</span><br><span class="line">			<span class="comment">// 那么就由当前领导批复即可</span></span><br><span class="line">			reply(ape);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span><br><span class="line">			 * 否则看看当前领导有木有上级</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != mSuperiorLeader) &#123;</span><br><span class="line">				<span class="comment">// 有的话简单撒直接扔给上级处理即可</span></span><br><span class="line">				mSuperiorLeader.handleRequest(ape);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 没有上级的话就批复不了老……不过在这个场景中总会有领导批复的淡定</span></span><br><span class="line">				System.out.println(<span class="string">"Goodbye my money......"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 为当前领导设置一个上级领导</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> superiorLeader</span><br><span class="line">	 *            上级领导</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeader</span><span class="params">(Leader superiorLeader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mSuperiorLeader = superiorLeader;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么一来，我们的领导老大们就有了实实在在的权利职责去处理底层苦逼程序猿的请求。OK，接下来要做的事就是让所有的领导继承该类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 小组长类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"GroupLeader: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 项目主管类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">5000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Director: Of course Yes!"</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 部门经理类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Manager: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 老总类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">40000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reply</span><span class="params">(ProgramApe ape)</span> </span>&#123;</span><br><span class="line">		System.out.println(ape.getApply());</span><br><span class="line">		System.out.println(<span class="string">"Boss: Of course Yes!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，更新我们的场景类，将其从责任人的角色中解放出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 场景模拟类</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> Aige&#123;<span class="doctag">@link</span> https://github.com/AigeStudio&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 先来一个程序猿 这里给他一个三万以内的随机值表示需要申请的差旅费</span><br><span class="line">		 */</span></span><br><span class="line">		ProgramApe ape = <span class="keyword">new</span> ProgramApe((<span class="keyword">int</span>) (Math.random() * <span class="number">30000</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 再来四个老大</span><br><span class="line">		 */</span></span><br><span class="line">		Leader leader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">		Leader director = <span class="keyword">new</span> Director();</span><br><span class="line">		Leader manager = <span class="keyword">new</span> Manager();</span><br><span class="line">		Leader boss = <span class="keyword">new</span> Boss();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * 设置老大的上一个老大</span><br><span class="line">		 */</span></span><br><span class="line">		leader.setLeader(director);</span><br><span class="line">		director.setLeader(manager);</span><br><span class="line">		manager.setLeader(boss);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理申请</span></span><br><span class="line">		leader.handleRequest(ape);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行三次，下面是三次运行的结果（注：由于随机值的原因你的结果也许与我不一样）：</p>
<blockquote>
<p>爹要点钱出差</p>
<p>Boss: Of course Yes!</p>
<hr>
<p>爹要点钱出差</p>
<p>Director: Of course Yes!</p>
<hr>
<p>爹要点钱出差</p>
<p>Boss: Of course Yes!</p>
</blockquote>
<h3 id="总结">总结</h3><p>OK，这样我们就将请求和处理分离开来，对于程序猿来说，不需要知道是谁给他批复的钱，而对于领导们来说，也不需要确切地知道是批给哪个程序猿，只要根据自己的责任做出处理即可，由此将两者优雅地解耦。</p>
<h2 id="Android源码中的模式实现">Android源码中的模式实现</h2><p>Android中关于责任链模式比较明显的体现就是在事件分发过程中对事件的投递，其实严格来说，事件投递的模式并不是严格的责任链模式，但是其是责任链模式的一种变种体现，在ViewGroup中对事件处理者的查找方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略两行代码…………</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略N行代码…………</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * 如果事件未被取消并未被拦截</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">        	<span class="comment">/*</span><br><span class="line">         	 * 如果事件为起始事件</span><br><span class="line">         	 */</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 省掉部分逻辑…………</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span><br><span class="line">         		 * 如果TouchTarget为空并且子元素不为0</span><br><span class="line">         		 */</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = isChildrenDrawingOrderEnabled();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">/*</span><br><span class="line">         		 	* 遍历子元素</span><br><span class="line">         		 	*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder ?</span><br><span class="line">                                getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = children[childIndex];</span><br><span class="line"></span><br><span class="line">                       <span class="comment">/*</span><br><span class="line">         		 		* 如果这个子元素无法接收Pointer Event或这个事件点压根就没有落在子元素的边界范围内</span><br><span class="line">         		 		*/</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 那么就跳出该次循环继续遍历</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到Event该由哪个子元素持有</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">/*</span><br><span class="line">         		 		* 投递事件执行触摸操作</span><br><span class="line">         		 		* 如果子元素还是一个ViewGroup则递归调用重复此过程</span><br><span class="line">         		 		* 如果子元素是一个View那么则会调用View的dispatchTouchEvent并最终由onTouchEvent处理</span><br><span class="line">         		 		*/</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            mLastTouchDownIndex = childIndex;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*</span><br><span class="line"> 		 		* 如果发现没有子元素可以持有该次事件</span><br><span class="line"> 		 		*/</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省去不必要代码……</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省去一行代码……</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看dispatchTransformedTouchEvent方法是如何调度子元素dispatchTouchEvent方法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span><br><span class="line">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 如果事件被取消</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span><br><span class="line">     	* 如果没有子元素</span><br><span class="line">     	*/</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 那么就直接调用父类的dispatchTouchEvent注意这里的父类终会为View类</span></span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果有子元素则传递cancle事件</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 计算即将被传递的点的数量</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 如果事件木有相应的点那么就丢弃该次事件</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明临时变量保存坐标转换后的MotionEvent</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 如果事件点的数量一致</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">    	 * 子元素为空或子元素有一个单位矩阵</span><br><span class="line">    	 */</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">    		 * 再次区分子元素为空的情况</span><br><span class="line">    		 */</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">// 为空则调用父类dispatchTouchEvent</span></span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 否则尝试获取xy方向上的偏移量（如果通过scrollTo或scrollBy对子视图进行滚动的话）</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将MotionEvent进行坐标变换</span></span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 再将变换后的MotionEvent传递给子元素</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复位MotionEvent以便之后再次使用</span></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果通过以上的逻辑判断当前事件被持有则可以直接返回</span></span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 下述雷同不再累赘</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup事件投递的递归调用就类似于一条责任链，一旦其寻找到责任者，那么将由责任者持有并消费掉该次事件，具体的体现在View的onTouchEvent方法中返回值的设置（这里介于篇幅就不具体介绍ViewGroup对事件的处理了），如果onTouchEvent返回false那么意味着当前View不会是该次事件的责任人将不会对其持有，如果为true则相反，此时View会持有该事件并不再向外传递。</p>
<h2 id="4-_杂谈">4. 杂谈</h2><p>世界不是完美的，所以不会有完美的事物存在。就像所有的设计模式一样，  有优点优缺点，但是总的来说优点必定大于缺点或者说缺点相对于优点来说更可控。责任链模式也一样，有点显而易见，可以对请求者和处理者关系的解耦提高代码的灵活性，比如上面我们的例子中如果在主管和经理之间多了一个总监，那么总监可以批复小于7500的经费，这时候根据我们上面重构的模式，仅需新建一个总监类继承Leader即可其它所有的存在类都可保持不变。责任链模式的最大缺点是对链中责任人的遍历，如果责任人太多那么遍历必定会影响性能，特别是在一些递归调用中，要慎重。</p>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中责任链模式分析<br>Android系统版本： 4.4.4<br>分析者：<a href="https://github.com/AigeStudio" target="_blank" rel="external">Aige</a>，分析状态：完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">SM哥</a>，校对状态：撒丫校对中  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>一个请求沿着一条“链”传递，直到该“链”上的某个处理者处理它为止。<br>]]>
    
    </summary>
    
      <category term="责任链模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之桥接模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_bridge/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_bridge/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="模式介绍">模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>将抽象部分与实现部分分离，使它们都可以独立的变化。<br><a id="more"></a></p>
<h3 id="模式的使用场景">模式的使用场景</h3><ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。</li>
<li>需要跨越多个平台的图形和窗口系统上。</li>
<li>一个类存在两个独立变化的维度，且两个维度都需要进行扩展。</li>
</ul>
<h3 id="UML类图">UML类图</h3><p><img src="http://img.blog.csdn.net/20150322120730408" alt="uml"></p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li>抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。<br>修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</li>
<li>实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接 口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
<li>具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。</li>
</ul>
<h2 id="模式的简单实现">模式的简单实现</h2><h3 id="介绍">介绍</h3><p>其实Java的虚拟机就是一个很好的例子，在不同平台平台上，用不同的虚拟机进行实现，这样只需把Java程序编译成符合虚拟机规范的文件，且只用编译一次，便在不同平台上都能工作。 但是这样说比较抽象，用一个简单的例子来实现bridge模式。</p>
<p> 编写一个程序，使用两个绘图的程序的其中一个来绘制矩形或者原型，同时，在实例化矩形的时候，它要知道使用绘图程序1（DP1）还是绘图程序2（DP2）。</p>
<p>(ps:假设dp1和dp2的绘制方式不一样，它们是用不同方式进行绘制，示例代码，不讨论过多细节)</p>
<h3 id="实现源码">实现源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">    首先是两个绘图程序dp1,dp2</span><br><span class="line"><span class="comment">//具体的绘图程序类dp1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DP1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw_1_Rantanle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用DP1的程序画矩形"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw_1_Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用DP1的程序画圆形"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的绘图程序类dp2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DP2</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRantanle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用DP2的程序画矩形"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用DP2的程序画圆形"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">接着​抽象的形状Shape和两个派生类：矩形Rantanle和圆形Circle</span><br><span class="line"><span class="comment">//抽象化角色Abstraction</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="comment">//持有实现的角色Implementor(作图类)</span></span><br><span class="line">	<span class="keyword">protected</span> Drawing myDrawing;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(Drawing drawing)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myDrawing = drawing;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保护方法drawRectangle</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//this.impl.implmentation()</span></span><br><span class="line">		myDrawing.drawRantangle();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//保护方法drawCircle</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//this.impl.implmentation()</span></span><br><span class="line">		myDrawing.drawCircle();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修正抽象化角色Refined Abstraction(矩形)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rantangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rantangle</span><span class="params">(Drawing drawing)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(drawing);</span><br><span class="line">	&#125;</span><br><span class="line">     </span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		drawRectangle();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修正抽象化角色Refined Abstraction(圆形)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Drawing drawing)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(drawing);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		drawCircle();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">最后，我们的实现绘图的Drawing和分别实现dp1的V1Drawing和dp2的V2Drawing</span><br><span class="line"><span class="comment">//实现化角色Implementor</span></span><br><span class="line"><span class="comment">//implmentation两个方法，画圆和画矩形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRantangle</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化逻辑ConcreteImplementor</span></span><br><span class="line"><span class="comment">//实现了接口方法，使用DP1进行绘图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V1Drawing</span> <span class="keyword">implements</span> <span class="title">Drawing</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	DP1 dp1;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">V1Drawing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp1 = <span class="keyword">new</span> DP1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRantangle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp1.draw_1_Rantanle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp1.draw_1_Circle();</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体实现化逻辑ConcreteImplementor</span></span><br><span class="line"><span class="comment">//实现了接口方法，使用DP2进行绘图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">V2Drawing</span> <span class="keyword">implements</span> <span class="title">Drawing</span></span>&#123;</span><br><span class="line">	DP2 dp2;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">V2Drawing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp2 = <span class="keyword">new</span> DP2();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRantangle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp2.drawRantanle();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		dp2.drawCircle();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​在这个示例中，图形Shape类有两种类型，圆形和矩形，为了使用不同的绘图程序绘制图形，把实现的部分进行了分离，构成了Drawing类层次结构，包括V1Drawing和V2Drawing。在具体实现类中，V1Drawing控制着DP1程序进行绘图，V2Drawing控制着DP2程序进行绘图，以及保护的方法drawRantangle,drawCircle(Shape类中) 。</p>
<h2 id="Android源码中的模式实现">Android源码中的模式实现</h2><p>在Android中也运用到了Bridge模式，我们使用很多的ListView和BaseAdpater其实就是Bridge模式的运行，很多人会问这个不是Adapter模式，接下来根据源码来分析。</p>
<p>首先ListAdapter.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListAdapter</span> <span class="keyword">extends</span> <span class="title">Adapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承自Adapter，扩展了自己的两个实现方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areAllItemsEnabled</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(<span class="keyword">int</span> position)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先来看一下父类AdapterView。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterView</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Adapter</span>&gt; <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里需要一个泛型的Adapter</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">getAdapter</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(T adapter)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看ListView的父类AbsListView，继承自AdapterView</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsListView</span> <span class="keyword">extends</span> <span class="title">AdapterView</span>&lt;<span class="title">ListAdapter</span>&gt;   </span><br><span class="line">    //继承自<span class="title">AdapterView</span>,并且指明了<span class="title">T</span>为<span class="title">ListAdapter</span></span><br><span class="line">    /**</span><br><span class="line">     * <span class="title">The</span> <span class="title">adapter</span> <span class="title">containing</span> <span class="title">the</span> <span class="title">data</span> <span class="title">to</span> <span class="title">be</span> <span class="title">displayed</span> <span class="title">by</span> <span class="title">this</span> <span class="title">view</span></span><br><span class="line">     */</span><br><span class="line">    <span class="title">ListAdapter</span> <span class="title">mAdapter</span></span>;  </span><br><span class="line">    <span class="comment">//代码省略</span></span><br><span class="line">    <span class="comment">//这里实现了setAdapter的方法，实例了对实现化对象的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这的adapter是从子类传入上来，也就是listview，拿到了具体实现化的对象</span></span><br><span class="line">        <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAdapterHasStableIds = mAdapter.hasStableIds();</span><br><span class="line">            <span class="keyword">if</span> (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mAdapterHasStableIds &amp;&amp;</span><br><span class="line">                    mCheckedIdStates == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCheckedIdStates = <span class="keyword">new</span> LongSparseArray&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCheckStates != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCheckStates.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mCheckedIdStates != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCheckedIdStates.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大家都知道，构建一个listview，adapter中最重要的两个方法，getCount()告知数量，getview()告知具体的view类型，接下来看看AbsListView作为一个视图的集合是如何来根据实现化对象adapter来实现的具体的view呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">     </span><br><span class="line">         <span class="comment">//省略代码，</span></span><br><span class="line">         <span class="comment">//这里在加入window的时候，getCount()确定了集合的个数</span></span><br><span class="line">         mDataChanged = <span class="keyword">true</span>;</span><br><span class="line">         mOldItemCount = mItemCount;</span><br><span class="line">         mItemCount = mAdapter.getCount();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>接着来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] isScrap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//代码省略</span></span><br><span class="line">     ​<span class="comment">//这里根据位置显示具体的view,return的child是从持有的实现对象mAdapter里面的具体实现的</span></span><br><span class="line">     ​<span class="comment">//方法getview来得到的。</span></span><br><span class="line">       <span class="keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">//代码省略</span></span><br><span class="line">       <span class="keyword">return</span> child;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来在ListView中，onMeasure调用了obtainView来确定宽高，在扩展自己的方法来排列这些view。知道了</p>
<p>这些以后，我们来画一个简易的UML图来看下:</p>
<p><img src="http://img.blog.csdn.net/20150322120809221" alt="uml"></p>
<p>对比下GOF的上图，是不是发现很像呢？实际上最开始研究Adapter模式的时候,越看越不对啊，于是整理结构，画了UML发现这更像是一个bridge模式，那时候对设计模式也是模模糊糊的，于是静下来研究。抽象化的角色一个视图的集合AdapterView，它扩展了AbsListView，AbsSpinner，接下来他们分别扩展了ListView，GridView，Spinner,Gallery，用不同方式来展现这些ItemViews，我们继续扩展类似ListView的PulltoRefreshView等等。而实现化角色Adapter扩展了ListAdpater,SpinnerAdapter，接着具体的实现化角色BaseAdapter实现了他们，我们通过继承BaseAdapter又实现了我们各式各样的ItemView。</p>
<h2 id="杂谈">杂谈</h2><p>这里就是Android工程师的牛X之处了，用一个bridge和adapter来解决了一个大的难题。试想一下，视图的排列方式是无穷尽，是人们每个人开发的视图也是无穷尽的。如果你正常开发，你需要多少类来完成呢？而Android把最常用用的展现方式全部都封装了出来，而在实现角色通过Adapter模式来应变无穷无尽的视图需要。抽象化了一个容器使用适配器来给容器里面添加视图，容器的形状(或理解为展现的方式)以及怎么样来绘制容器内的视图，你都可以独自的变化，双双不会干扰，真正的脱耦，就要最开始说的那样：“将抽象部分与实现部分分离，使它们都可以独立的变化。”</p>
<p>从上面的两个案例，我们可以看出，我们在两个解决方案中都用到bridge和adapter模式，那是因为我们必须使用给定的绘图程序(adapter适配器)，绘图程序(adapter适配器)有已经存在的接口必须要遵循，因此需要使用Adapter进行适配，然后才能用同样的方式处理他们,他们经常一起使用，并且相似，但是Adapter并不是Bridge的一部分。</p>
<h3 id="优点与缺点">优点与缺点</h3><p>实现与使用实现的对象解耦，提供了可扩展性，客户对象无需担心操作的实现问题。  如果你采用了bridge模式，在处理新的实现将会非常容易。你只需定义一个新的具体实现类，并且实现它就好了，不需要修改任何其他的东西。但是如果你出现了一个新的具体情况，需要对实现进行修改时，就得先修改抽象的接口，再对其派生类进行修改，但是这种修改只会存在于局部,并且这种修改将变化的英雄控制在局部，并且降低了出现副作用的风险，而且类之间的关系十分清晰，如何实现一目了然。</p>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中 桥接模式 分析<br>Android系统版本： 4.2<br>分析者：<a href="https://github.com/shen0834" target="_blank" rel="external">shen0834</a>，分析状态：未完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="模式介绍">模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>将抽象部分与实现部分分离，使它们都可以独立的变化。<br>]]>
    
    </summary>
    
      <category term="桥接模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之Builder模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_binder/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_binder/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:57:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br><a id="more"></a></p>
<h3 id="模式的使用场景">模式的使用场景</h3><ol>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时；   </li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适；</li>
</ol>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/blob/master/builder/mr.simple/images/builder-uml.png" alt="url">  </p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li>Product 产品类 :  产品的抽象类。</li>
<li>Builder : 抽象类， 规范产品的组建，一般是由子类实现具体的组件过程。</li>
<li>ConcreteBuilder : 具体的构建器.</li>
<li>Director : 统一组装过程(可省略)。</li>
</ul>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>电脑的组装过程较为复杂，步骤繁多，但是顺序却是不固定的。下面我们以组装电脑为例来演示一下简单且经典的builder模式。</p>
<h3 id="实现源码">实现源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Computer产品抽象类, 为了例子简单, 只列出这几个属性</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> mCpuCore = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> mRamSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">protected</span> String mOs = <span class="string">"Dos"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置CPU核心数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setCPU</span><span class="params">(<span class="keyword">int</span> core)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置内存</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setRAM</span><span class="params">(<span class="keyword">int</span> gb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置操作系统</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">(String os)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Computer [mCpuCore="</span> + mCpuCore + <span class="string">", mRamSize="</span> + mRamSize</span><br><span class="line">				+ <span class="string">", mOs="</span> + mOs + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Apple电脑</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">AppleComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCPU</span><span class="params">(<span class="keyword">int</span> core)</span> </span>&#123;</span><br><span class="line">		mCpuCore = core;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRAM</span><span class="params">(<span class="keyword">int</span> gb)</span> </span>&#123;</span><br><span class="line">		mRamSize = gb;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">(String os)</span> </span>&#123;</span><br><span class="line">		mOs = os;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * builder抽象类</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 设置CPU核心数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">(<span class="keyword">int</span> core)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置内存</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildRAM</span><span class="params">(<span class="keyword">int</span> gb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置操作系统</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOs</span><span class="params">(String os)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Computer</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplePCBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Computer mApplePc = <span class="keyword">new</span> AppleComputer();</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">(<span class="keyword">int</span> core)</span> </span>&#123;</span><br><span class="line">		mApplePc.setCPU(core);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRAM</span><span class="params">(<span class="keyword">int</span> gb)</span> </span>&#123;</span><br><span class="line">		mApplePc.setRAM(gb);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOs</span><span class="params">(String os)</span> </span>&#123;</span><br><span class="line">		mApplePc.setOs(os);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mApplePc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">	Builder mBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> builder</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">		mBuilder = builder;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 构建对象</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@param</span> cpu</span><br><span class="line">	 * <span class="doctag">@param</span> ram</span><br><span class="line">	 * <span class="doctag">@param</span> os</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">int</span> cpu, <span class="keyword">int</span> ram, String os)</span> </span>&#123;</span><br><span class="line">		mBuilder.buildCPU(cpu);</span><br><span class="line">		mBuilder.buildRAM(ram);</span><br><span class="line">		mBuilder.buildOs(os);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 经典实现较为繁琐</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 构建器</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> ApplePCBuilder();</span><br><span class="line">		<span class="comment">// Director</span></span><br><span class="line">		Director pcDirector = <span class="keyword">new</span> Director(builder);</span><br><span class="line">		<span class="comment">// 封装构建过程, 4核, 内存2GB, Mac系统</span></span><br><span class="line">		pcDirector.construct(<span class="number">4</span>, <span class="number">2</span>, <span class="string">"Mac OS X 10.9.1"</span>);</span><br><span class="line">		<span class="comment">// 构建电脑, 输出相关信息</span></span><br><span class="line">		System.out.println(<span class="string">"Computer Info : "</span> + builder.create().toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Builder来构建产品对象, 而Director封装了构建复杂产品对象对象的过程，不对外隐藏构建细节。</p>
<h2 id="Android源码中的模式实现">Android源码中的模式实现</h2><p>在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示基本的AlertDialog  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showDialog</span><span class="params">(Context context)</span> </span>&#123;  </span><br><span class="line">    AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(context);  </span><br><span class="line">    builder.setIcon(R.drawable.icon);  </span><br><span class="line">    builder.setTitle(<span class="string">"Title"</span>);  </span><br><span class="line">    builder.setMessage(<span class="string">"Message"</span>);  </span><br><span class="line">    builder.setPositiveButton(<span class="string">"Button1"</span>,  </span><br><span class="line">            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whichButton)</span> </span>&#123;  </span><br><span class="line">                    setTitle(<span class="string">"点击了对话框上的Button1"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.setNeutralButton(<span class="string">"Button2"</span>,  </span><br><span class="line">            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whichButton)</span> </span>&#123;  </span><br><span class="line">                    setTitle(<span class="string">"点击了对话框上的Button2"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.setNegativeButton(<span class="string">"Button3"</span>,  </span><br><span class="line">            <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> whichButton)</span> </span>&#123;  </span><br><span class="line">                    setTitle(<span class="string">"点击了对话框上的Button3"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.create().show();  <span class="comment">// 构建AlertDialog， 并且显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 :<br><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/builder/mr.simple/images/result.png" alt="result">     </p>
<p>下面我们看看AlertDialog的相关源码 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlertDialog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Controller, 接受Builder成员变量P中的各个参数</span></span><br><span class="line">    <span class="keyword">private</span> AlertController mAlert;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AlertDialog</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, theme, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 : 构造AlertDialog</span></span><br><span class="line">    AlertDialog(Context context, <span class="keyword">int</span> theme, <span class="keyword">boolean</span> createContextWrapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, resolveDialogTheme(context, theme), createContextWrapper);</span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = <span class="keyword">new</span> AlertController(getContext(), <span class="keyword">this</span>, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上调用的是mAlert的setTitle方法</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setTitle(title);</span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上调用的是mAlert的setCustomTitle方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomTitle</span><span class="params">(View customTitleView)</span> </span>&#123;</span><br><span class="line">        mAlert.setCustomTitle(customTitleView);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AlertDialog其他的代码省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ************  Builder为AlertDialog的内部类   *******************</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 : 存储AlertDialog的各个参数, 例如title, message, icon等.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line">        <span class="comment">// 属性省略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constructor using a context for this builder and the &#123;<span class="doctag">@link</span> AlertDialog&#125; it creates.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(context, resolveDialogTheme(context, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Context context, <span class="keyword">int</span> theme)</span> </span>&#123;</span><br><span class="line">            P = <span class="keyword">new</span> AlertController.AlertParams(<span class="keyword">new</span> ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, theme)));</span><br><span class="line">            mTheme = theme;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Builder的其他代码省略 ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 : 设置各种参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">            P.mTitle = title;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">            P.mMessage = message;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setIcon</span><span class="params">(<span class="keyword">int</span> iconId)</span> </span>&#123;</span><br><span class="line">            P.mIconId = iconId;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPositiveButton</span><span class="params">(CharSequence text, <span class="keyword">final</span> OnClickListener listener)</span> </span>&#123;</span><br><span class="line">            P.mPositiveButtonText = text;</span><br><span class="line">            P.mPositiveButtonListener = listener;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            P.mView = view;</span><br><span class="line">            P.mViewSpacingSpecified = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 : 构建AlertDialog, 传递参数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog </span></span><br><span class="line">            <span class="keyword">final</span> AlertDialog dialog = <span class="keyword">new</span> AlertDialog(P.mContext, mTheme, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 5 : 将P中的参数应用的dialog中的mAlert对象中</span></span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            <span class="keyword">if</span> (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            <span class="keyword">if</span> (P.mOnKeyListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过Builder来设置AlertDialog中的title, message, button等参数， 这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 : </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(AlertController dialog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCustomTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIcon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIconId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconAttrId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setMessage(mMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPositiveButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                mPositiveButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNegativeButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                mNegativeButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNeutralButtonText != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                mNeutralButtonListener, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mForceInverseBackground) &#123;</span><br><span class="line">        dialog.setInverseBackgroundForced(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For a list, the client can either supply an array of items or an</span></span><br><span class="line">    <span class="comment">// adapter or a cursor</span></span><br><span class="line">    <span class="keyword">if</span> ((mItems != <span class="keyword">null</span>) || (mCursor != <span class="keyword">null</span>) || (mAdapter != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        createListView(dialog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewSpacingSpecified) &#123;</span><br><span class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                    mViewSpacingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dialog.setView(mView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。       </p>
<h2 id="4-_杂谈">4. 杂谈</h2><h3 id="优点与缺点">优点与缺点</h3><h4 id="优点">优点</h4><ul>
<li>良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节；</li>
<li>建造者独立，容易扩展；</li>
<li>在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>会产生多余的Builder对象以及Director对象，消耗内存；</li>
<li>对象的构建过程暴露。 </li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中 Builder模式 分析<br>Android系统版本： 2.3<br>分析者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，分析状态：完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>]]>
    
    </summary>
    
      <category term="Builder模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Builder%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之Java 注解 Annotation]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android-open-project-analysis_annotation/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android-open-project-analysis_annotation/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:58:18.000Z</updated>
    <content type="html"><![CDATA[<p>不少开源库都用到了注解的方式来简化代码提高开发效率。<br>本文简单介绍下 <strong>Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析</strong>。<br> <a id="more"></a></p>
<h3 id="1-_Annotation_示例">1. Annotation 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Override Annotation  </span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br><span class="line">Retrofit Annotation  </span><br><span class="line"></span><br><span class="line">    <span class="annotation">@GET</span>(<span class="string">"/users/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line">Butter Knife Annotation  </span><br><span class="line"></span><br><span class="line">    <span class="annotation">@InjectView</span>(R.id.user) EditText username;</span><br><span class="line">ActiveAndroid Annotation  </span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Column</span>(name = “Name<span class="string">") public String name;</span></span><br></pre></td></tr></table></figure>
<p>Retrofit 为符合 RESTful 规范的网络请求框架<br>Butter Knife 为 View 及事件等依赖注入框架<br>Active Android 为 ORM 框架<br>更多见：<a href="https://github.com/Trinea/android-open-project" target="_blank" rel="external">Android 开源项目汇总</a>  </p>
<h3 id="2-_Annotation_概念及作用">2. Annotation 概念及作用</h3><h4 id="2-1_概念">2.1 概念</h4><blockquote>
<p>An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.  </p>
</blockquote>
<p>能够添加到 Java 源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据与程序元素进行关联。Annotation 中文常译为“注解”。  </p>
<h4 id="2-2_作用">2.2 作用</h4><p>a. 标记，用于告诉编译器一些信息<br>b. 编译时动态处理，如动态生成代码<br>c. 运行时动态处理，如得到注解信息<br>这里的三个作用实际对应着后面自定义 Annotation 时说的 @Retention 三种值分别表示的 Annotation   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.id == id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Set&lt;Person&gt; set = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            set.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"Jim"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的运行结果是多少？  </p>
<h3 id="3-_Annotation_分类">3. Annotation 分类</h3><h4 id="3-1_标准_Annotation，Override,_Deprecated,_SuppressWarnings">3.1 标准 Annotation，Override, Deprecated, SuppressWarnings</h4><p>标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning  </p>
<h4 id="3-2_元_Annotation，@Retention,_@Target,_@Inherited,_@Documented">3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented</h4><p>元 Annotation 是指用来定义 Annotation 的 Annotation，在后面 Annotation 自定义部分会详细介绍含义  </p>
<h4 id="3-3_自定义_Annotation">3.3 自定义 Annotation</h4><p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation<br>这里是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation，后面在自定义 Annotation 时会具体介绍  </p>
<h3 id="4-_Annotation_自定义">4. Annotation 自定义</h3><h4 id="4-1_调用">4.1 调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@MethodInfo</span>(</span><br><span class="line">        author = “trinea.cn+android<span class="annotation">@gmail</span>.com”,</span><br><span class="line">        date = <span class="string">"2014/02/14"</span>,</span><br><span class="line">        version = <span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"trinea"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是调用自定义 Annotation——MethodInfo 的示例。<br>MethodInfo Annotation 作用为给方法添加相关信息，包括 author、date、version。  </p>
<h4 id="4-2_定义">4.2 定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MethodInfo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "trinea@gmail.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是 MethodInfo 的实现部分<br>(1). 通过 @interface 定义，注解名即为自定义注解名<br>(2). 注解配置参数名为注解类的方法名，且：<br>a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public ，不允许抛异常<br>b. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组<br>c. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation<br>(3). 可以加 default 表示默认值  </p>
<h4 id="4-3_元_Annotation">4.3 元 Annotation</h4><p>@Documented 是否会保存到 Javadoc 文档中<br>@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings<br>@Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有<br>@Inherited 是否可以被继承，默认为 false  </p>
<h3 id="5-_Annotation_解析">5. Annotation 解析</h3><h4 id="5-1_运行时_Annotation_解析">5.1 运行时 Annotation 解析</h4><p>(1) 运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method.getAnnotation(AnnotationName.class);</span><br><span class="line">method.getAnnotations();</span><br><span class="line">method.isAnnotationPresent(AnnotationName.class);</span><br></pre></td></tr></table></figure>
<p>其他 @Target 如 Field，Class 方法类似<br>getAnnotation(AnnotationName.class) 表示得到该 Target 某个 Annotation 的信息，因为一个 Target 可以被多个 Annotation 修饰<br>getAnnotations() 则表示得到该 Target 所有 Annotation<br>isAnnotationPresent(AnnotationName.class) 表示该 Target 是否被某个 Annotation 修饰<br>(2) 解析示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class cls = Class.forName(<span class="string">"cn.trinea.java.test.annotation.App"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method method : cls.getMethods()) &#123;</span><br><span class="line">            MethodInfo methodInfo = method.getAnnotation(</span><br><span class="line">MethodInfo.class);</span><br><span class="line">            <span class="keyword">if</span> (methodInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"method name:"</span> + method.getName());</span><br><span class="line">                System.out.println(<span class="string">"method author:"</span> + methodInfo.author());</span><br><span class="line">                System.out.println(<span class="string">"method version:"</span> + methodInfo.version());</span><br><span class="line">                System.out.println(<span class="string">"method date:"</span> + methodInfo.date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以之前自定义的 MethodInfo 为例，利用 Target（这里是 Method）getAnnotation 函数得到 Annotation 信息，然后就可以调用 Annotation 的方法得到响应属性值  </p>
<h4 id="5-2_编译时_Annotation_解析">5.2 编译时 Annotation 解析</h4><p>(1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，甴编译器自动解析。需要做的<br>a. 自定义类集成自 AbstractProcessor<br>b. 重写其中的 process 函数<br>这块很多同学不理解，实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理<br>(2) 假设 MethodInfo 的 @Retention 为 CLASS，解析示例如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SupportedAnnotationTypes</span>(&#123; <span class="string">"cn.trinea.java.test.annotation.MethodInfo"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInfoProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);</span><br><span class="line">                map.put(element.getEnclosingElement().toString(), methodInfo.author());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。<br>process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境<br>process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理  </p>
<h3 id="6-_几个_Android_开源库_Annotation_原理简析">6. 几个 Android 开源库 Annotation 原理简析</h3><h4 id="6-1_Annotation_—_Retrofit">6.1 Annotation — Retrofit</h4><p>(1) 调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"/users/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure></p>
<p>(2) 定义  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Target</span>(METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="annotation">@RestMethod</span>(<span class="string">"GET"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> GET &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method<br>(3) 原理  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseMethodAnnotations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType = methodAnnotation.annotationType();</span><br><span class="line">    RestMethod methodInfo = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (Annotation innerAnnotation : annotationType.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RestMethod.class == innerAnnotation.annotationType()) &#123;</span><br><span class="line">            methodInfo = (RestMethod) innerAnnotation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit/RestMethodInfo.java" target="_blank" rel="external">RestMethodInfo.java</a> 的 parseMethodAnnotations 方法如上，会检查每个方法的每个 Annotation， 看是否被 RestMethod 这个 Annotation 修饰的 Annotation 修饰，这个有点绕，就是是否被 GET、DELETE、POST、PUT、HEAD、PATCH 这些 Annotation 修饰，然后得到 Annotation 信息，在对接口进行动态代理时会掉用到这些 Annotation 信息从而完成调用。  </p>
<p>Retrofit 原理涉及到<a href="http://codekk.com/open-source-project-analysis/detail/Android/Caij/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8BJava%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" target="_blank" rel="external">动态代理</a>，这里原理都只介绍 Annotation，具体原理分析请见 <a href="http://www.codekk.com" target="_blank" rel="external">Android 开源项目实现原理解析</a>   </p>
<h4 id="6-2_Annotation_—_Butter_Knife">6.2 Annotation — Butter Knife</h4><p>(1) 调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@InjectView</span>(R.id.user) </span><br><span class="line">EditText username;</span><br></pre></td></tr></table></figure></p>
<p>(2) 定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(CLASS) </span><br><span class="line"><span class="annotation">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> InjectView &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可看出 Butter Knife 的 InjectView Annotation 是编译时 Annotation，并且只能用于修饰属性<br>(3) 原理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        TypeElement typeElement = entry.getKey();</span><br><span class="line">        ViewInjector viewInjector = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);</span><br><span class="line">            Writer writer = jfo.openWriter();</span><br><span class="line">            writer.write(viewInjector.brewJava());</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            error(typeElement, <span class="string">"Unable to write injector for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/JakeWharton/butterknife/blob/master/butterknife/src/main/java/butterknife/internal/ButterKnifeProcessor.java" target="_blank" rel="external">ButterKnifeProcessor.java</a> 的 process 方法如上，编译时，在此方法中过滤 InjectView 这个 Annotation 到 targetClassMap 后，会根据 targetClassMap 中元素生成不同的 class 文件到最终的 APK 中，然后在运行时调用 ButterKnife.inject(x) 函数时会到之前编译时生成的类中去找。<br>这里原理都只介绍 Annotation，具体原理分析请见 <a href="http://www.codekk.com" target="_blank" rel="external">Android 开源项目实现原理解析</a>   </p>
<h4 id="6-3_Annotation_—_ActiveAndroid">6.3 Annotation — ActiveAndroid</h4><p>(1) 调用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Column(name = “Name") </span><br><span class="line">public String name;</span><br></pre></td></tr></table></figure></p>
<p>(2) 定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Column &#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可看出 ActiveAndroid 的 Column Annotation 是运行时 Annotation，并且只能用于修饰属性。<br>(3) 原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Field idField = getIdField(type);</span><br><span class="line">mColumnNames.put(idField, mIdName);</span><br><span class="line"></span><br><span class="line">List&lt;Field&gt; fields = <span class="keyword">new</span> LinkedList&lt;Field&gt;(ReflectionUtils.getDeclaredColumnFields(type));</span><br><span class="line">Collections.reverse(fields);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (field.isAnnotationPresent(Column.class)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Column columnAnnotation = field.getAnnotation(Column.class);</span><br><span class="line">        String columnName = columnAnnotation.name();</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(columnName)) &#123;</span><br><span class="line">            columnName = field.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mColumnNames.put(field, columnName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/pardom/ActiveAndroid/blob/master/src/com/activeandroid/TableInfo.java" target="_blank" rel="external">TableInfo.java</a> 的构造函数如上，运行时，得到所有行信息并存储起来用来构件表信息。  </p>
<p>这里原理都只介绍 Annotation，具体原理分析请见 <a href="http://www.codekk.com" target="_blank" rel="external">Android 开源项目实现原理解析</a>   </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不少开源库都用到了注解的方式来简化代码提高开发效率。<br>本文简单介绍下 <strong>Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析</strong>。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之模板方法模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_template_method/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_template_method/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:58:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><a id="more"></a></p>
<h3 id="模式的使用场景">模式的使用场景</h3><ol>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li>
</ol>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/template-method/mr.simple/images/uml.png" alt="url">  </p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li>AbstractClass : 抽象类，定义了一套算法框架。 </li>
<li>ConcreteClass1 : 具体实现类1；</li>
<li>ConcreteClass2： 具体实现类2；</li>
</ul>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>模板方法实际上是封装一个算法框架，就像是一套模板一样。而子类可以有不同的算法实现，在框架不被修改的情况下实现算法的替换。下面我们以开电脑这个动作来简单演示一下模板方法。开电脑的整个过程都是相对稳定的，首先打开电脑电源，电脑检测自身状态没有问题时将进入操作系统，对用户进行验证之后即可登录电脑，下面我们使用模板方法来模拟一下这个过程。 </p>
<h3 id="实现源码">实现源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 抽象的Computer</span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启电源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"硬件检查"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"载入操作系统"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小白的电脑无验证，直接进入系统"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 启动电脑方法, 步骤固定为开启电源、系统检查、加载操作系统、用户登录。该方法为final， 防止算法框架被覆写.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------ 开机 START ------"</span>);</span><br><span class="line">        powerOn();</span><br><span class="line">        checkHardware();</span><br><span class="line">        loadOS();</span><br><span class="line">        login();</span><br><span class="line">        System.out.println(<span class="string">"------ 开机 END ------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 码农的计算机</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoderComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"码农只需要进行用户和密码验证就可以了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 军用计算机</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilitaryComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.checkHardware();</span><br><span class="line">        System.out.println(<span class="string">"检查硬件防火墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行指纹之别等复杂的用户验证"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractComputer comp = <span class="keyword">new</span> CoderComputer();</span><br><span class="line">        comp.startUp();</span><br><span class="line"></span><br><span class="line">        comp = <span class="keyword">new</span> MilitaryComputer();</span><br><span class="line">        comp.startUp();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">输出结果如下 :</span><br></pre></td></tr></table></figure>
<p>——— 开机 START ———<br>开启电源<br>硬件检查<br>载入操作系统<br>码农只需要进行用户和密码验证就可以了<br>——— 开机 END ———<br>——— 开机 START ———<br>开启电源<br>硬件检查<br>检查硬件防火墙<br>载入操作系统<br>进行指纹之别等复杂的用户验证<br>——— 开机 END ———<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">通过上面的例子可以看到，在startUp方法中有一些固定的步骤，依次为开启电源、检查硬件、加载系统、用户登录四个步骤，这四个步骤是电脑开机过程中不会变动的四个过程。但是不同用户的这几个步骤的实现可能各不相同，因此他们可以用不同的实现。而startUp为final方法，即保证了算法框架不能修改，具体算法实现却可以灵活改变。startUp中的这几个算法步骤我们可以称为是一个套路，即可称为模板方法。因此，模板方法是定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。如图 :    </span><br><span class="line"></span><br><span class="line">![flow](https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/<span class="keyword">template</span>-<span class="keyword">method</span>/mr.simple/images/flow.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Android源码中的模式实现</span></span><br><span class="line">在<span class="type">Android</span>中，使用了模板方法且为我们熟知的一个典型类就是<span class="type">AsyncTask</span>了，关于<span class="type">AsyncTask</span>的更详细的分析请移步<span class="type">Android</span>中<span class="type">AsyncTask</span>的使用与源码分析，我们这里只分析在该类中使用的模板方法模式。     </span><br><span class="line"></span><br><span class="line">在使用<span class="type">AsyncTask</span>时，我们都有知道耗时的方法要放在doInBackground(<span class="type">Params</span>... params)中，在doInBackground之前如果还想做一些类似初始化的操作可以写在onPreExecute方法中，当doInBackground方法执行完成后，会执行onPostExecute方法，而我们只需要构建<span class="type">AsyncTask</span>对象，然后执行execute方法即可。我们可以看到，它整个执行过程其实是一个框架，具体的实现都需要子类来完成。而且它执行的算法框架是固定的，调用execute后会依次执行onPreExecute,doInBackground,onPostExecute,当然你也可以通过onProgressUpdate来更新进度。我们可以简单的理解为如下图的模式  :</span><br><span class="line">	</span><br><span class="line">![async-flow](images/async-flow.png)	   </span><br><span class="line"></span><br><span class="line">下面我们看源码，首先我们看执行异步任务的入口, 即execute方法 :     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> public final <span class="type">AsyncTask</span>&lt;<span class="type">Params</span>, <span class="type">Progress</span>, <span class="type">Result</span>&gt; execute(<span class="type">Params</span>... params) &#123;</span><br><span class="line">        <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final <span class="type">AsyncTask</span>&lt;<span class="type">Params</span>, <span class="type">Progress</span>, <span class="type">Result</span>&gt; executeOnExecutor(<span class="type">Executor</span> exec,</span><br><span class="line">            <span class="type">Params</span>... params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStatus != <span class="type">Status</span>.<span class="type">PENDING</span>) &#123;</span><br><span class="line">            switch (mStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">RUNNING</span>:</span><br><span class="line">                    throw new <span class="type">IllegalStateException</span>(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task is already running."</span>);</span><br><span class="line">                <span class="keyword">case</span> <span class="type">FINISHED</span>:</span><br><span class="line">                    throw new <span class="type">IllegalStateException</span>(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStatus = <span class="type">Status</span>.<span class="type">RUNNING</span>;</span><br><span class="line"></span><br><span class="line">        onPreExecute();</span><br><span class="line"></span><br><span class="line">        mWorker.mParams = params;</span><br><span class="line">        exec.execute(mFuture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到execute方法(为final类型的方法)调用了executeOnExecutor方法，在该方法中会判断该任务的状态，如果不是PENDING状态则抛出异常，这也解释了为什么AsyncTask只能被执行一次，因此如果该任务已经被执行过的话那么它的状态就会变成FINISHED。继续往下看，我们看到在executeOnExecutor方法中首先执行了onPreExecute方法，并且该方法执行在UI线程。然后将params参数传递给了mWorker对象的mParams字段，然后执行了exec.execute(mFuture)方法。        </p>
<p>mWorker和mFuture又是什么呢？其实mWorker只是实现了Callable接口，并添加了一个参数数组字段，关于Callable和FutureTask的资料请参考<a href="http://blog.csdn.net/bboyfeiyu/article/details/24851847" target="_blank" rel="external">Java中的Runnable、Callable、Future、FutureTask的区别与示例</a>，我们挨个来分析吧，跟踪代码我们可以看到，这两个字段都是在构造函数中初始化。</p>
<pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>{
     mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() {
         <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
             mTaskInvoked.set(<span class="keyword">true</span>);

             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
             <span class="keyword">return</span> postResult(doInBackground(mParams));
         }
     };

     mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) {
         <span class="annotation">@Override</span>
         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>{
             <span class="keyword">try</span> {
                 <span class="keyword">final</span> Result result = get();

                 postResultIfNotInvoked(result);
             } <span class="keyword">catch</span> (InterruptedException e) {
                 android.util.Log.w(LOG_TAG, e);
             } <span class="keyword">catch</span> (ExecutionException e) {
                 <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,
                         e.getCause());
             } <span class="keyword">catch</span> (CancellationException e) {
                 postResultIfNotInvoked(<span class="keyword">null</span>);
             } <span class="keyword">catch</span> (Throwable t) {
                 <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing "</span>
                         + <span class="string">"doInBackground()"</span>, t);
             }
         }
     };
 }
</code></pre>
<p>简单的说就是mFuture就包装了这个mWorker对象，会调用mWorker对象的call方法，并且将之返回给调用者。<br>    关于AsyncTask的更详细的分析请移步<a href="http://blog.csdn.net/bboyfeiyu/article/details/8973058" target="_blank" rel="external">Android中AsyncTask的使用与源码分析</a>，我们这里只分析模板方法模式。总之，call方法会在子线程中调用，而在call方法中又调用了doInBackground方法，因此doInBackground会执行在子线程。doInBackground会返回结果，最终通过postResult投递给UI线程。<br>    我们再看看postResult的实现 :     </p>
<pre><code class="java"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>{
    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,
            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));
    message.sendToTarget();
    <span class="keyword">return</span> result;
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>{
    <span class="annotation">@SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>})
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{
        AsyncTaskResult result = (AsyncTaskResult) msg.obj;
        <span class="keyword">switch</span> (msg.what) {
            <span class="keyword">case</span> MESSAGE_POST_RESULT:
                <span class="comment">// There is only one result</span>
                result.mTask.finish(result.mData[<span class="number">0</span>]);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:
                result.mTask.onProgressUpdate(result.mData);
                <span class="keyword">break</span>;
        }
    }
}


<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>{
    <span class="keyword">if</span> (isCancelled()) {
        onCancelled(result);
    } <span class="keyword">else</span> {
        onPostExecute(result);
    }
    mStatus = Status.FINISHED;
}
</code></pre>
<p>可以看到，postResult就是把一个消息( msg.what == MESSAGE_POST_RESULT)发送给sHandler，sHandler类型为InternalHandler类型，当InternalHandler接到MESSAGE_POST_RESULT类型的消息时就会调用result.mTask.finish(result.mData[0])方法。我们可以看到result为AsyncTaskResult类型，源码如下  :     </p>
<pre><code class="java"><span class="annotation">@SuppressWarnings</span>({<span class="string">"RawUseOfParameterizedType"</span>})
<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>{
    <span class="keyword">final</span> AsyncTask mTask;
    <span class="keyword">final</span> Data[] mData;

    AsyncTaskResult(AsyncTask task, Data... data) {
        mTask = task;
        mData = data;
    }
}
</code></pre>
<p><strong>可以看到mTask就是AsyncTask对象</strong>，调用AsyncTask对象的finish方法时又调用了onPostExecute，这个时候整个执行过程就完成了。<br>    总之，execute方法内部封装了onPreExecute, doInBackground, onPostExecute这个算法框架，用户可以根据自己的需求来在覆写这几个方法，使得用户可以很方便的使用异步任务来完成耗时操作，又可以通过onPostExecute来完成更新UI线程的工作。<br>    另一个比较好的模板方法示例就是Activity的声明周期函数，例如Activity从onCreate、onStart、onResume这些程式化的执行模板，这就是一个Activity的模板方法。       </p>
<h2 id="4-_杂谈">4. 杂谈</h2><h3 id="优点与缺点">优点与缺点</h3><h4 id="优点">优点</h4><ul>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>模板方法会带来代码阅读的难度，会让心觉得难以理解。 </li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中 模板方法模式 分析<br>Android系统版本： 2.3<br>分析者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，分析状态：完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>]]>
    
    </summary>
    
      <category term="模板方法模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 开源项目源码解析之 依赖注入]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android-open-project-analysis_dependency-injection/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android-open-project-analysis_dependency-injection/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:58:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_依赖">1. 依赖</h3><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        father = <span class="keyword">new</span> Father();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细看这段代码我们会发现存在一些问题：<br>(1). 如果现在要改变 father 生成方式，如需要用<code>new Father(String name)</code>初始化 father，需要修改 Human 代码；<br>(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；<br>(3). 如果<code>new Father()</code>过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。  </p>
<h3 id="2-_依赖注入">2. 依赖注入</h3><p>上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">(Father father)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.father = father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。<strong>像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。</strong><br>现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：<br>(1). 解耦，将依赖之间解耦。<br>(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。  </p>
<h3 id="3-_Java_中的依赖注入">3. Java 中的依赖注入</h3><p>依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Inject</span> Father father;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？</p>
<p>实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 <a href="https://github.com/google/guice" target="_blank" rel="external">Google Guice</a>、<a href="http://projects.spring.io/spring-framework/" target="_blank" rel="external">Spring</a> 等，而在 Android 上比较流行的有 <a href="https://github.com/roboguice/roboguice" target="_blank" rel="external">RoboGuice</a>、<a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger</a> 等。其中 Dagger 是我现在正在项目中使用的。如果感兴趣，你可以到 <a href="https://github.com/android-cn/android-open-project-analysis/tree/master/dagger" target="_blank" rel="external">Dagger 实现原理解析</a> 了解更多依赖注入和 Dagger 实现原理相关信息。</p>
<blockquote>
<p>本文为 <a href="https://github.com/android-cn/android-open-project-analysis" target="_blank" rel="external">Android 开源项目源码解析</a> 公共技术点中的 依赖注入 部分<br> 分析者：<a href="https://github.com/rengwuxian" target="_blank" rel="external">扔物线</a>，校对者：<a href="https://github.com/Trinea" target="_blank" rel="external">Trinea</a>，校对状态：完成  </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_依赖">1. 依赖</h3><p>如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。<br>]]>
    
    </summary>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
      <category term="连载" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/"/>
    
      <category term="开源项目解析" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%BF%9E%E8%BD%BD/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之策略模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_strategy/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_strategy/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:58:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p><strong>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</strong><br><a id="more"></a><br><code>注：针对同一类型操作，将复杂多样的处理方式分别开来，有选择的实现各自特有的操作。</code></p>
<h3 id="模式的使用场景">模式的使用场景</h3><ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象多个子类，而又需要使用if-else 或者 switch-case来选择时。</li>
</ul>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml.png" alt="url">  </p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Strategy : 策略的抽象。</li>
<li>ConcreteStrategyA、ConcreteStrategyB : 具体的策略实现。</li>
</ul>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>通常如果一个问题有多个解决方案或者稍有区别的操作时，最简单的方式就是利用if-else or switch-case方式来解决，对于简单的解决方案这样做无疑是比较简单、方便、快捷的，但是如果解决方案中包括大量的处理逻辑需要封装，或者处理方式变动较大的时候则就显得混乱、复杂，而策略模式则很好的解决了这样的问题，它将各种方案分离开来，让操作者根据具体的需求来动态的选择不同的策略方案。<br>这里以简单的计算操作(+、-、*、/)作为示例：</p>
<h3 id="未使用策略模式">未使用策略模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(String op, <span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="string">"+"</span>.equals(op)) &#123;</span><br><span class="line">		System.out.println(<span class="string">"执行加法..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA + paramB;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-"</span>.equals(op)) &#123;</span><br><span class="line">		System.out.println(<span class="string">"执行减法..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA - paramB;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(op)) &#123;</span><br><span class="line">		System.out.println(<span class="string">"执行乘法..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA * paramB;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/"</span>.equals(op)) &#123;</span><br><span class="line">		System.out.println(<span class="string">"执行除法..."</span>);</span><br><span class="line">		<span class="keyword">if</span> (paramB == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"除数不能为0!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> paramA / paramB;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"未找到计算方法!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用策略模式">使用策略模式</h3><p>UML类图<br><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml-calc.png" alt="url">  </p>
<ul>
<li>Calc：进行计算操作的上下文环境。</li>
<li>Strategy : 计算操作的抽象。</li>
<li>AddStrategy、SubStrategy、MultiStrategy、DivStrategy : 具体的 +、-、*、/ 实现。</li>
</ul>
<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对操作进行抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法的具体实现策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"执行加法策略..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA + paramB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法的具体实现策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"执行减法策略..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA - paramB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法的具体实现策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"执行乘法策略..."</span>);</span><br><span class="line">		<span class="keyword">return</span> paramA * paramB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法的具体实现策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"执行除法策略..."</span>);</span><br><span class="line">		<span class="keyword">if</span> (paramB == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"除数不能为0!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> paramA / paramB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文环境的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Strategy strategy;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// doing something</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"你还没有设置计算的策略"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.strategy.calc(paramA, paramB);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(Strategy strategy, <span class="keyword">double</span> paramA, <span class="keyword">double</span> paramB)</span> </span>&#123;</span><br><span class="line">	Calc calc = <span class="keyword">new</span> Calc();</span><br><span class="line">	calc.setStrategy(strategy);</span><br><span class="line">	<span class="keyword">return</span> calc.calc(paramA, paramB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二者运行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> paramA = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">double</span> paramB = <span class="number">21</span>;</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"------------- 普通形式 ----------------"</span>);</span><br><span class="line">	System.out.println(<span class="string">"加法结果是："</span> + calc(<span class="string">"+"</span>, paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"减法结果是："</span> + calc(<span class="string">"-"</span>, paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"乘法结果是："</span> + calc(<span class="string">"*"</span>, paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"除法结果是："</span> + calc(<span class="string">"/"</span>, paramA, paramB));</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"------------ 策略模式  ----------------"</span>);</span><br><span class="line">	System.out.println(<span class="string">"加法结果是："</span> + calc(<span class="keyword">new</span> AddStrategy(), paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"减法结果是："</span> + calc(<span class="keyword">new</span> SubStrategy(), paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"乘法结果是："</span> + calc(<span class="keyword">new</span> MultiStrategy(), paramA, paramB));</span><br><span class="line">	System.out.println(<span class="string">"除法结果是："</span> + calc(<span class="keyword">new</span> DivStrategy(), paramA, paramB));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml-calc-result.png" alt="url">  </p>
<h3 id="总结">总结</h3><p>通过简单的代码可以清晰的看出二者的优势所在，前者通过简单的if-else来解决问题，在解决简单问题事会更简单、方便，后者则是通过给予不同的具体策略来获取不同的结果，对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。</p>
<h2 id="Android源码中的模式实现">Android源码中的模式实现</h2><p>日常的Android开发中经常会用到动画，Android中最简单的动画就是Tween Animation了，当然帧动画和属性动画也挺方便的，但是基本原理都类似，毕竟动画的本质都是一帧一帧的展现给用户的，只不要当fps小于60的时候，人眼基本看不出间隔，也就成了所谓的流畅动画。（注：属性动画是3.0以后才有的，低版本可采用<a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="external">NineOldAndroids</a>来兼容。而动画的动态效果往往也取决于插值器Interpolator不同，我们只需要对Animation对象设置不同的Interpolator就可以实现不同的效果，这是怎么实现的呢？</p>
<p>首先要想知道动画的执行流程，还是得从View入手，因为Android中主要针对的操作对象还是View，所以我们首先到View中查找，我们找到了View.startAnimation(Animation animation)这个方法。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化动画开始时间</span></span><br><span class="line">       animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">	<span class="comment">//对View设置动画</span></span><br><span class="line">       setAnimation(animation); </span><br><span class="line">	<span class="comment">//刷新父类缓存</span></span><br><span class="line">       invalidateParentCaches();</span><br><span class="line">	<span class="comment">//刷新View本身及子View</span></span><br><span class="line">       invalidate(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>考虑到View一般不会单独存在，都是存在于某个ViewGroup中，所以google使用动画绘制的地方选择了在ViewGroup中的drawChild(Canvas canvas, View child, long drawingTime)方法中进行调用子View的绘制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>再看下View中的draw(Canvas canvas, ViewGroup parent, long drawingTime)方法中是如何调用使用Animation的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查看是否需要清除动画信息</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) == ViewGroup.FLAG_CLEAR_TRANSFORMATION) &#123;</span><br><span class="line">           parent.getChildTransformation().clear();</span><br><span class="line">           parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取设置的动画信息</span></span><br><span class="line">   	<span class="keyword">final</span> Animation a = getAnimation();</span><br><span class="line">       <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//绘制动画</span></span><br><span class="line">           more = drawAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">           concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">           <span class="keyword">if</span> (concatMatrix) &#123;</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">           &#125;</span><br><span class="line">           transformToApply = parent.getChildTransformation();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在父类调用View的draw方法中，会先判断是否设置了清除到需要做该表的标记，然后再获取设置的动画的信息，如果设置了动画，就会调用View中的drawAnimation方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span><br><span class="line">           Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Transformation invalidationTransform;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">	<span class="comment">//判断动画是否已经初始化过</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</span><br><span class="line">       <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">           a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</span><br><span class="line">           a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">           <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</span><br><span class="line">           onAnimationStart();</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断View是否需要进行缩放</span></span><br><span class="line">	<span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line">       <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</span><br><span class="line">       <span class="keyword">if</span> (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != <span class="number">1f</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (parent.mInvalidationTransformation == <span class="keyword">null</span>) &#123;</span><br><span class="line">               parent.mInvalidationTransformation = <span class="keyword">new</span> Transformation();</span><br><span class="line">           &#125;</span><br><span class="line">           invalidationTransform = parent.mInvalidationTransformation;</span><br><span class="line">           a.getTransformation(drawingTime, invalidationTransform, <span class="number">1f</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           invalidationTransform = t;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (more) &#123;</span><br><span class="line">		<span class="comment">//根据具体实现，判断当前动画类型是否需要进行调整位置大小，然后刷新不同的区域</span></span><br><span class="line">           <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">				</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要的操作是动画始化、动画操作、界面刷新。动画的具体实现是调用了Animation中的getTransformation(long currentTime, Transformation outTransformation,float scale)方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation,</span><br><span class="line">           <span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">       mScaleFactor = scale;</span><br><span class="line">       <span class="keyword">return</span> getTransformation(currentTime, outTransformation);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中主要是获取缩放系数和调用Animation.getTransformation(long currentTime, Transformation outTransformation)来计算和应用动画效果。</p>
<pre><code class="java">Interpolator mInterpolator;  <span class="comment">//成员变量</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>{
        <span class="comment">//计算处理当前动画的时间点...</span>
        <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);
        <span class="comment">//后续处理，以此来应用动画效果...</span>
        applyTransformation(interpolatedTime, outTransformation);
    <span class="keyword">return</span> mMore;
}
</code></pre>
<p>很容易发现Android系统中在处理动画的时候会调用插值器中的getInterpolation(float input)方法来获取当前的时间点，依次来计算当前变化的情况。这就不得不说到Android中的插值器Interpolator，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画）、AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）和DecelerateInterpolator（减速插值器：动画越来越慢）等，如图：</p>
<p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml-android-interpolator.png" alt="url"> </p>
<p>由于初期比较旧的版本采用的插值器是TimeInterpolator抽象，google采用了多加一层接口继承来实现兼容也不足为怪了。很显然策略模式在这里作了很好的实现，Interpolator就是处理动画时间的抽象，LinearInterpolator、CycleInterpolator等插值器就是具体的实现策略。插值器与Animation的关系图如下：</p>
<p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml-android.png" alt="url"> </p>
<p>这里以LinearInterpolator和CycleInterpolator为例：</p>
<ul>
<li><p>LinearInterpolator</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>{
    <span class="keyword">return</span> input;
}
</code></pre></li>
<li><p>CycleInterpolator</p>
<pre><code>  <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>{
    <span class="keyword">return</span> (<span class="keyword">float</span>)(Math.<span class="built_in">sin</span>(<span class="number">2</span> * mCycles * Math.PI * input));
}    
</code></pre></li>
</ul>
<p>可以看出LinearInterpolator中计算当前时间的方法是做线性运算，也就是返回input*1，所以动画会成直线匀速播放出来，而CycleInterpolator是按照正弦运算，所以动画会正反方向跑一次，其它插值器依次类推。不同的插值器的计算方法都有所差别，用户设置插值器以实现动画速率的算法替换。       </p>
<h2 id="4-_杂谈">4. 杂谈</h2><p>策略模式主要用来分离算法，根据相同的行为抽象来做不同的具体策略实现。</p>
<p>通过以上也可以看出策略模式的优缺点：</p>
<p>优点：</p>
<ul>
<li>结构清晰明了、使用简单直观。</li>
<li>耦合度相对而言较低，扩展方便。</li>
<li>操作封装也更为彻底，数据更为安全。</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着策略的增加，子类也会变得繁多。</li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中策略模式分析<br>Android系统版本：4.4.2<br>分析者：<a href="https://github.com/GKerison" target="_blank" rel="external">GKerison</a>，分析状态：已完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p><strong>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</strong><br>]]>
    
    </summary>
    
      <category term="策略模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之单例模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_singleton/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_singleton/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:58:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br><a id="more"></a></p>
<h3 id="模式的使用场景">模式的使用场景</h3><p>确保某个类有且只有一个对象的场景，例如创建一个对象需要消耗的资源过多，如要访问 IO 和数据库等资源。</p>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/singleton/mr.simple/images/singleton-mr.simple-uml.png" alt="url">  </p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li>Client : 高层客户端。</li>
<li>Singleton : 单例类。</li>
</ul>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>单例模式是设计模式中最简单的，只有一个单例类，没有其他的层次结构与抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗太多的资源或者没有没有多个实例的理由。例如一个公司只有一个CEO、一台电脑通常只有一个显示器等。下面我们以公司里的CEO为例来简单演示一下，一个公司可以有几个VP，无数个员工，但是CEO只有一个，请看下面示例。 </p>
<h3 id="实现源码">实现源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dp.example.singleton;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 人的基类</span><br><span class="line"> * <span class="doctag">@author</span> mrsimple</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 副总裁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VP</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CEO， 单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CEO mCeo = <span class="keyword">new</span> CEO();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">getCeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mCeo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CEO发表讲话"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公司类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Person&gt; allPersons = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStaff</span><span class="params">(Person per)</span> </span>&#123;</span><br><span class="line">		allPersons.add(per);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAllStaffs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Person per : allPersons) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Obj : "</span> + per.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Company cp = <span class="keyword">new</span> Company() ;</span><br><span class="line">		Person ceo1 = CEO.getCeo() ;</span><br><span class="line">		Person ceo2 = CEO.getCeo() ;</span><br><span class="line">		cp.addStaff(ceo1);</span><br><span class="line">		cp.addStaff(ceo2);</span><br><span class="line">		</span><br><span class="line">		Person vp1 = <span class="keyword">new</span> VP() ;</span><br><span class="line">		Person vp2 = <span class="keyword">new</span> VP() ;</span><br><span class="line">		</span><br><span class="line">		Person staff1 = <span class="keyword">new</span> Staff() ;</span><br><span class="line">		Person staff2 = <span class="keyword">new</span> Staff() ;</span><br><span class="line">		Person staff3 = <span class="keyword">new</span> Staff() ;</span><br><span class="line">		</span><br><span class="line">		cp.addStaff(vp1);</span><br><span class="line">		cp.addStaff(vp2);</span><br><span class="line">		cp.addStaff(staff1);</span><br><span class="line">		cp.addStaff(staff2);</span><br><span class="line">		cp.addStaff(staff3);</span><br><span class="line">		</span><br><span class="line">		cp.showAllStaffs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下 :<br><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/singleton/mr.simple/images/singleton-mr.simple-result.png" alt="result">    </p>
<p>可以看到, CEO两次输出的CEO对象的文字描述都是一样的，而VP、Staff类的对象都是不同的。即CEO是唯一实例，而其他类型都是不同的实例。这个实现的核心在于将CEO类的构造方法私有化，使得外部程序不能通过构造函数来构造CEO对象，而CEO类通过一个静态方法返回一个唯一的对象。</p>
<h3 id="单例模式的其他实现">单例模式的其他实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dp.example.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 方式二、double-check， 避免并发时创建了多个实例, 该方式不能完全避免并发带来的破坏.</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					mInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 方式三 : 在第一次加载SingletonHolder时初始化一次mOnlyInstance对象, 保证唯一性, 也延迟了单例的实例化,</span><br><span class="line">	 * 如果该单例比较耗资源可以使用这种模式.</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstanceFromHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.mOnlyInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 静态内部类</span><br><span class="line">	 * </span><br><span class="line">	 * <span class="doctag">@author</span> mrsimple</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton mOnlyInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 *  方式四 : 枚举单例, 线程安全</span><br><span class="line">	 * <span class="doctag">@author</span> mrsimple</span><br><span class="line">	 *</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">		INSTANCE;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"do sth."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 方式五 : 注册到容器, 根据key获取对象.一般都会有多种相同属性类型的对象会注册到一个map中</span><br><span class="line">	 * instance容器</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;string singleton=<span class="string">""</span>&gt; objMap = <span class="keyword">new</span> HashMap&lt;string singleton=<span class="string">""</span>&gt;();</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 注册对象到map中</span><br><span class="line">	 * <span class="doctag">@param</span> key</span><br><span class="line">	 * <span class="doctag">@param</span> instance</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Singleton instance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">			objMap.put(key, instance) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * 根据key获取对象</span><br><span class="line">	 * <span class="doctag">@param</span> key</span><br><span class="line">	 * <span class="doctag">@return</span></span><br><span class="line">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。       </p>
<h2 id="Android源码中的模式实现">Android源码中的模式实现</h2><p>在Android系统中，我们经常会通过Context获取系统级别的服务，比如WindowsManagerService, ActivityManagerService等，更常用的是一个叫LayoutInflater的类。这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过Context的getSystemService(String name)获取。我们以LayoutInflater为例来说明, 平时我们使用LayoutInflater较为常见的地方是在ListView的getView方法中。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span>	</span><br><span class="line">	View itemView </span>= <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">		itemView = LayoutInflater.from(mContext).inflate(mLayoutId, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">// 其他代码</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		itemView = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取Holder</span></span><br><span class="line">	<span class="comment">// 初始化每项的数据</span></span><br><span class="line">	<span class="keyword">return</span> itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常我们使用LayoutInflater.from(Context)来获取LayoutInflater服务, 下面我们看看LayoutInflater.from(Context)的实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Obtains the LayoutInflater from the given context.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span>(<span class="params">Context context</span>) </span>&#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到from(Context)函数内部调用的是Context类的getSystemService(String key)方法，我们跟踪到Context类看到, 该类是抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的getView中使用的Context对象的具体实现类是什么呢 ？其实在Application，Activity, Service,中都会存在一个Context对象，即Context的总个数为Activity个数 + Service个数 + 1。而ListView通常都是显示在Activity中，那么我们就以Activity中的Context来分析。    </p>
<p>我们知道，一个Activity的入口是ActivityThread的main函数。在该main函数中创建一个新的ActivityThread对象，并且启动消息循环(UI线程)，创建新的Activity、新的Context对象，然后将该Context对象传递给Activity。下面我们看看ActivityThread源码。    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">        <span class="comment">// 主线程消息循环</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="comment">// 创建ActivityThread对象</span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AsyncTask.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">this</span>);</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ensureJitEnabled();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                    UserHandle.myUserId());</span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 省略</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中，我们创建一个ActivityThread对象后，调用了其attach函数，并且参数为false. 在attach函数中， 参数为false的情况下， 会通过Binder机制与ActivityManagerService通信，并且最终调用handleLaunchActivity函数 ( 具体分析请参考老罗的博客 : <a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="external">Activity的启动流程</a>)，我们看看该函数的实现 。     </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(         <span class="comment">// 1 : 创建Activity</span></span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">     <span class="comment">// 代码省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity); <span class="comment">// 2 : 获取Context对象</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="comment">// 3: 将appContext等对象attach到activity中</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 代码省略</span></span><br><span class="line">            <span class="comment">// 4 ： 调用Activity的onCreate方法</span></span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            <span class="comment">// 代码省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Context <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r,</span><br><span class="line">        <span class="keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 5 ： 创建Context对象, 可以看到实现类是ContextImpl</span></span><br><span class="line">    ContextImpl appContext = <span class="keyword">new</span> ContextImpl();           appContext.init(r.packageInfo, r.token, <span class="keyword">this</span>);</span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    <span class="keyword">return</span> baseContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面1~5的代码分析可以知道， Context的实现类为ComtextImpl类。我们继续跟踪到ContextImpl类。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Override this class when the system service constructor needs a</span><br><span class="line">     * ContextImpl.  Else, use StaticServiceFetcher below.</span><br><span class="line">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFetcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mContextCacheIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Main entrypoint; only override if you don't need caching.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">            ArrayList&lt;Object&gt; cache = ctx.mServiceCache;</span><br><span class="line">            Object service;</span><br><span class="line">            <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sNextPerContextServiceCacheIndex; i++) &#123;</span><br><span class="line">                        cache.add(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    service = cache.get(mContextCacheIndex);</span><br><span class="line">                    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> service;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                service = createService(ctx);</span><br><span class="line">                cache.set(mContextCacheIndex, service);</span><br><span class="line">                <span class="keyword">return</span> service;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Override this to create a new per-Context instance of the</span><br><span class="line">         * service.  getService() will handle locking and caching.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 : service容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&gt; SYSTEM_SERVICE_MAP =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sNextPerContextServiceCacheIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2: 注册服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, ServiceFetcher fetcher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(fetcher <span class="keyword">instanceof</span> StaticServiceFetcher)) &#123;</span><br><span class="line">            fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        SYSTEM_SERVICE_MAP.put(serviceName, fetcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3: 静态语句块, 第一次加载该类时执行 ( 只执行一次, 保证实例的唯一性. )</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//  代码省略</span></span><br><span class="line">        <span class="comment">// 注册Activity Servicer</span></span><br><span class="line">        registerService(ACTIVITY_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">                &#125;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册LayoutInflater service</span></span><br><span class="line">        registerService(LAYOUT_INFLATER_SERVICE, <span class="keyword">new</span> ServiceFetcher() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> PolicyManager.makeNewLayoutInflater(ctx.getOuterContext());</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">        <span class="comment">// 代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4: 根据key获取对应的服务, </span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据name来获取服务</span></span><br><span class="line">        ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</span><br><span class="line">        <span class="keyword">return</span> fetcher == <span class="keyword">null</span> ? <span class="keyword">null</span> : fetcher.getService(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从ContextImpl类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种服务，其中就包含了LayoutInflater Service, 将这些服务以键值对的形式存储在一个HashMap中，用户使用时只需要根据key来获取到对应的服务，从而达到单例的效果。这种模式就是上文中提到的“单例模式的实现方式5”。系统核心服务以单例形式存在，减少了资源消耗。         </p>
<h2 id="4-_杂谈">4. 杂谈</h2><h3 id="优点与缺点">优点与缺点</h3><h4 id="优点">优点</h4><ul>
<li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li>
<li>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 </li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中 单例模式 分析<br>Android系统版本： 2.3<br>分析者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，分析状态：完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：完成   </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_模式介绍">1. 模式介绍</h2><h3 id="模式的定义">模式的定义</h3><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<br>]]>
    
    </summary>
    
      <category term="单例模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计模式源码解析之Proxy模式]]></title>
    <link href="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_proxy/"/>
    <id>http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/2015/05/02/android_design_patterns_analysis_proxy/</id>
    <published>2015-05-01T16:00:00.000Z</published>
    <updated>2015-06-30T13:16:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Binder中的代理模式">Binder中的代理模式</h1><p>再说Binder中的代理模式之前，我们需要先看看代理模式的简单实现，这一部分内容采用了<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html" target="_blank" rel="external">《JAVA与模式》之代理模式</a>这篇文章中的代码示例和uml类图。<br><a id="more"></a></p>
<h2 id="1-_模式介绍">1. 模式介绍</h2><p>代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p>
<h3 id="模式的使用场景">模式的使用场景</h3><p>就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<h2 id="2-_UML类图">2. UML类图</h2><p><img src="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis/raw/master/proxy/singwhatiwanna/images/proxy-uml.png" alt="url"></p>
<h3 id="角色介绍">角色介绍</h3><ul>
<li><p>抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</p>
</li>
<li><p>目标对象角色：定义了代理对象所代表的目标对象。</p>
</li>
<li><p>代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</p>
</li>
</ul>
<h2 id="3-_模式的简单实现">3. 模式的简单实现</h2><h3 id="简单实现的介绍">简单实现的介绍</h3><p>下面通过一种抽象的方式来实现下代理模式</p>
<h3 id="实现源码">实现源码</h3><p>抽象对象角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标对象角色</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractObject</span> &#123;</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        <span class="comment">//一些操作</span></span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"一些操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理对象角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span></span>&#123;</span><br><span class="line">    RealObject realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用目标对象之前可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"before"</span>);        </span><br><span class="line">        realObject.operation();        </span><br><span class="line">        <span class="comment">//调用目标对象之后可以做相关操作</span></span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractObject obj = <span class="keyword">new</span> ProxyObject();</span><br><span class="line">        obj.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-_代理模式在Binder中的使用">4. 代理模式在Binder中的使用</h2><p>直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<p>Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。</p>
<p>为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。</p>
<ol>
<li>先定义一个Binder接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ryg.design.manualbinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.IInterface;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBank</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTOR = <span class="string">"com.ryg.design.manualbinder.IBank"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">queryMoney</span><span class="params">(<span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建一个Binder并实现这个上述接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ryg.design.manualbinder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankImpl</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IBank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BankImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IBank <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> IBank))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((IBank) iin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BankImpl.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span><br><span class="line">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_queryMoney: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">int</span> uid = data.readInt();</span><br><span class="line">            <span class="keyword">long</span> result = <span class="keyword">this</span>.queryMoney(uid);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeLong(result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">queryMoney</span><span class="params">(<span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid * <span class="number">10l</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">IBank</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> IBinder mRemote;</span><br><span class="line"></span><br><span class="line">        Proxy(IBinder remote) &#123;</span><br><span class="line">            mRemote = remote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mRemote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">queryMoney</span><span class="params">(<span class="keyword">int</span> uid)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            <span class="keyword">long</span> result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                data.writeInt(uid);</span><br><span class="line">                mRemote.transact(TRANSACTION_queryMoney, data, reply, <span class="number">0</span>);</span><br><span class="line">                reply.readException();</span><br><span class="line">                result = reply.readLong();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reply.recycle();</span><br><span class="line">                data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。</p>
<p>我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxy(IBinder remote) &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。</p>
<h2 id="5-_杂谈">5. 杂谈</h2><h3 id="优点与缺点">优点与缺点</h3><h4 id="优点">优点</h4><ul>
<li>给对象增加了本地化的扩展性，增加了存取操作控制</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>会产生多余的代理类</li>
</ul>
<blockquote>
<p>本文为 <a href="https://github.com/simple-android-framework-exchange/android_design_patterns_analysis" target="_blank" rel="external">Android 设计模式源码解析</a> 中 Proxy模式 分析<br>Android系统版本： 5.0<br>分析者：<a href="https://github.com/singwhatiwanna" target="_blank" rel="external">singwhatiwanna</a>，分析状态：完成，校对者：<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>，校对状态：未校对     </p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Binder中的代理模式">Binder中的代理模式</h1><p>再说Binder中的代理模式之前，我们需要先看看代理模式的简单实现，这一部分内容采用了<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html">《JAVA与模式》之代理模式</a>这篇文章中的代码示例和uml类图。<br>]]>
    
    </summary>
    
      <category term="Proxy模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/tags/Proxy%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://likebamboo.com/AndroidBloghttp://likebamboo.com/AndroidBlog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>